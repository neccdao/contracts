{
  "language": "Solidity",
  "sources": {
    "contracts/facets/Treasury/TreasuryFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./Facet.sol\";\n\ninterface IBondCalculator {\n    function valuation(address pair_, uint256 amount_)\n        external\n        view\n        returns (uint256 _value);\n}\n\ninterface IERC20Mintable {\n    function decimals() external view returns (uint256);\n\n    function mint(uint256 amount_) external;\n\n    function mint(address account_, uint256 ammount_) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n\ncontract TreasuryFacet is Facet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed token, uint256 amount, uint256 value);\n    event Withdrawal(address indexed token, uint256 amount, uint256 value);\n    event CreateDebt(\n        address indexed debtor,\n        address indexed token,\n        uint256 amount,\n        uint256 value\n    );\n    event RepayDebt(\n        address indexed debtor,\n        address indexed token,\n        uint256 amount,\n        uint256 value\n    );\n    event ReservesManaged(address indexed token, uint256 amount);\n    event ReservesUpdated(uint256 indexed totalReserves);\n    event ReservesAudited(uint256 indexed totalReserves);\n    event RewardsMinted(\n        address indexed caller,\n        address indexed recipient,\n        uint256 amount\n    );\n    event ChangeQueued(MANAGING indexed managing, address queued);\n    event ChangeActivated(\n        MANAGING indexed managing,\n        address activated,\n        bool result\n    );\n\n    enum MANAGING {\n        RESERVEDEPOSITOR,\n        RESERVESPENDER,\n        RESERVETOKEN,\n        RESERVEMANAGER,\n        LIQUIDITYDEPOSITOR,\n        LIQUIDITYTOKEN,\n        LIQUIDITYMANAGER,\n        DEBTOR,\n        REWARDMANAGER,\n        NNECC\n    }\n\n    function initializeTreasury(\n        address _Necc,\n        address _NDOL,\n        uint256 _blocksNeededForQueue\n    ) external {\n        onlyGov();\n        require(_Necc != address(0));\n        s.Necc = _Necc;\n\n        s.isReserveToken[_NDOL] = true;\n        s.reserveTokens.push(_NDOL);\n\n        s.blocksNeededForQueue = _blocksNeededForQueue;\n    }\n\n    /**\n        @notice send epoch reward to staking contract\n     */\n    function mintRewards(address _recipient, uint256 _amount) external {\n        require(s.isRewardManager[msg.sender], \"Treasury: Not approved\");\n        require(_amount <= excessReserves(), \"Treasury: Insufficient reserves\");\n\n        IERC20Mintable(s.Necc).mint(_recipient, _amount);\n\n        emit RewardsMinted(msg.sender, _recipient, _amount);\n    }\n\n    /**\n        @notice allow approved address to deposit an asset for Necc\n        @param _amount uint\n        @param _token address\n        @param _profit uint\n        @return send_ uint\n     */\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256 send_) {\n        require(\n            s.isReserveToken[_token] || s.isLiquidityToken[_token],\n            \"Treasury: Not accepted\"\n        );\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (s.isReserveToken[_token]) {\n            require(s.isReserveDepositor[msg.sender], \"Treasury: Not approved\");\n        } else {\n            require(\n                s.isLiquidityDepositor[msg.sender],\n                \"Treasury: Not approved\"\n            );\n        }\n\n        uint256 value = valueOfToken(_token, _amount);\n        // mint Necc needed and store amount of rewards for distribution\n        send_ = value.sub(_profit);\n        IERC20Mintable(s.Necc).mint(msg.sender, send_);\n\n        s.totalReserves = s.totalReserves.add(value);\n        emit ReservesUpdated(s.totalReserves);\n\n        emit Deposit(_token, _amount, value);\n\n        return send_;\n    }\n\n    /**\n        @notice allow approved address to burn Necc for reserves\n        @param _amount uint\n        @param _token address\n     */\n    function withdraw(uint256 _amount, address _token) external {\n        require(s.isReserveToken[_token], \"Treasury: Not accepted\"); // Only reserves can be used for redemptions\n        require(\n            s.isReserveSpender[msg.sender] == true,\n            \"Treasury: Not approved\"\n        );\n\n        uint256 _value = valueOfToken(_token, _amount);\n        IERC20Mintable(s.Necc).burnFrom(msg.sender, _value);\n\n        s.totalReserves = s.totalReserves.sub(_value);\n        emit ReservesUpdated(s.totalReserves);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n\n        emit Withdrawal(_token, _amount, _value);\n    }\n\n    /**\n        @notice allow approved address to borrow reserves\n        @param _amount uint\n        @param _token address\n     */\n    function incurDebt(uint256 _amount, address _token) external {\n        require(s.isDebtor[msg.sender], \"Treasury: Not approved\");\n        require(s.isReserveToken[_token], \"Treasury: Not accepted\");\n\n        uint256 _value = valueOfToken(_token, _amount);\n\n        uint256 maximumDebt = IERC20(s.nNecc).balanceOf(msg.sender); // Can only borrow against nNecc held\n        uint256 availableDebt = maximumDebt.sub(s.debtorBalance[msg.sender]);\n        require(_value <= availableDebt, \"Exceeds debt limit\");\n\n        s.debtorBalance[msg.sender] = s.debtorBalance[msg.sender].add(_value);\n        s.totalDebt = s.totalDebt.add(_value);\n\n        s.totalReserves = s.totalReserves.sub(_value);\n        emit ReservesUpdated(s.totalReserves);\n\n        IERC20(_token).transfer(msg.sender, _amount);\n\n        emit CreateDebt(msg.sender, _token, _amount, _value);\n    }\n\n    /**\n        @notice allow approved address to repay borrowed reserves with reserves\n        @param _amount uint\n        @param _token address\n     */\n    function repayDebtWithReserve(uint256 _amount, address _token) external {\n        require(s.isDebtor[msg.sender], \"Treasury: Not approved\");\n        require(s.isReserveToken[_token], \"Treasury: Not accepted\");\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 _value = valueOfToken(_token, _amount);\n        s.debtorBalance[msg.sender] = s.debtorBalance[msg.sender].sub(_value);\n        s.totalDebt = s.totalDebt.sub(_value);\n\n        s.totalReserves = s.totalReserves.add(_value);\n        emit ReservesUpdated(s.totalReserves);\n\n        emit RepayDebt(msg.sender, _token, _amount, _value);\n    }\n\n    /**\n        @notice allow approved address to repay borrowed reserves with Necc\n        @param _amount uint\n     */\n    function repayDebtWithNecc(uint256 _amount) external {\n        require(s.isDebtor[msg.sender], \"Treasury: Not approved\");\n\n        IERC20Mintable(s.Necc).burnFrom(msg.sender, _amount);\n\n        s.debtorBalance[msg.sender] = s.debtorBalance[msg.sender].sub(_amount);\n        s.totalDebt = s.totalDebt.sub(_amount);\n\n        emit RepayDebt(msg.sender, s.Necc, _amount, _amount);\n    }\n\n    /**\n        @notice allow approved address to withdraw assets\n        @param _token address\n        @param _amount uint\n     */\n    function manage(address _token, uint256 _amount) external {\n        if (s.isLiquidityToken[_token]) {\n            require(s.isLiquidityManager[msg.sender], \"Treasury: Not approved\");\n        } else {\n            require(s.isReserveManager[msg.sender], \"Treasury: Not approved\");\n        }\n\n        uint256 _value = valueOfToken(_token, _amount);\n        (_token, _amount);\n        require(_value <= excessReserves(), \"Treasury: Insufficient reserves\");\n\n        s.totalReserves = s.totalReserves.sub(_value);\n        emit ReservesUpdated(s.totalReserves);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n\n        emit ReservesManaged(_token, _amount);\n    }\n\n    /**\n        @notice returns excess reserves not backing tokens\n        @return uint\n     */\n    function excessReserves() public view returns (uint256) {\n        return\n            s.totalReserves.sub(IERC20(s.Necc).totalSupply().sub(s.totalDebt));\n    }\n\n    /**\n        @notice takes inventory of all tracked assets\n        @notice always consolidate to recognized reserves before audit\n     */\n    function auditReserves() external {\n        onlyGov();\n        uint256 reserves;\n        for (uint256 i = 0; i < s.reserveTokens.length; i++) {\n            reserves = reserves.add(\n                valueOfToken(\n                    s.reserveTokens[i],\n                    IERC20(s.reserveTokens[i]).balanceOf(address(this))\n                )\n            );\n        }\n        for (uint256 i = 0; i < s.liquidityTokens.length; i++) {\n            reserves = reserves.add(\n                valueOfToken(\n                    s.liquidityTokens[i],\n                    IERC20(s.liquidityTokens[i]).balanceOf(address(this))\n                )\n            );\n        }\n        s.totalReserves = reserves;\n        emit ReservesUpdated(reserves);\n        emit ReservesAudited(reserves);\n    }\n\n    /**\n        @notice returns Necc valuation of asset\n        @param _token address\n        @param _amount uint\n        @return _value uint\n     */\n    function valueOfToken(address _token, uint256 _amount)\n        public\n        view\n        returns (uint256 _value)\n    {\n        if (s.isReserveToken[_token]) {\n            // convert amount to match Necc decimals\n            _value = _amount.mul(10**IERC20Mintable(s.Necc).decimals()).div(\n                10**IERC20Mintable(_token).decimals()\n            );\n        } else if (s.isLiquidityToken[_token]) {\n            _value = IBondCalculator(address(this)).valuation(_token, _amount);\n        }\n    }\n\n    /**\n        @notice queue address to change boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n    function queue(MANAGING _managing, address _address)\n        external\n        returns (bool)\n    {\n        onlyGov();\n        require(_address != address(0));\n        if (_managing == MANAGING.RESERVEDEPOSITOR) {\n            // 0\n            s.reserveDepositorQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVESPENDER) {\n            // 1\n            s.reserveSpenderQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVETOKEN) {\n            // 2\n            s.reserveTokenQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVEMANAGER) {\n            // 3\n            s.ReserveManagerQueue[_address] = block.number.add(\n                s.blocksNeededForQueue.mul(2)\n            );\n        } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n            // 4\n            s.LiquidityDepositorQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n            // 5\n            s.LiquidityTokenQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n            // 6\n            s.LiquidityManagerQueue[_address] = block.number.add(\n                s.blocksNeededForQueue.mul(2)\n            );\n        } else if (_managing == MANAGING.DEBTOR) {\n            // 7\n            s.debtorQueue[_address] = block.number.add(s.blocksNeededForQueue);\n        } else if (_managing == MANAGING.REWARDMANAGER) {\n            // 8\n            s.rewardManagerQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.NNECC) {\n            // 9\n            s.nNeccQueue = block.number.add(s.blocksNeededForQueue);\n        } else return false;\n\n        emit ChangeQueued(_managing, _address);\n        return true;\n    }\n\n    /**\n        @notice verify queue then set boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n    function toggle(MANAGING _managing, address _address)\n        external\n        returns (bool)\n    {\n        onlyGov();\n        require(_address != address(0));\n        bool _result;\n        if (_managing == MANAGING.RESERVEDEPOSITOR) {\n            // 0\n            if (\n                requirements(\n                    s.reserveDepositorQueue,\n                    s.isReserveDepositor,\n                    _address\n                )\n            ) {\n                s.reserveDepositorQueue[_address] = 0;\n                if (!listContains(s.reserveDepositors, _address)) {\n                    s.reserveDepositors.push(_address);\n                }\n            }\n            _result = !s.isReserveDepositor[_address];\n            s.isReserveDepositor[_address] = _result;\n        } else if (_managing == MANAGING.RESERVESPENDER) {\n            // 1\n            if (\n                requirements(\n                    s.reserveSpenderQueue,\n                    s.isReserveSpender,\n                    _address\n                )\n            ) {\n                s.reserveSpenderQueue[_address] = 0;\n                if (!listContains(s.reserveSpenders, _address)) {\n                    s.reserveSpenders.push(_address);\n                }\n            }\n            _result = !s.isReserveSpender[_address];\n            s.isReserveSpender[_address] = _result;\n        } else if (_managing == MANAGING.RESERVETOKEN) {\n            // 2\n            if (requirements(s.reserveTokenQueue, s.isReserveToken, _address)) {\n                s.reserveTokenQueue[_address] = 0;\n                if (!listContains(s.reserveTokens, _address)) {\n                    s.reserveTokens.push(_address);\n                }\n            }\n            _result = !s.isReserveToken[_address];\n            s.isReserveToken[_address] = _result;\n        } else if (_managing == MANAGING.RESERVEMANAGER) {\n            // 3\n            if (\n                requirements(\n                    s.ReserveManagerQueue,\n                    s.isReserveManager,\n                    _address\n                )\n            ) {\n                s.reserveManagers.push(_address);\n                s.ReserveManagerQueue[_address] = 0;\n                if (!listContains(s.reserveManagers, _address)) {\n                    s.reserveManagers.push(_address);\n                }\n            }\n            _result = !s.isReserveManager[_address];\n            s.isReserveManager[_address] = _result;\n        } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n            // 4\n            if (\n                requirements(\n                    s.LiquidityDepositorQueue,\n                    s.isLiquidityDepositor,\n                    _address\n                )\n            ) {\n                s.liquidityDepositors.push(_address);\n                s.LiquidityDepositorQueue[_address] = 0;\n                if (!listContains(s.liquidityDepositors, _address)) {\n                    s.liquidityDepositors.push(_address);\n                }\n            }\n            _result = !s.isLiquidityDepositor[_address];\n            s.isLiquidityDepositor[_address] = _result;\n        } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n            // 5\n            if (\n                requirements(\n                    s.LiquidityTokenQueue,\n                    s.isLiquidityToken,\n                    _address\n                )\n            ) {\n                s.LiquidityTokenQueue[_address] = 0;\n                if (!listContains(s.liquidityTokens, _address)) {\n                    s.liquidityTokens.push(_address);\n                }\n            }\n            _result = !s.isLiquidityToken[_address];\n            s.isLiquidityToken[_address] = _result;\n        } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n            // 6\n            if (\n                requirements(\n                    s.LiquidityManagerQueue,\n                    s.isLiquidityManager,\n                    _address\n                )\n            ) {\n                s.LiquidityManagerQueue[_address] = 0;\n                if (!listContains(s.liquidityManagers, _address)) {\n                    s.liquidityManagers.push(_address);\n                }\n            }\n            _result = !s.isLiquidityManager[_address];\n            s.isLiquidityManager[_address] = _result;\n        } else if (_managing == MANAGING.DEBTOR) {\n            // 7\n            if (requirements(s.debtorQueue, s.isDebtor, _address)) {\n                s.debtorQueue[_address] = 0;\n                if (!listContains(s.debtors, _address)) {\n                    s.debtors.push(_address);\n                }\n            }\n            _result = !s.isDebtor[_address];\n            s.isDebtor[_address] = _result;\n        } else if (_managing == MANAGING.REWARDMANAGER) {\n            // 8\n            if (\n                requirements(s.rewardManagerQueue, s.isRewardManager, _address)\n            ) {\n                s.rewardManagerQueue[_address] = 0;\n                if (!listContains(s.rewardManagers, _address)) {\n                    s.rewardManagers.push(_address);\n                }\n            }\n            _result = !s.isRewardManager[_address];\n            s.isRewardManager[_address] = _result;\n        } else if (_managing == MANAGING.NNECC) {\n            // 9\n            s.nNeccQueue = 0;\n            s.nNecc = _address;\n            _result = true;\n        } else return false;\n\n        emit ChangeActivated(_managing, _address, _result);\n        return true;\n    }\n\n    /**\n        @notice checks requirements and returns altered structs\n        @param queue_ mapping( address => uint )\n        @param status_ mapping( address => bool )\n        @param _address address\n        @return bool \n     */\n    function requirements(\n        mapping(address => uint256) storage queue_,\n        mapping(address => bool) storage status_,\n        address _address\n    ) internal view returns (bool) {\n        if (!status_[_address]) {\n            require(queue_[_address] != 0, \"Must queue\");\n            require(queue_[_address] <= block.number, \"Queue not expired\");\n            return true;\n        }\n        return false;\n    }\n\n    /**\n        @notice checks array to ensure against duplicate\n        @param _list address[]\n        @param _token address\n        @return bool\n     */\n    function listContains(address[] storage _list, address _token)\n        internal\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _list.length; i++) {\n            if (_list[i] == _token) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/facets/Treasury/Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../../lib/LibTreasuryStorage.sol\";\nimport \"../../lib/LibDiamond.sol\";\n\ncontract Facet {\n    LibTreasuryStorage.Storage internal s;\n\n    function onlyGov() internal view {\n        LibDiamond.enforceIsContractOwner();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/lib/LibTreasuryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// import \"hardhat/console.sol\";\n\nlibrary LibTreasuryStorage {\n    bytes32 constant STORAGE_POSITION = keccak256(\"necc.dao.treasury.storage\");\n\n    // Single global store\n    struct Storage {\n        // TODO: Refactor arrays to EnumerableSet\n        // Treasury\n        address Necc;\n        uint256 blocksNeededForQueue;\n        address[] reserveTokens; // Push only, beware false-positives.\n        address nNecc;\n        uint256 nNeccQueue; // Delays change to nNecc address\n        uint256 totalReserves; // Risk-free value of all assets\n        uint256 totalDebt;\n        mapping(address => bool) isReserveToken;\n        mapping(address => uint256) reserveTokenQueue; // Delays changes to mapping.\n        address[] reserveDepositors; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isReserveDepositor;\n        mapping(address => uint256) reserveDepositorQueue; // Delays changes to mapping.\n        address[] reserveSpenders; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isReserveSpender;\n        mapping(address => uint256) reserveSpenderQueue; // Delays changes to mapping.\n        address[] liquidityTokens; // Push only, beware false-positives.\n        mapping(address => bool) isLiquidityToken;\n        mapping(address => uint256) LiquidityTokenQueue; // Delays changes to mapping.\n        address[] liquidityDepositors; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isLiquidityDepositor;\n        mapping(address => uint256) LiquidityDepositorQueue; // Delays changes to mapping.\n        address[] reserveManagers; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isReserveManager;\n        mapping(address => uint256) ReserveManagerQueue; // Delays changes to mapping.\n        address[] liquidityManagers; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isLiquidityManager;\n        mapping(address => uint256) LiquidityManagerQueue; // Delays changes to mapping.\n        address[] debtors; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isDebtor;\n        mapping(address => uint256) debtorQueue; // Delays changes to mapping.\n        mapping(address => uint256) debtorBalance;\n        address[] rewardManagers; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isRewardManager;\n        mapping(address => uint256) rewardManagerQueue; // Delays changes to mapping.\n        // Always add new storage variable to the end of this struct\n    }\n}\n"
    },
    "contracts/lib/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nlibrary LibDiamond {\n    bytes32 public constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(\n            msg.sender == diamondStorage().contractOwner,\n            \"LibDiamond: invalid contract owner\"\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}