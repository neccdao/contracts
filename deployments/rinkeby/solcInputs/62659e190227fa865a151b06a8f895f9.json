{
  "language": "Solidity",
  "sources": {
    "contracts/amm/PancakePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"./interfaces/IPancakePair.sol\";\n\ncontract PancakePair is IPancakePair {\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    function setReserves(uint256 balance0, uint256 balance1) external {\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = uint32(block.timestamp);\n    }\n\n    function getReserves()\n        public\n        view\n        override\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n}\n"
    },
    "contracts/amm/interfaces/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IPancakePair {\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n}\n"
    },
    "contracts/amm/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IUniswapV2ERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/tokens/Necc/StandardBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./libraries/FixedPoint.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./interfaces/IERC20Metadata.sol\";\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"../../amm/interfaces/IUniswapV2Pair.sol\";\nimport \"../../amm/interfaces/IUniswapV2ERC20.sol\";\n\ncontract StandardBondingCalculator is IBondingCalculator {\n    using FixedPoint for *;\n    using SafeMath for uint256;\n    using SafeMath for uint112;\n\n    IERC20 immutable Necc;\n\n    constructor(address _Necc) {\n        require(_Necc != address(0));\n        Necc = IERC20(_Necc);\n    }\n\n    // NOTE - ported from ./libraries/SafeMath.sol to OZ\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 b = a.div(2).add(1);\n            while (b < c) {\n                c = b;\n                b = a.div(b).add(b).div(2);\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n\n    function getKValue(address _pair) public view returns (uint256 k_) {\n        uint256 token0 = IERC20Metadata(IUniswapV2Pair(_pair).token0())\n            .decimals();\n        uint256 token1 = IERC20Metadata(IUniswapV2Pair(_pair).token1())\n            .decimals();\n        uint256 decimals = token0.add(token1).sub(\n            IERC20Metadata(_pair).decimals()\n        );\n\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_pair)\n            .getReserves();\n        k_ = reserve0.mul(reserve1).div(10**decimals);\n    }\n\n    function getTotalValue(address _pair) public view returns (uint256 _value) {\n        _value = sqrrt(getKValue(_pair)).mul(2);\n    }\n\n    function valuation(address _pair, uint256 amount_)\n        external\n        view\n        override\n        returns (uint256 _value)\n    {\n        uint256 totalValue = getTotalValue(_pair);\n        uint256 totalSupply = IUniswapV2Pair(_pair).totalSupply();\n\n        _value = totalValue\n            .mul(FixedPoint.fraction(amount_, totalSupply).decode112with18())\n            .div(1e18);\n    }\n\n    function markdown(address _pair) external view override returns (uint256) {\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_pair)\n            .getReserves();\n\n        uint256 reserve;\n        if (IUniswapV2Pair(_pair).token0() == address(Necc)) {\n            reserve = reserve1;\n        } else {\n            reserve = reserve0;\n        }\n        return\n            reserve.mul(2 * (10**IERC20Metadata(address(Necc)).decimals())).div(\n                getTotalValue(_pair)\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/tokens/Necc/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"./FullMath.sol\";\n\nlibrary Babylonian {\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n\nlibrary BitMath {\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, \"BitMath::mostSignificantBit: zero\");\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n}\n\nlibrary FixedPoint {\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\n    uint256 private constant Q224 =\n        0x100000000000000000000000000000000000000000000000000000000;\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    function decode112with18(uq112x112 memory self)\n        internal\n        pure\n        returns (uint256)\n    {\n        return uint256(self._x) / 5192296858534827;\n    }\n\n    function fraction(uint256 numerator, uint256 denominator)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        if (self._x <= uint144(-1)) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return\n            uq112x112(\n                uint224(\n                    Babylonian.sqrt(uint256(self._x) << safeShiftBits) <<\n                        ((112 - safeShiftBits) / 2)\n                )\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/tokens/Necc/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/tokens/Necc/interfaces/IBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IBondingCalculator {\n    function markdown(address _LP) external view returns (uint256);\n\n    function valuation(address pair_, uint256 amount_)\n        external\n        view\n        returns (uint256 _value);\n}\n"
    },
    "contracts/amm/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\ninterface IUniswapV2Pair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/tokens/Necc/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y)\n        private\n        pure\n        returns (uint256 l, uint256 h)\n    {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n        require(h < d, \"FullMath::mulDiv: overflow\");\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "contracts/facets/Treasury/BondingCalculatorFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./Facet.sol\";\nimport \"../../lib/FixedPoint.sol\";\nimport \"../../amm/interfaces/IUniswapV2Pair.sol\";\nimport \"../../amm/interfaces/IUniswapV2ERC20.sol\";\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\ncontract BondingCalculatorFacet is Facet {\n    using FixedPoint for *;\n    using SafeMath for uint256;\n    using SafeMath for uint112;\n\n    // NOTE - ported from ./libraries/SafeMath.sol to OZ\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 b = a.div(2).add(1);\n            while (b < c) {\n                c = b;\n                b = a.div(b).add(b).div(2);\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n\n    function getKValue(address _pair) public view returns (uint256 k_) {\n        uint256 token0 = IERC20Metadata(IUniswapV2Pair(_pair).token0())\n            .decimals();\n        uint256 token1 = IERC20Metadata(IUniswapV2Pair(_pair).token1())\n            .decimals();\n        uint256 decimals = token0.add(token1).sub(\n            IERC20Metadata(_pair).decimals()\n        );\n\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_pair)\n            .getReserves();\n        k_ = reserve0.mul(reserve1).div(10**decimals);\n    }\n\n    function getTotalValue(address _pair) public view returns (uint256 _value) {\n        _value = sqrrt(getKValue(_pair)).mul(2);\n    }\n\n    function valuation(address _pair, uint256 amount_)\n        external\n        view\n        returns (uint256 _value)\n    {\n        uint256 totalValue = getTotalValue(_pair);\n        uint256 totalSupply = IUniswapV2Pair(_pair).totalSupply();\n\n        _value = totalValue\n            .mul(FixedPoint.fraction(amount_, totalSupply).decode112with18())\n            .div(1e18);\n    }\n\n    function markdown(address _pair) external view returns (uint256) {\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_pair)\n            .getReserves();\n\n        uint256 reserve;\n        if (IUniswapV2Pair(_pair).token0() == address(s.Necc)) {\n            reserve = reserve1;\n        } else {\n            reserve = reserve0;\n        }\n        return\n            reserve\n                .mul(2 * (10**IERC20Metadata(address(s.Necc)).decimals()))\n                .div(getTotalValue(_pair));\n    }\n}\n"
    },
    "contracts/facets/Treasury/Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"./LibTreasuryStorage.sol\";\nimport \"../../lib/LibDiamond.sol\";\n\ncontract Facet {\n    LibTreasuryStorage.Storage internal s;\n\n    function onlyGov() internal view {\n        LibDiamond.enforceIsContractOwner();\n    }\n}\n"
    },
    "contracts/lib/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"./FullMath.sol\";\n\nlibrary Babylonian {\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n\nlibrary BitMath {\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, \"BitMath::mostSignificantBit: zero\");\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n}\n\nlibrary FixedPoint {\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\n    uint256 private constant Q224 =\n        0x100000000000000000000000000000000000000000000000000000000;\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    function decode112with18(uq112x112 memory self)\n        internal\n        pure\n        returns (uint256)\n    {\n        return uint256(self._x) / 5192296858534827;\n    }\n\n    function fraction(uint256 numerator, uint256 denominator)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        if (self._x <= uint144(-1)) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return\n            uq112x112(\n                uint224(\n                    Babylonian.sqrt(uint256(self._x) << safeShiftBits) <<\n                        ((112 - safeShiftBits) / 2)\n                )\n            );\n    }\n}\n"
    },
    "contracts/facets/Treasury/LibTreasuryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\n// import \"hardhat/console.sol\";\n\nlibrary LibTreasuryStorage {\n    bytes32 constant STORAGE_POSITION = keccak256(\"necc.dao.treasury.storage\");\n\n    // Single global store\n    struct Storage {\n        // TODO: Refactor arrays to EnumerableSet\n        // Treasury\n        address Necc;\n        uint256 blocksNeededForQueue;\n        address[] reserveTokens; // Push only, beware false-positives.\n        address nNecc;\n        uint256 nNeccQueue; // Delays change to nNecc address\n        uint256 totalReserves; // Risk-free value of all assets\n        uint256 totalDebt;\n        mapping(address => bool) isReserveToken;\n        mapping(address => uint256) reserveTokenQueue; // Delays changes to mapping.\n        address[] reserveDepositors; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isReserveDepositor;\n        mapping(address => uint256) reserveDepositorQueue; // Delays changes to mapping.\n        address[] reserveSpenders; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isReserveSpender;\n        mapping(address => uint256) reserveSpenderQueue; // Delays changes to mapping.\n        address[] liquidityTokens; // Push only, beware false-positives.\n        mapping(address => bool) isLiquidityToken;\n        mapping(address => uint256) LiquidityTokenQueue; // Delays changes to mapping.\n        address[] liquidityDepositors; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isLiquidityDepositor;\n        mapping(address => uint256) LiquidityDepositorQueue; // Delays changes to mapping.\n        address[] reserveManagers; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isReserveManager;\n        mapping(address => uint256) ReserveManagerQueue; // Delays changes to mapping.\n        address[] liquidityManagers; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isLiquidityManager;\n        mapping(address => uint256) LiquidityManagerQueue; // Delays changes to mapping.\n        address[] debtors; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isDebtor;\n        mapping(address => uint256) debtorQueue; // Delays changes to mapping.\n        mapping(address => uint256) debtorBalance;\n        address[] rewardManagers; // Push only, beware false-positives. Only for viewing.\n        mapping(address => bool) isRewardManager;\n        mapping(address => uint256) rewardManagerQueue; // Delays changes to mapping.\n        // Always add new storage variable to the end of this struct\n    }\n}\n"
    },
    "contracts/lib/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nlibrary LibDiamond {\n    bytes32 public constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(\n            msg.sender == diamondStorage().contractOwner,\n            \"LibDiamond: invalid contract owner\"\n        );\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) public {\n        enforceIsContractOwner();\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n\n        emit OwnershipTransferred(previousOwner, ds.contractOwner);\n    }\n\n    function contractOwner() public view returns (address) {\n        DiamondStorage storage ds = diamondStorage();\n        return ds.contractOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/lib/FullMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y)\n        private\n        pure\n        returns (uint256 l, uint256 h)\n    {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n        require(h < d, \"FullMath::mulDiv: overflow\");\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "contracts/facets/Bond/BondDepositoryFacet.sol": {
      "content": "pragma abicoder v2;\n// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/drafts/ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../lib/FixedPoint.sol\";\nimport \"../../lib/FullMath.sol\";\nimport \"./LibBondStorage.sol\";\nimport \"./BondDepositoryLib.sol\";\nimport \"./Facet.sol\";\n\ninterface IBCVPC {\n    function storePayout(address _principle, uint256 _amount) external;\n}\n\ninterface ITreasury {\n    function mintRewards(address _recipient, uint256 _amount) external;\n\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256 send_);\n\n    function valueOfToken(address _token, uint256 _amount)\n        external\n        view\n        returns (uint256 value_);\n}\n\ninterface IBondCalculator {\n    function valuation(address _LP, uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function markdown(address _LP) external view returns (uint256);\n}\n\ninterface IStaking {\n    function stake(uint256 _amount, address _recipient) external returns (bool);\n}\n\ninterface IERC20Decimals {\n    function decimals() external view returns (uint8);\n}\n\ncontract BondDepositoryFacet is Facet {\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using BondDepositoryLib for LibBondStorage.Storage;\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated(\n        uint256 deposit,\n        uint256 indexed payout,\n        uint256 indexed expires,\n        uint256 indexed priceInUSD\n    );\n    event BondRedeemed(\n        address indexed recipient,\n        uint256 payout,\n        uint256 remaining\n    );\n    event BondPriceChanged(\n        uint256 indexed priceInUSD,\n        uint256 indexed internalPrice,\n        uint256 indexed debtRatio\n    );\n    event ControlVariableAdjustment(\n        uint256 initialBCV,\n        uint256 newBCV,\n        uint256 adjustment,\n        bool addition\n    );\n\n    /* ======== INITIALIZATION ======== */\n\n    function initializeBondDepository(\n        address _nusd,\n        address _Necc,\n        address _treasury,\n        address _DAO\n    ) external {\n        onlyGov();\n        require(_Necc != address(0));\n        s.Necc = _Necc;\n        require(_treasury != address(0));\n        s.treasury = _treasury;\n        require(_DAO != address(0));\n        s.DAO = _DAO;\n        require(_nusd != address(0));\n        s.nusd = _nusd;\n    }\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint256\n     *  @param _minimumPrice uint\n     *  @param _maxPayout uint\n     *  @param _fee uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBondTerms(\n        uint256 _controlVariable,\n        uint256 _minimumPrice,\n        uint256 _maxPayout,\n        uint256 _fee,\n        uint256 _maxDebt,\n        uint256 _initialDebt,\n        uint256 _vestingTerm,\n        uint256 _weight,\n        bool _isLiquidityBond,\n        address _principle\n    ) external {\n        onlyGov();\n        EnumerableSet.add(s.principles, _principle);\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        require(\n            s.terms[_principleIndex].controlVariable == 0,\n            \"Bonds must be initialized from 0\"\n        );\n        s.terms[_principleIndex] = LibBondStorage.Terms({\n            controlVariable: _controlVariable,\n            minimumPrice: _minimumPrice,\n            maxPayout: _maxPayout,\n            fee: _fee,\n            maxDebt: _maxDebt,\n            vestingTerm: _vestingTerm,\n            isLiquidityBond: _isLiquidityBond\n        });\n        s.totalDebt[_principleIndex] = _initialDebt;\n        s.lastDecay[_principleIndex] = uint256(block.timestamp);\n        if (_weight > 0) {\n            s.totalWeight = s.totalWeight.add(_weight).sub(\n                s.weights[_principleIndex]\n            );\n            s.weights[_principleIndex] = _weight;\n        }\n    }\n\n    /* ======== POLICY FUNCTIONS ======== */\n\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _parameter PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms(\n        PARAMETER _parameter,\n        uint256 _input,\n        address _principle\n    ) external {\n        onlyGov();\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        if (_parameter == PARAMETER.VESTING) {\n            // 0\n            require(_input >= 129600, \"Vesting must be longer than 36 hours\");\n            s.terms[_principleIndex].vestingTerm = uint256(_input);\n        } else if (_parameter == PARAMETER.PAYOUT) {\n            // 1\n            require(_input <= 1000, \"Payout cannot be above 1 percent\");\n            s.terms[_principleIndex].maxPayout = _input;\n        } else if (_parameter == PARAMETER.FEE) {\n            // 2\n            require(_input <= 10000, \"DAO fee cannot exceed payout\");\n            s.terms[_principleIndex].fee = _input;\n        } else if (_parameter == PARAMETER.DEBT) {\n            // 3\n            s.terms[_principleIndex].maxDebt = _input;\n        } else if (_parameter == PARAMETER.MINPRICE) {\n            // 4\n            s.terms[_principleIndex].minimumPrice = _input;\n        }\n    }\n\n    function setAdjustment(\n        bool _addition,\n        uint256 _delta,\n        uint256 _seconds,\n        address _principle\n    ) external {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        require(\n            (msg.sender == address(this)) || (msg.sender == ds.contractOwner),\n            \"BondDepository: Invalid contract owner\"\n        );\n        uint256 _principleIndex = s.getIndexAt(_principle);\n\n        require(_seconds <= 500000, \"Adjustment: Change too fast\");\n\n        s.bondDepositoryAdjustment[_principleIndex] = LibBondStorage\n            .BondDepositoryAdjustment({\n                add: _addition,\n                delta: _delta,\n                timeToTarget: _seconds,\n                lastTime: uint256(block.timestamp)\n            });\n    }\n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit(\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _depositor,\n        address _principle\n    ) external returns (uint256) {\n        require(_depositor != address(0), \"Invalid address\");\n        uint256 _principleIndex = s.getIndexAt(_principle);\n\n        decayDebt(_principle);\n        require(\n            s.totalDebt[_principleIndex] <= s.terms[_principleIndex].maxDebt,\n            \"Max capacity reached\"\n        );\n\n        uint256 priceInUSD = bondPriceInUSD(_principle); // Stored in bond info\n        uint256 nativePrice = _bondPrice(_principle);\n\n        require(\n            _maxPrice >= nativePrice,\n            \"Slippage limit: more than max price\"\n        ); // slippage protection\n\n        uint256 value = ITreasury(s.treasury).valueOfToken(_principle, _amount);\n        uint256 payout = payoutFor(value, _principle); // payout to bonder is computed\n\n        require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 Necc ( underflow protection )\n        require(payout <= maxPayout(_principle), \"Bond too large\"); // size protection because there is no slippage\n\n        // profits are calculated\n        uint256 fee = payout.mul(s.terms[_principleIndex].fee).div(10000);\n        uint256 profit = value.sub(payout).sub(fee);\n\n        /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) Necc\n         */\n        IERC20(_principle).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(_principle).approve(address(s.treasury), _amount);\n        ITreasury(s.treasury).deposit(_amount, _principle, profit);\n\n        if (fee != 0) {\n            // fee is transferred to dao\n            IERC20(s.Necc).safeTransfer(s.DAO, fee);\n        }\n\n        // total debt is increased\n        s.totalDebt[_principleIndex] = s.totalDebt[_principleIndex].add(value);\n\n        // depositor info is stored\n        s.bondInfo[_depositor][_principleIndex] = LibBondStorage.Bond({\n            payout: s.bondInfo[_depositor][_principleIndex].payout.add(payout),\n            vesting: s.terms[_principleIndex].vestingTerm,\n            lastTime: uint256(block.timestamp),\n            pricePaid: priceInUSD\n        });\n\n        // indexed events are emitted\n        emit BondCreated(\n            _amount,\n            payout,\n            block.timestamp.add(s.terms[_principleIndex].vestingTerm),\n            priceInUSD\n        );\n        emit BondPriceChanged(\n            bondPriceInUSD(_principle),\n            _bondPrice(_principle),\n            debtRatio(_principle)\n        );\n\n        adjust(_principle); // control variable is adjusted\n        return payout;\n    }\n\n    /**\n     *  @notice redeem bond for user\n     *  @param _recipient address\n     *  @param _stake bool\n     *  @return uint\n     */\n    function redeem(\n        address _recipient,\n        address _principle,\n        bool _stake\n    ) external returns (uint256) {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        LibBondStorage.Bond memory info = s.bondInfo[_recipient][\n            _principleIndex\n        ];\n        // (seconds since last interaction / vesting term remaining)\n        uint256 percentVested = percentVestedFor(_recipient, _principle);\n\n        if (percentVested >= 10000) {\n            // if fully vested\n            delete s.bondInfo[_recipient][_principleIndex]; // delete user info\n            emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n            return stakeOrSend(_recipient, _stake, info.payout, _principle); // pay user everything due\n        } else {\n            // if unfinished\n            // calculate payout vested\n            uint256 payout = info.payout.mul(percentVested).div(10000);\n            // store updated deposit info\n            s.bondInfo[_recipient][_principleIndex] = LibBondStorage.Bond({\n                payout: info.payout.sub(payout),\n                vesting: info.vesting.sub(\n                    uint256(block.timestamp).sub(info.lastTime)\n                ),\n                lastTime: uint256(block.timestamp),\n                pricePaid: info.pricePaid\n            });\n\n            emit BondRedeemed(\n                _recipient,\n                payout,\n                s.bondInfo[_recipient][_principleIndex].payout\n            );\n            return stakeOrSend(_recipient, _stake, payout, _principle);\n        }\n    }\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout(address _principle) public view returns (uint256) {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        return\n            IERC20(s.Necc)\n                .totalSupply()\n                .mul(s.terms[_principleIndex].maxPayout)\n                .div(100000);\n    }\n\n    /**\n     *  @notice calculate interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor(uint256 _value, address _principle)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            FixedPoint\n                .fraction(_value, bondPrice(_principle))\n                .decode112with18()\n                .div(1e16);\n    }\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price_ uint\n     */\n    function bondPrice(address _principle)\n        public\n        view\n        returns (uint256 price_)\n    {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        price_ = s\n            .terms[_principleIndex]\n            .controlVariable\n            .mul(debtRatio(_principle))\n            .add(1000000000)\n            .div(1e7);\n\n        if (price_ < s.terms[_principleIndex].minimumPrice) {\n            price_ = s.terms[_principleIndex].minimumPrice;\n        }\n    }\n\n    /**\n     *  @notice calculate current bond price and remove floor if above\n     *  @return price_ uint\n     */\n    function _bondPrice(address _principle) internal returns (uint256 price_) {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        price_ = s\n            .terms[_principleIndex]\n            .controlVariable\n            .mul(debtRatio(_principle))\n            .add(1000000000)\n            .div(1e7);\n\n        if (price_ < s.terms[_principleIndex].minimumPrice) {\n            price_ = s.terms[_principleIndex].minimumPrice;\n        } else if (s.terms[_principleIndex].minimumPrice != 0) {\n            s.terms[_principleIndex].minimumPrice = 0;\n        }\n    }\n\n    /**\n     *  @notice converts bond price to DAI value\n     *  @return price_ uint\n     */\n    function bondPriceInUSD(address _principle)\n        public\n        view\n        returns (uint256 price_)\n    {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n\n        if (s.terms[_principleIndex].isLiquidityBond) {\n            price_ = bondPrice(_principle)\n                .mul(IBondCalculator(address(this)).markdown(_principle))\n                .div(100);\n        } else {\n            price_ = bondPrice(_principle)\n                .mul(10**IERC20Decimals(_principle).decimals())\n                .div(100);\n        }\n    }\n\n    /**\n     *  @notice calculate current ratio of debt to Necc supply\n     *  @return debtRatio_ uint\n     */\n    function debtRatio(address _principle)\n        public\n        view\n        returns (uint256 debtRatio_)\n    {\n        uint256 supply = IERC20(s.Necc).totalSupply();\n        debtRatio_ = FixedPoint\n            .fraction(currentDebt(_principle).mul(1e9), supply)\n            .decode112with18()\n            .div(1e18);\n    }\n\n    /**\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\n     *  @return uint\n     */\n    function standardizedDebtRatio(address _principle)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        if (s.terms[_principleIndex].isLiquidityBond) {\n            return\n                debtRatio(_principle)\n                    .mul(IBondCalculator(address(this)).markdown(_principle))\n                    .div(1e9);\n        } else {\n            return debtRatio(_principle);\n        }\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt(address _principle) public view returns (uint256) {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        return s.totalDebt[_principleIndex].sub(debtDecay(_principle));\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay_ uint\n     */\n    function debtDecay(address _principle)\n        public\n        view\n        returns (uint256 decay_)\n    {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        uint256 timeSinceLast = uint256(block.timestamp).sub(\n            s.lastDecay[_principleIndex]\n        );\n        decay_ = s.totalDebt[_principleIndex].mul(timeSinceLast).div(\n            s.terms[_principleIndex].vestingTerm\n        );\n        if (decay_ > s.totalDebt[_principleIndex]) {\n            decay_ = s.totalDebt[_principleIndex];\n        }\n    }\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested_ uint\n     */\n    function percentVestedFor(address _depositor, address _principle)\n        public\n        view\n        returns (uint256 percentVested_)\n    {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        LibBondStorage.Bond memory bond = s.bondInfo[_depositor][\n            _principleIndex\n        ];\n        uint256 secondsSinceLast = uint256(block.timestamp).sub(bond.lastTime);\n        uint256 vesting = bond.vesting;\n\n        if (vesting > 0) {\n            percentVested_ = secondsSinceLast.mul(100000).div(vesting);\n        } else {\n            percentVested_ = 0;\n        }\n    }\n\n    /**\n     *  @notice calculate amount of Necc available for claim by depositor\n     *  @param _depositor address\n     *  @return pendingPayout_ uint\n     */\n    function pendingPayoutFor(address _depositor, address _principle)\n        external\n        view\n        returns (uint256 pendingPayout_)\n    {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        uint256 percentVested = percentVestedFor(_depositor, _principle);\n        uint256 payout = s.bondInfo[_depositor][_principleIndex].payout;\n\n        if (percentVested >= 10000) {\n            pendingPayout_ = payout;\n        } else {\n            pendingPayout_ = payout.mul(percentVested).div(10000);\n        }\n    }\n\n    /* ======= AUXILLIARY ======= */\n\n    /**\n     *  @notice allow anyone to send lost tokens (excluding principle or Necc) to the DAO\n     *  @return bool\n     */\n    function recoverLostToken(address _token) external returns (bool) {\n        require(_token != s.Necc);\n        require(!EnumerableSet.contains(s.principles, _token));\n        IERC20(_token).safeTransfer(\n            s.DAO,\n            IERC20(_token).balanceOf(address(this))\n        );\n\n        return true;\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt(address _principle) internal {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        s.totalDebt[_principleIndex] = s.totalDebt[_principleIndex].sub(\n            debtDecay(_principle)\n        );\n        s.lastDecay[_principleIndex] = uint256(block.timestamp);\n    }\n\n    function terms(address _principle)\n        public\n        view\n        returns (LibBondStorage.Terms memory)\n    {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        return s.terms[_principleIndex];\n    }\n\n    /**\n     *  @notice allow user to stake payout automatically\n     *  @param _stake bool\n     *  @param _amount uint\n     *  @return uint\n     */\n    function stakeOrSend(\n        address _recipient,\n        bool _stake,\n        uint256 _amount,\n        address _principle\n    ) internal returns (uint256) {\n        if (!_stake) {\n            // if user does not want to stake\n            IERC20(s.Necc).transfer(_recipient, _amount); // send payout\n        } else {\n            // if user wants to stake\n\n            IERC20(s.Necc).approve(address(this), _amount);\n            IStaking(address(this)).stake(_amount, _recipient);\n        }\n\n        // Store payout of Necc to calculate new BCV\n        if (_recipient == s.treasury || _recipient == s.DAO) {\n            return _amount;\n        } else {\n            IBCVPC(address(this)).storePayout(_principle, _amount);\n            return _amount;\n        }\n    }\n\n    /**\n     *  @notice makes incremental adjustment to control variable\n     */\n    function adjust(address _principle) internal {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        LibBondStorage.BondDepositoryAdjustment memory adjustment = s\n            .bondDepositoryAdjustment[_principleIndex];\n        LibBondStorage.Terms memory _bondTerms = s.terms[_principleIndex];\n\n        if (adjustment.delta != 0) {\n            uint256 initial = _bondTerms.controlVariable;\n            uint256 timeSinceLast = block.timestamp.sub(adjustment.lastTime);\n            uint256 change = changeBy(_principle);\n\n            adjustment.delta = adjustment.delta.sub(change);\n            adjustment.timeToTarget = adjustment.timeToTarget.sub(\n                timeSinceLast\n            );\n\n            if (adjustment.add) {\n                _bondTerms.controlVariable = _bondTerms.controlVariable.add(\n                    change\n                );\n            } else {\n                _bondTerms.controlVariable = _bondTerms.controlVariable.sub(\n                    change\n                );\n            }\n\n            adjustment.lastTime = block.timestamp;\n\n            emit ControlVariableAdjustment(\n                initial,\n                _bondTerms.controlVariable,\n                change,\n                adjustment.add\n            );\n        }\n    }\n\n    function changeBy(address _principle)\n        internal\n        view\n        returns (uint256 changeBy_)\n    {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        LibBondStorage.BondDepositoryAdjustment memory adjustment = s\n            .bondDepositoryAdjustment[_principleIndex];\n\n        uint256 timeSinceLast = block.timestamp.sub(adjustment.lastTime);\n\n        changeBy_ = adjustment.delta.mul(timeSinceLast).div(\n            adjustment.timeToTarget\n        );\n\n        if (changeBy_ > adjustment.delta) {\n            changeBy_ = adjustment.delta;\n        }\n    }\n\n    function bondInfo(address _depositor, address _principle)\n        public\n        view\n        returns (LibBondStorage.Bond memory)\n    {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        return s.bondInfo[_depositor][_principleIndex];\n    }\n\n    function BCV(address _principle) public view returns (uint256 BCV_) {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        LibBondStorage.BondDepositoryAdjustment memory _bondAdjustment = s\n            .bondDepositoryAdjustment[_principleIndex];\n\n        uint256 change = changeBy(_principle);\n\n        if (_bondAdjustment.add) {\n            BCV_ = s.terms[_principleIndex].controlVariable.add(change);\n        } else {\n            BCV_ = s.terms[_principleIndex].controlVariable.sub(change);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/drafts/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.5 <0.8.0;\n\nimport \"../token/ERC20/ERC20.sol\";\nimport \"./IERC20Permit.sol\";\nimport \"../cryptography/ECDSA.sol\";\nimport \"../utils/Counters.sol\";\nimport \"./EIP712.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping (address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) internal EIP712(name, \"1\") {\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _PERMIT_TYPEHASH,\n                owner,\n                spender,\n                value,\n                _nonces[owner].current(),\n                deadline\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _nonces[owner].increment();\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "contracts/facets/Bond/LibBondStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\nenum PARAMETER {\n    VESTING,\n    PAYOUT,\n    FEE,\n    DEBT,\n    MINPRICE\n}\n\nenum CONTRACTS {\n    DISTRIBUTOR,\n    WARMUP,\n    LOCKER\n}\n\nuint256 constant BCV_ADJUSTMENT_EPOCH_PERIOD = 1; // how many epochs to spread an adjustment across\n\nlibrary LibBondStorage {\n    bytes32 constant STORAGE_POSITION = keccak256(\"necc.dao.bond.storage\");\n\n    struct Payout {\n        uint256 amount; // Necc paid\n        uint256 blockTimestamp; // block number occurred\n    }\n\n    struct Info {\n        uint256 rate; // in ten-thousandths ( 5000 = 0.5% )\n        address recipient;\n    }\n\n    struct DistributorAdjustment {\n        bool add;\n        uint256 rate;\n        uint256 target;\n    }\n\n    struct Terms {\n        uint256 controlVariable; // scaling variable for price\n        uint256 minimumPrice; // vs principle value\n        uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint256 fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\n        uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n        uint256 vestingTerm; // in seconds\n        bool isLiquidityBond; // Reserve and LP tokens are treated differently, LP uses bond calculator\n    }\n\n    // Info for bond holder\n    struct Bond {\n        uint256 payout; // Necc remaining to be paid\n        uint256 pricePaid; // In DAI, for front end viewing\n        uint256 lastTime; // Last interaction\n        uint256 vesting; // Seconds left to vest\n    }\n\n    // Info for incremental adjustments to control variable\n    struct BondDepositoryAdjustment {\n        bool add; // addition or subtraction\n        uint256 delta; // increment\n        uint256 timeToTarget; // seconds till target\n        uint256 lastTime; // time when last adjustment made\n    }\n    struct Epoch {\n        uint256 number;\n        uint256 distribute;\n        uint256 length;\n        uint256 endTime;\n    }\n\n    struct Claim {\n        uint256 deposit;\n        uint256 gons;\n        uint256 expiry;\n        bool lock; // prevents malicious delays\n    }\n\n    // Single global store\n    struct Storage {\n        address Necc; // token given as payment for bond\n        address nNecc; // token given for staking\n        address nusd; // principle token without price feed\n        address treasury; // mints Necc when receives principle\n        address DAO; // receives profit share from bond\n        address staking; // to auto-stake payout\n        address stakingHelper; // to stake and claim if no staking warmup\n        //\n        EnumerableSet.AddressSet principles;\n        mapping(uint256 => Terms) terms; // stores terms for new bonds\n        mapping(uint256 => BondDepositoryAdjustment) bondDepositoryAdjustment; // stores adjustment to BCV data\n        mapping(address => mapping(uint256 => Bond)) bondInfo; // stores bond information for depositors\n        mapping(uint256 => uint256) totalDebt; // total value of outstanding bonds; used for pricing\n        mapping(uint256 => uint256) lastDecay; // reference time for debt decay\n        mapping(uint256 => uint256) nextEpochTimestamp; // block number of next epoch\n        //\n        Info[] info; // stores infof or distribution recipients\n        mapping(uint256 => DistributorAdjustment) distributorAdjustments;\n        //\n        Epoch epoch;\n        uint256 epochLength;\n        address distributor;\n        address locker;\n        uint256 totalBonus;\n        uint256 warmupPeriod;\n        mapping(address => Claim) warmupInfo;\n        //\n        uint256 targetSum; // target total Necc as payouts during period\n        mapping(uint256 => Payout[]) payouts; // storage of all past payouts\n        mapping(uint256 => uint256) weights; // weight per bond type\n        uint256 totalWeight; // total weight (denominator)\n\n        // Always add new storage variable to the end of this struct\n    }\n}\n"
    },
    "contracts/facets/Bond/BondDepositoryLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\nimport \"./LibBondStorage.sol\";\n\nlibrary BondDepositoryLib {\n    function getIndexAt(LibBondStorage.Storage storage s, address _principle)\n        internal\n        view\n        returns (uint256 _index)\n    {\n        uint256 _principleLength = EnumerableSet.length(s.principles);\n        for (uint256 i = 0; i < _principleLength; i++) {\n            if (EnumerableSet.at(s.principles, i) == _principle) {\n                return i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/facets/Bond/Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"./LibBondStorage.sol\";\nimport \"../../lib/LibDiamond.sol\";\n\ncontract Facet {\n    LibBondStorage.Storage internal s;\n\n    function onlyGov() internal view {\n        LibDiamond.enforceIsContractOwner();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/drafts/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/drafts/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/facets/Bond/StakingWarmupFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./Facet.sol\";\n\ncontract StakingWarmupFacet is Facet {\n    function initializeStakingWarmup(address _nNecc) public {\n        require(_nNecc != address(0));\n        s.nNecc = _nNecc;\n    }\n\n    function retrieve(address _staker, uint256 _amount) external {\n        require(msg.sender == address(this));\n        IERC20(s.nNecc).transfer(_staker, _amount);\n    }\n}\n"
    },
    "contracts/tokens/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract Token is IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor() {\n        _name = \"Token\";\n        _symbol = \"TOKEN\";\n        _decimals = 18;\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function withdrawToken(\n        address token,\n        address account,\n        uint256 amount\n    ) public {\n        IERC20(token).transfer(account, amount);\n    }\n\n    function deposit() public payable {\n        _balances[msg.sender] = _balances[msg.sender].add(msg.value);\n    }\n\n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _msgSender().transfer(amount);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(\n            amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(address(msg.sender));\n    }\n}\n"
    },
    "contracts/tokens/NUSD/YieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/drafts/ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IYieldToken.sol\";\n\ncontract YieldToken is ERC20Permit, IYieldToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public gov;\n\n    // [ownder] => balance\n    mapping(address => uint256) public balances;\n    // [owner][spender] => allowance\n    mapping(address => mapping(address => uint256)) public allowances;\n\n    mapping(address => bool) public admins;\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"YieldToken: forbidden\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"YieldToken: forbidden\");\n        _;\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _initialSupply\n    ) ERC20Permit(_name) ERC20(_name, _symbol) {\n        gov = msg.sender;\n        admins[msg.sender] = true;\n        _mint(msg.sender, _initialSupply);\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function addAdmin(address _account) external onlyGov {\n        admins[_account] = true;\n    }\n\n    function removeAdmin(address _account) external override onlyGov {\n        admins[_account] = false;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(\n        address _token,\n        address _account,\n        uint256 _amount\n    ) external onlyAdmin {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IYieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IYieldToken {\n    function removeAdmin(address _account) external;\n}\n"
    },
    "contracts/peripherals/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/ITimelockTarget.sol\";\nimport \"../core/interfaces/IVault.sol\";\nimport \"../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../core/interfaces/IRouter.sol\";\nimport \"../tokens/interfaces/IYieldToken.sol\";\n\ncontract Timelock {\n    using SafeMath for uint256;\n\n    uint256 public constant PRICE_PRECISION = 10**30;\n\n    uint256 public buffer;\n    address public admin;\n\n    mapping(bytes32 => uint256) public pendingActions;\n\n    event SignalPendingAction(bytes32 action);\n    event SignalApprove(\n        address token,\n        address spender,\n        uint256 amount,\n        bytes32 action\n    );\n    event SignalSetGov(address target, address gov, bytes32 action);\n    event SignalSetPriceFeed(address vault, address priceFeed, bytes32 action);\n    event SignalAddPlugin(address router, address plugin, bytes32 action);\n    event ClearAction(bytes32 action);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Timelock: forbidden\");\n        _;\n    }\n\n    constructor(uint256 _buffer) {\n        buffer = _buffer;\n        admin = msg.sender;\n    }\n\n    function setFees(\n        address _vault,\n        uint256 _swapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd\n    ) external onlyAdmin {\n        require(\n            _swapFeeBasisPoints < 100,\n            \"Timelock: invalid _swapFeeBasisPoints\"\n        );\n        require(\n            _marginFeeBasisPoints < 100,\n            \"Timelock: invalid _marginFeeBasisPoints\"\n        );\n        require(\n            _liquidationFeeUsd < 10 * PRICE_PRECISION,\n            \"Timelock: invalid _liquidationFeeUsd\"\n        );\n\n        IVault(_vault).setFees(\n            _swapFeeBasisPoints,\n            _marginFeeBasisPoints,\n            _liquidationFeeUsd\n        );\n    }\n\n    function removeAdmin(address _token, address _account) external onlyAdmin {\n        IYieldToken(_token).removeAdmin(_account);\n    }\n\n    function setIsAmmEnabled(address _priceFeed, bool _isEnabled)\n        external\n        onlyAdmin\n    {\n        IVaultPriceFeed(_priceFeed).setIsAmmEnabled(_isEnabled);\n    }\n\n    function setIsSecondaryPriceEnabled(address _priceFeed, bool _isEnabled)\n        external\n        onlyAdmin\n    {\n        IVaultPriceFeed(_priceFeed).setIsSecondaryPriceEnabled(_isEnabled);\n    }\n\n    function setMaxStrictPriceDeviation(\n        address _priceFeed,\n        uint256 _maxStrictPriceDeviation\n    ) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setMaxStrictPriceDeviation(\n            _maxStrictPriceDeviation\n        );\n    }\n\n    function setSpreadBasisPoints(\n        address _token,\n        address _priceFeed,\n        uint256 _spreadBasisPoints\n    ) external onlyAdmin {\n        IVaultPriceFeed(_priceFeed).setSpreadBasisPoints(\n            _token,\n            _spreadBasisPoints\n        );\n    }\n\n    function setPriceSampleSpace(address _priceFeed, uint256 _priceSampleSpace)\n        external\n        onlyAdmin\n    {\n        require(_priceSampleSpace <= 3, \"Invalid _priceSampleSpace\");\n        IVaultPriceFeed(_priceFeed).setPriceSampleSpace(_priceSampleSpace);\n    }\n\n    function setIsMintingEnabled(address _vault, bool _isMintingEnabled)\n        external\n        onlyAdmin\n    {\n        IVault(_vault).setIsMintingEnabled(_isMintingEnabled);\n    }\n\n    function setMaxNUSD(\n        address _vault,\n        uint256 _maxNUSDBatchSize,\n        uint256 _maxNUSDBuffer\n    ) external onlyAdmin {\n        IVault(_vault).setMaxNUSD(_maxNUSDBatchSize, _maxNUSDBuffer);\n    }\n\n    function signalApprove(\n        address _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyAdmin {\n        bytes32 action = keccak256(\n            abi.encodePacked(\"approve\", _token, _spender, _amount)\n        );\n        _setPendingAction(action);\n        emit SignalApprove(_token, _spender, _amount, action);\n    }\n\n    function approve(\n        address _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyAdmin {\n        bytes32 action = keccak256(\n            abi.encodePacked(\"approve\", _token, _spender, _amount)\n        );\n        _validateAction(action);\n        IERC20(_token).approve(_spender, _amount);\n        _clearAction(action);\n    }\n\n    function signalSetGov(address _target, address _gov) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _setPendingAction(action);\n        emit SignalSetGov(_target, _gov, action);\n    }\n\n    function setGov(address _target, address _gov) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _validateAction(action);\n        ITimelockTarget(_target).setGov(_gov);\n        _clearAction(action);\n    }\n\n    function signalSetPriceFeed(address _vault, address _priceFeed)\n        external\n        onlyAdmin\n    {\n        bytes32 action = keccak256(\n            abi.encodePacked(\"setPriceFeed\", _vault, _priceFeed)\n        );\n        _setPendingAction(action);\n        emit SignalSetPriceFeed(_vault, _priceFeed, action);\n    }\n\n    function setPriceFeed(address _vault, address _priceFeed)\n        external\n        onlyAdmin\n    {\n        bytes32 action = keccak256(\n            abi.encodePacked(\"setPriceFeed\", _vault, _priceFeed)\n        );\n        _validateAction(action);\n        IVault(_vault).setPriceFeed(_priceFeed);\n        _clearAction(action);\n    }\n\n    function withdrawFees(\n        address _vault,\n        address _token,\n        address _receiver\n    ) external onlyAdmin {\n        IVault(_vault).withdrawFees(_token, _receiver);\n    }\n\n    function signalAddPlugin(address _router, address _plugin)\n        external\n        onlyAdmin\n    {\n        bytes32 action = keccak256(\n            abi.encodePacked(\"addPlugin\", _router, _plugin)\n        );\n        _setPendingAction(action);\n        emit SignalAddPlugin(_router, _plugin, action);\n    }\n\n    function addPlugin(address _router, address _plugin) external onlyAdmin {\n        bytes32 action = keccak256(\n            abi.encodePacked(\"addPlugin\", _router, _plugin)\n        );\n        _validateAction(action);\n        IRouter(_router).addPlugin(_plugin);\n        _clearAction(action);\n    }\n\n    function cancelAction(bytes32 _action) external onlyAdmin {\n        _clearAction(_action);\n    }\n\n    function _setPendingAction(bytes32 _action) private {\n        pendingActions[_action] = block.timestamp.add(buffer);\n        emit SignalPendingAction(_action);\n    }\n\n    function _validateAction(bytes32 _action) private view {\n        require(pendingActions[_action] != 0, \"Timelock: action not signalled\");\n        require(\n            pendingActions[_action] < block.timestamp,\n            \"Timelock: action time not yet passed\"\n        );\n    }\n\n    function _clearAction(bytes32 _action) private {\n        require(pendingActions[_action] != 0, \"Timelock: invalid _action\");\n        delete pendingActions[_action];\n        emit ClearAction(_action);\n    }\n}\n"
    },
    "contracts/peripherals/interfaces/ITimelockTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface ITimelockTarget {\n    function setGov(address _gov) external;\n\n    function withdrawToken(\n        address _token,\n        address _account,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/core/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IVault {\n    function getRedemptionCollateralUsd(address _token)\n        external\n        view\n        returns (uint256);\n\n    function setIsMintingEnabled(bool _isMintingEnabled) external;\n\n    function setFees(\n        uint256 _swapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd\n    ) external;\n\n    function setPriceFeed(address _priceFeed) external;\n\n    function setMaxNUSD(uint256 _maxNUSDBatchSize, uint256 _maxNUSDBuffer)\n        external;\n\n    function directPoolDeposit(address _token) external;\n\n    function buyNUSD(address _token, address _receiver)\n        external\n        returns (uint256);\n\n    function sellNUSD(address _token, address _receiver)\n        external\n        returns (uint256);\n\n    function swap(\n        address _tokenIn,\n        address _tokenOut,\n        address _receiver\n    ) external returns (uint256);\n\n    function increasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _sizeDelta,\n        bool _isLong\n    ) external;\n\n    function decreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) external returns (uint256);\n\n    function priceFeed() external view returns (address);\n\n    function fundingRateFactor() external view returns (uint256);\n\n    function cumulativeFundingRates(address _token)\n        external\n        view\n        returns (uint256);\n\n    function getNextFundingRate(address _token) external view returns (uint256);\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function swapFeeBasisPoints() external view returns (uint256);\n\n    function feeReserves(address _token) external view returns (uint256);\n\n    function tokenDecimals(address _token) external view returns (uint256);\n\n    function guaranteedUsd(address _token) external view returns (uint256);\n\n    function poolAmounts(address _token) external view returns (uint256);\n\n    function reservedAmounts(address _token) external view returns (uint256);\n\n    function nusdAmounts(address _token) external view returns (uint256);\n\n    function getRedemptionAmount(address _token, uint256 _nusdAmount)\n        external\n        view\n        returns (uint256);\n\n    function getMaxPrice(address _token) external view returns (uint256);\n\n    function getMinPrice(address _token) external view returns (uint256);\n\n    function getUtilisation(address _token) external view returns (uint256);\n\n    function getDelta(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _lastIncreasedTime\n    ) external view returns (bool, uint256);\n\n    function getPosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256\n        );\n\n    function adjustForDecimals(\n        uint256 _amount,\n        address _tokenDiv,\n        address _tokenMul\n    ) external view returns (uint256);\n\n    function withdrawFees(address _token, address _receiver)\n        external\n        returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IVaultPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IVaultPriceFeed {\n    function setIsAmmEnabled(bool _isEnabled) external;\n\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;\n\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external;\n\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints)\n        external;\n\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints)\n        external;\n\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external;\n\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation)\n        external;\n\n    function getPrice(\n        address _token,\n        bool _maximise,\n        bool _includeAmmPrice\n    ) external view returns (uint256);\n\n    function getAmmPrice(address _token) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IRouter {\n    function addPlugin(address _plugin) external;\n\n    function nusd() external view returns (address);\n\n    function swap(\n        address[] memory _path,\n        uint256 _amountIn,\n        uint256 _minOut,\n        address _receiver\n    ) external;\n\n    function vault() external view returns (address);\n}\n"
    },
    "contracts/core/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../tokens/interfaces/IWETH.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRouter.sol\";\n\ncontract Router is IRouter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    address public gov;\n\n    address public weth;\n    address public override nusd;\n    address public override vault;\n\n    mapping(address => bool) public plugins;\n    mapping(address => mapping(address => bool)) public approvedPlugins;\n\n    event Swap(\n        address account,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"Router: forbidden\");\n        _;\n    }\n\n    constructor(\n        address _vault,\n        address _nusd,\n        address _weth\n    ) {\n        vault = _vault;\n        nusd = _nusd;\n        weth = _weth;\n\n        gov = msg.sender;\n    }\n\n    receive() external payable {\n        require(msg.sender == weth, \"Router: invalid sender\");\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function addPlugin(address _plugin) external override onlyGov {\n        plugins[_plugin] = true;\n    }\n\n    function removePlugin(address _plugin) external onlyGov {\n        plugins[_plugin] = false;\n    }\n\n    function approvePlugin(address _plugin) external {\n        approvedPlugins[msg.sender][_plugin] = true;\n    }\n\n    function denyPlugin(address _plugin) external {\n        approvedPlugins[msg.sender][_plugin] = false;\n    }\n\n    function pluginTransfer(\n        address _token,\n        address _account,\n        address _receiver,\n        uint256 _amount\n    ) external {\n        _validatePlugin(_account);\n        IERC20(_token).safeTransferFrom(_account, _receiver, _amount);\n    }\n\n    function pluginIncreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _sizeDelta,\n        bool _isLong\n    ) external {\n        _validatePlugin(_account);\n        IVault(vault).increasePosition(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _sizeDelta,\n            _isLong\n        );\n    }\n\n    function pluginDecreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) external returns (uint256) {\n        _validatePlugin(_account);\n        return\n            IVault(vault).decreasePosition(\n                _account,\n                _collateralToken,\n                _indexToken,\n                _collateralDelta,\n                _sizeDelta,\n                _isLong,\n                _receiver\n            );\n    }\n\n    function directPoolDeposit(address _token, uint256 _amount) external {\n        IERC20(_token).safeTransferFrom(_sender(), vault, _amount);\n        IVault(vault).directPoolDeposit(_token);\n    }\n\n    function swap(\n        address[] memory _path,\n        uint256 _amountIn,\n        uint256 _minOut,\n        address _receiver\n    ) public override {\n        IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        uint256 amountOut = _swap(_path, _minOut, _receiver);\n        emit Swap(\n            msg.sender,\n            _path[0],\n            _path[_path.length - 1],\n            _amountIn,\n            amountOut\n        );\n    }\n\n    function swapETHToTokens(\n        address[] memory _path,\n        uint256 _minOut,\n        address _receiver\n    ) external payable {\n        require(_path[0] == weth, \"Router: invalid _path\");\n        _transferETHToVault();\n        uint256 amountOut = _swap(_path, _minOut, _receiver);\n        emit Swap(\n            msg.sender,\n            _path[0],\n            _path[_path.length - 1],\n            msg.value,\n            amountOut\n        );\n    }\n\n    function swapTokensToETH(\n        address[] memory _path,\n        uint256 _amountIn,\n        uint256 _minOut,\n        address payable _receiver\n    ) external {\n        require(_path[_path.length - 1] == weth, \"Router: invalid _path\");\n        IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        uint256 amountOut = _swap(_path, _minOut, address(this));\n        _transferOutETH(amountOut, _receiver);\n        emit Swap(\n            msg.sender,\n            _path[0],\n            _path[_path.length - 1],\n            _amountIn,\n            amountOut\n        );\n    }\n\n    function increasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _amountIn,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _price\n    ) external {\n        if (_amountIn > 0) {\n            IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        }\n        if (_path.length > 1 && _amountIn > 0) {\n            uint256 amountOut = _swap(_path, _minOut, address(this));\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, amountOut);\n        }\n        _increasePosition(\n            _path[_path.length - 1],\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _price\n        );\n    }\n\n    function increasePositionETH(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _price\n    ) external payable {\n        require(_path[0] == weth, \"Router: invalid _path\");\n        if (msg.value > 0) {\n            _transferETHToVault();\n        }\n        if (_path.length > 1 && msg.value > 0) {\n            uint256 amountOut = _swap(_path, _minOut, address(this));\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, amountOut);\n        }\n        _increasePosition(\n            _path[_path.length - 1],\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _price\n        );\n    }\n\n    function decreasePosition(\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _price\n    ) external {\n        _decreasePosition(\n            _collateralToken,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong,\n            _receiver,\n            _price\n        );\n    }\n\n    function decreasePositionETH(\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address payable _receiver,\n        uint256 _price\n    ) external {\n        uint256 amountOut = _decreasePosition(\n            _collateralToken,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong,\n            address(this),\n            _price\n        );\n        _transferOutETH(amountOut, _receiver);\n    }\n\n    function _increasePosition(\n        address _collateralToken,\n        address _indexToken,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _price\n    ) private {\n        if (_isLong) {\n            require(\n                IVault(vault).getMaxPrice(_indexToken) <= _price,\n                \"Router: mark price higher than limit\"\n            );\n        } else {\n            require(\n                IVault(vault).getMinPrice(_indexToken) >= _price,\n                \"Router: mark price lower than limit\"\n            );\n        }\n\n        IVault(vault).increasePosition(\n            _sender(),\n            _collateralToken,\n            _indexToken,\n            _sizeDelta,\n            _isLong\n        );\n    }\n\n    function _decreasePosition(\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _price\n    ) private returns (uint256) {\n        if (_isLong) {\n            require(\n                IVault(vault).getMinPrice(_indexToken) >= _price,\n                \"Router: mark price lower than limit\"\n            );\n        } else {\n            require(\n                IVault(vault).getMaxPrice(_indexToken) <= _price,\n                \"Router: mark price higher than limit\"\n            );\n        }\n\n        uint256 amountOut = IVault(vault).decreasePosition(\n            _sender(),\n            _collateralToken,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong,\n            _receiver\n        );\n\n        return amountOut;\n    }\n\n    function _transferETHToVault() private {\n        IWETH(weth).deposit{value: msg.value}();\n        IERC20(weth).safeTransfer(vault, msg.value);\n    }\n\n    function _transferOutETH(uint256 _amountOut, address payable _receiver)\n        private\n    {\n        IWETH(weth).withdraw(_amountOut);\n        _receiver.sendValue(_amountOut);\n    }\n\n    function _swap(\n        address[] memory _path,\n        uint256 _minOut,\n        address _receiver\n    ) private returns (uint256) {\n        if (_path.length == 2) {\n            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\n        }\n        if (_path.length == 3) {\n            uint256 midOut = _vaultSwap(_path[0], _path[1], 0, address(this));\n            IERC20(_path[1]).safeTransfer(vault, midOut);\n            return _vaultSwap(_path[1], _path[2], _minOut, _receiver);\n        }\n\n        revert(\"Router: invalid _path.length\");\n    }\n\n    function _vaultSwap(\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _minOut,\n        address _receiver\n    )\n        private\n        returns (\n            // uint256 _amountIn\n            uint256\n        )\n    {\n        uint256 _amountOut;\n\n        if (_tokenOut == nusd) {\n            // buyNUSD\n            _amountOut = IVault(vault).buyNUSD(_tokenIn, _receiver);\n        } else if (_tokenIn == nusd) {\n            // sellNUSD\n            _amountOut = IVault(vault).sellNUSD(_tokenOut, _receiver);\n        } else {\n            // swap\n            _amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\n        }\n\n        require(_amountOut >= _minOut, \"Router: insufficient amountOut\");\n\n        /* Minting means contributing collateral for lending */\n\n        return _amountOut;\n    }\n\n    function _sender() private view returns (address) {\n        return msg.sender;\n    }\n\n    function _validatePlugin(address _account) private view {\n        require(plugins[msg.sender], \"Router: invalid plugin\");\n        require(\n            approvedPlugins[_account][msg.sender],\n            \"Router: plugin not approved\"\n        );\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IWETH.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/peripherals/Reader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../core/interfaces/IVault.sol\";\nimport \"../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../tokens/interfaces/IYieldToken.sol\";\nimport \"../amm/interfaces/IUniswapV2Factory.sol\";\n\ncontract Reader {\n    using SafeMath for uint256;\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant POSITION_PROPS_LENGTH = 9;\n\n    function getMaxAmountIn(\n        IVault _vault,\n        address _tokenIn,\n        address _tokenOut\n    ) public view returns (uint256) {\n        uint256 priceIn = _vault.getMinPrice(_tokenIn);\n        uint256 priceOut = _vault.getMaxPrice(_tokenOut);\n        uint256 poolAmount = _vault.poolAmounts(_tokenOut);\n        uint256 reservedAmount = _vault.reservedAmounts(_tokenOut);\n        uint256 availableAmount = poolAmount.sub(reservedAmount);\n\n        uint256 _amountIn = availableAmount.mul(priceOut).div(priceIn);\n        return _vault.adjustForDecimals(_amountIn, _tokenOut, _tokenIn);\n    }\n\n    function getAmountOut(\n        IVault _vault,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amountIn\n    ) public view returns (uint256, uint256) {\n        uint256 priceIn = _vault.getMinPrice(_tokenIn);\n        uint256 priceOut = _vault.getMaxPrice(_tokenOut);\n        uint256 amountOut = _amountIn.mul(priceIn).div(priceOut);\n        uint256 feeBasisPoints = _vault.swapFeeBasisPoints();\n        uint256 amountOutAfterFees = amountOut\n            .mul(BASIS_POINTS_DIVISOR.sub(feeBasisPoints))\n            .div(BASIS_POINTS_DIVISOR);\n        uint256 feeAmount = amountOut.sub(amountOutAfterFees);\n\n        return (amountOutAfterFees, feeAmount);\n    }\n\n    function getFees(address _vault, address[] memory _tokens)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory amounts = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amounts[i] = IVault(_vault).feeReserves(_tokens[i]);\n        }\n        return amounts;\n    }\n\n    // TODO: getTotalContributedCollateral()\n\n    function getPairInfo(address _factory, address[] memory _tokens)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256 inputLength = 2;\n        uint256 propsLength = 2;\n        uint256[] memory amounts = new uint256[](\n            (_tokens.length / inputLength) * propsLength\n        );\n        for (uint256 i = 0; i < _tokens.length / inputLength; i++) {\n            address token0 = _tokens[i * inputLength];\n            address token1 = _tokens[i * inputLength + 1];\n            address pair = IUniswapV2Factory(_factory).getPair(token0, token1);\n\n            amounts[i * propsLength] = IERC20(token0).balanceOf(pair);\n            amounts[i * propsLength + 1] = IERC20(token1).balanceOf(pair);\n        }\n        return amounts;\n    }\n\n    function getFundingRates(\n        address _vault,\n        address _weth,\n        address[] memory _tokens\n    ) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory fundingRates = new uint256[](\n            _tokens.length * propsLength\n        );\n        IVault vault = IVault(_vault);\n        uint256 fundingRateFactor = vault.fundingRateFactor();\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            uint256 reservedAmount = vault.reservedAmounts(token);\n            uint256 poolAmount = vault.poolAmounts(token);\n\n            if (poolAmount > 0) {\n                fundingRates[i * propsLength] = fundingRateFactor\n                    .mul(reservedAmount)\n                    .div(poolAmount);\n            }\n\n            if (vault.cumulativeFundingRates(token) > 0) {\n                uint256 nextRate = vault.getNextFundingRate(token);\n                uint256 baseRate = vault.cumulativeFundingRates(token);\n                fundingRates[i * propsLength + 1] = baseRate.add(nextRate);\n            }\n        }\n\n        return fundingRates;\n    }\n\n    function getTokenSupply(IERC20 _token, address[] memory _excludedAccounts)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 supply = _token.totalSupply();\n        for (uint256 i = 0; i < _excludedAccounts.length; i++) {\n            address account = _excludedAccounts[i];\n            uint256 balance = _token.balanceOf(account);\n            supply = supply.sub(balance);\n        }\n        return supply;\n    }\n\n    function getTokenBalances(address _account, address[] memory _tokens)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory balances = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                balances[i] = _account.balance;\n                continue;\n            }\n            balances[i] = IERC20(token).balanceOf(_account);\n        }\n        return balances;\n    }\n\n    function getTokenBalancesWithSupplies(\n        address _account,\n        address[] memory _tokens\n    ) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory balances = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                balances[i * propsLength] = _account.balance;\n                balances[i * propsLength + 1] = 0;\n                continue;\n            }\n            balances[i * propsLength] = IERC20(token).balanceOf(_account);\n            balances[i * propsLength + 1] = IERC20(token).totalSupply();\n        }\n        return balances;\n    }\n\n    function getVaultTokenInfo(\n        address _vault,\n        address _weth,\n        uint256 _nusdAmount,\n        address[] memory _tokens\n    ) public view returns (uint256[] memory) {\n        uint256 propsLength = 9;\n\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.nusdAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(\n                token,\n                _nusdAmount\n            );\n            amounts[i * propsLength + 4] = vault.getMinPrice(token);\n            amounts[i * propsLength + 5] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 6] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 7] = priceFeed.getPrice(\n                token,\n                false,\n                false\n            );\n            amounts[i * propsLength + 8] = priceFeed.getPrice(\n                token,\n                true,\n                false\n            );\n        }\n\n        return amounts;\n    }\n\n    function getPositions(\n        address _vault,\n        address _account,\n        address[] memory _collateralTokens,\n        address[] memory _indexTokens,\n        bool[] memory _isLong\n    ) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](\n            _collateralTokens.length * POSITION_PROPS_LENGTH\n        );\n\n        for (uint256 i = 0; i < _collateralTokens.length; i++) {\n            {\n                (\n                    uint256 size,\n                    uint256 collateral,\n                    uint256 averagePrice,\n                    uint256 entryFundingRate,\n                    ,\n                    /* reserveAmount */\n                    uint256 realisedPnl,\n                    bool hasRealisedProfit,\n                    uint256 lastIncreasedTime\n                ) = IVault(_vault).getPosition(\n                        _account,\n                        _collateralTokens[i],\n                        _indexTokens[i],\n                        _isLong[i]\n                    );\n\n                amounts[i * POSITION_PROPS_LENGTH] = size;\n                amounts[i * POSITION_PROPS_LENGTH + 1] = collateral;\n                amounts[i * POSITION_PROPS_LENGTH + 2] = averagePrice;\n                amounts[i * POSITION_PROPS_LENGTH + 3] = entryFundingRate;\n                amounts[i * POSITION_PROPS_LENGTH + 4] = hasRealisedProfit\n                    ? 1\n                    : 0;\n                amounts[i * POSITION_PROPS_LENGTH + 5] = realisedPnl;\n                amounts[i * POSITION_PROPS_LENGTH + 6] = lastIncreasedTime;\n            }\n\n            uint256 _size = amounts[i * POSITION_PROPS_LENGTH];\n            uint256 _averagePrice = amounts[i * POSITION_PROPS_LENGTH + 2];\n            uint256 _lastIncreasedTime = amounts[i * POSITION_PROPS_LENGTH + 6];\n            if (_averagePrice > 0) {\n                (bool hasProfit, uint256 delta) = IVault(_vault).getDelta(\n                    _indexTokens[i],\n                    _size,\n                    _averagePrice,\n                    _isLong[i],\n                    _lastIncreasedTime\n                );\n                amounts[i * POSITION_PROPS_LENGTH + 7] = hasProfit ? 1 : 0;\n                amounts[i * POSITION_PROPS_LENGTH + 8] = delta;\n            }\n        }\n\n        return amounts;\n    }\n}\n"
    },
    "contracts/amm/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setMigrator(address) external;\n}\n"
    },
    "contracts/facets/Reader/ReaderFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IVaultPriceFeed.sol\";\nimport \"../../amm/interfaces/IUniswapV2Factory.sol\";\nimport \"../Vault/VaultLib.sol\";\nimport \"../../lib/Facet.sol\";\n\ncontract ReaderFacet is Facet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    function getMaxAmountIn(\n        IVault,\n        address _tokenIn,\n        address _tokenOut\n    ) public view returns (uint256) {\n        uint256 priceIn = VaultLib.getMinPrice(_tokenIn, s.includeAmmPrice);\n        uint256 priceOut = VaultLib.getMaxPrice(_tokenOut, s.includeAmmPrice);\n        uint256 poolAmount = s.poolAmounts[_tokenOut];\n        uint256 reservedAmount = s.reservedAmounts[_tokenOut];\n        uint256 availableAmount = poolAmount.sub(reservedAmount);\n        uint256 _amountIn = availableAmount.mul(priceOut).div(priceIn);\n\n        return VaultLib.adjustForDecimals(s, _amountIn, _tokenOut, _tokenIn);\n    }\n\n    function getAmountOut(\n        IVault,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amountIn\n    ) public view returns (uint256, uint256) {\n        uint256 priceIn = VaultLib.getMinPrice(_tokenIn, s.includeAmmPrice);\n        uint256 priceOut = VaultLib.getMaxPrice(_tokenOut, s.includeAmmPrice);\n        uint256 amountOut = _amountIn.mul(priceIn).div(priceOut);\n        uint256 amountOutAfterFees = amountOut\n            .mul(BASIS_POINTS_DIVISOR.sub(SWAP_FEE_BASIS_POINTS))\n            .div(BASIS_POINTS_DIVISOR);\n        uint256 feeAmount = amountOut.sub(amountOutAfterFees);\n\n        return (amountOutAfterFees, feeAmount);\n    }\n\n    function getFees(address, address[] memory _tokens)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory amounts = new uint256[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amounts[i] = s.feeReserves[_tokens[i]];\n        }\n\n        return amounts;\n    }\n\n    // TODO: getTotalContributedCollateral()\n\n    function getPairInfo(address _factory, address[] memory _tokens)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256 inputLength = 2;\n        uint256 propsLength = 2;\n        uint256[] memory amounts = new uint256[](\n            (_tokens.length / inputLength) * propsLength\n        );\n\n        for (uint256 i = 0; i < _tokens.length / inputLength; i++) {\n            address token0 = _tokens[i * inputLength];\n            address token1 = _tokens[i * inputLength + 1];\n            address pair = IUniswapV2Factory(_factory).getPair(token0, token1);\n\n            amounts[i * propsLength] = IERC20(token0).balanceOf(pair);\n            amounts[i * propsLength + 1] = IERC20(token1).balanceOf(pair);\n        }\n\n        return amounts;\n    }\n\n    function getFundingRates(\n        address,\n        address _weth,\n        address[] memory _tokens\n    ) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory fundingRates = new uint256[](\n            _tokens.length * propsLength\n        );\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n\n            uint256 reservedAmount = s.reservedAmounts[token];\n            uint256 poolAmount = s.poolAmounts[token];\n\n            if (poolAmount > 0) {\n                fundingRates[i * propsLength] = FUNDING_RATE_FACTOR\n                    .mul(reservedAmount)\n                    .div(poolAmount);\n            }\n\n            if (s.cumulativeFundingRates[token] > 0) {\n                uint256 nextRate = VaultLib._getNextFundingRate(s, token);\n                uint256 baseRate = s.cumulativeFundingRates[token];\n                fundingRates[i * propsLength + 1] = baseRate.add(nextRate);\n            }\n        }\n\n        return fundingRates;\n    }\n\n    function getTokenSupply(IERC20 _token, address[] memory _excludedAccounts)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 supply = _token.totalSupply();\n        for (uint256 i = 0; i < _excludedAccounts.length; i++) {\n            address account = _excludedAccounts[i];\n            uint256 balance = _token.balanceOf(account);\n            supply = supply.sub(balance);\n        }\n\n        return supply;\n    }\n\n    function getTokenBalances(address _account, address[] memory _tokens)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory balances = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                balances[i] = _account.balance;\n                continue;\n            }\n            balances[i] = IERC20(token).balanceOf(_account);\n        }\n        return balances;\n    }\n\n    function getTokenBalancesWithSupplies(\n        address _account,\n        address[] memory _tokens\n    ) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory balances = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                balances[i * propsLength] = _account.balance;\n                balances[i * propsLength + 1] = 0;\n                continue;\n            }\n            balances[i * propsLength] = IERC20(token).balanceOf(_account);\n            balances[i * propsLength + 1] = IERC20(token).totalSupply();\n        }\n        return balances;\n    }\n\n    function getVaultTokenInfo(\n        address,\n        address _weth,\n        uint256 _nusdAmount,\n        address[] memory _tokens\n    ) public view returns (uint256[] memory) {\n        uint256 propsLength = 9;\n\n        IVault vault = IVault(address(this));\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(address(this));\n\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            if (token != s.nusd) {\n                amounts[i * propsLength] = s.poolAmounts[token];\n                amounts[i * propsLength + 1] = s.reservedAmounts[token];\n                amounts[i * propsLength + 2] = s.nusdAmounts[token];\n                amounts[i * propsLength + 3] = vault.getRedemptionAmount(\n                    token,\n                    _nusdAmount\n                );\n                amounts[i * propsLength + 4] = VaultLib.getMinPrice(\n                    token,\n                    s.includeAmmPrice\n                );\n                amounts[i * propsLength + 5] = VaultLib.getMaxPrice(\n                    token,\n                    s.includeAmmPrice\n                );\n                amounts[i * propsLength + 6] = s.guaranteedUsd[token];\n                amounts[i * propsLength + 7] = priceFeed.getPrice(\n                    token,\n                    false,\n                    false\n                );\n                amounts[i * propsLength + 8] = priceFeed.getPrice(\n                    token,\n                    true,\n                    false\n                );\n            }\n        }\n\n        return amounts;\n    }\n\n    function getPositions(\n        address,\n        address _account,\n        address[] memory _collateralTokens,\n        address[] memory _indexTokens,\n        bool[] memory _isLong\n    ) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](\n            _collateralTokens.length * POSITION_PROPS_LENGTH\n        );\n\n        for (uint256 i = 0; i < _collateralTokens.length; i++) {\n            {\n                (\n                    uint256 size,\n                    uint256 collateral,\n                    uint256 averagePrice,\n                    uint256 entryFundingRate,\n                    ,\n                    /* reserveAmount */\n                    uint256 realisedPnl,\n                    bool hasRealisedProfit,\n                    uint256 lastIncreasedTime\n                ) = IVault(address(this)).getPosition(\n                        _account,\n                        _collateralTokens[i],\n                        _indexTokens[i],\n                        _isLong[i]\n                    );\n\n                amounts[i * POSITION_PROPS_LENGTH] = size;\n                amounts[i * POSITION_PROPS_LENGTH + 1] = collateral;\n                amounts[i * POSITION_PROPS_LENGTH + 2] = averagePrice;\n                amounts[i * POSITION_PROPS_LENGTH + 3] = entryFundingRate;\n                amounts[i * POSITION_PROPS_LENGTH + 4] = hasRealisedProfit\n                    ? 1\n                    : 0;\n                amounts[i * POSITION_PROPS_LENGTH + 5] = realisedPnl;\n                amounts[i * POSITION_PROPS_LENGTH + 6] = lastIncreasedTime;\n            }\n\n            uint256 _size = amounts[i * POSITION_PROPS_LENGTH];\n            uint256 _averagePrice = amounts[i * POSITION_PROPS_LENGTH + 2];\n            uint256 _lastIncreasedTime = amounts[i * POSITION_PROPS_LENGTH + 6];\n            if (_averagePrice > 0) {\n                (bool hasProfit, uint256 delta) = IVault(address(this))\n                    .getDelta(\n                        _indexTokens[i],\n                        _size,\n                        _averagePrice,\n                        _isLong[i],\n                        _lastIncreasedTime\n                    );\n                amounts[i * POSITION_PROPS_LENGTH + 7] = hasProfit ? 1 : 0;\n                amounts[i * POSITION_PROPS_LENGTH + 8] = delta;\n            }\n        }\n\n        return amounts;\n    }\n}\n"
    },
    "contracts/facets/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IVault {\n    function getRedemptionCollateralUsd(address _token)\n        external\n        view\n        returns (uint256);\n\n    function setIsMintingEnabled(bool _isMintingEnabled) external;\n\n    function setFees(\n        uint256 _swapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd\n    ) external;\n\n    function setPriceFeed(address _priceFeed) external;\n\n    function setMaxNUSD(uint256 _maxNUSDBatchSize, uint256 _maxNUSDBuffer)\n        external;\n\n    function directPoolDeposit(address _token) external;\n\n    function buyNUSD(address _token, address _receiver)\n        external\n        returns (uint256);\n\n    function sellNUSD(address _token, address _receiver)\n        external\n        returns (uint256);\n\n    function swap(\n        address _tokenIn,\n        address _tokenOut,\n        address _receiver\n    ) external returns (uint256);\n\n    function increasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _sizeDelta,\n        bool _isLong\n    ) external;\n\n    function decreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) external returns (uint256);\n\n    function priceFeed() external view returns (address);\n\n    function fundingRateFactor() external view returns (uint256);\n\n    function cumulativeFundingRates(address _token)\n        external\n        view\n        returns (uint256);\n\n    function getNextFundingRate(address _token) external view returns (uint256);\n\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\n\n    function swapFeeBasisPoints() external view returns (uint256);\n\n    function feeReserves(address _token) external view returns (uint256);\n\n    function tokenDecimals(address _token) external view returns (uint256);\n\n    function guaranteedUsd(address _token) external view returns (uint256);\n\n    function poolAmounts(address _token) external view returns (uint256);\n\n    function reservedAmounts(address _token) external view returns (uint256);\n\n    function nusdAmounts(address _token) external view returns (uint256);\n\n    function getRedemptionAmount(address _token, uint256 _nusdAmount)\n        external\n        view\n        returns (uint256);\n\n    function getMaxPrice(address _token) external view returns (uint256);\n\n    function getMinPrice(address _token) external view returns (uint256);\n\n    function getUtilisation(address _token) external view returns (uint256);\n\n    function getDelta(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _lastIncreasedTime\n    ) external view returns (bool, uint256);\n\n    function getPosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256\n        );\n\n    function adjustForDecimals(\n        uint256 _amount,\n        address _tokenDiv,\n        address _tokenMul\n    ) external view returns (uint256);\n\n    function withdrawFees(address _token, address _receiver)\n        external\n        returns (uint256);\n}\n"
    },
    "contracts/facets/interfaces/IVaultPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IVaultPriceFeed {\n    function setIsAmmEnabled(bool _isEnabled) external;\n\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;\n\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external;\n\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints)\n        external;\n\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints)\n        external;\n\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external;\n\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation)\n        external;\n\n    function getPrice(\n        address _token,\n        bool _maximise,\n        bool _includeAmmPrice\n    ) external view returns (uint256);\n\n    function getAmmPrice(address _token) external view returns (uint256);\n}\n"
    },
    "contracts/facets/Vault/VaultLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IVaultPriceFeed.sol\";\nimport \"../../lib/LibAppStorage.sol\";\n\n// import \"hardhat/console.sol\";\n\nlibrary VaultLib {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event IncreaseNUSDAmount(address token, uint256 amount);\n    event DecreaseNUSDAmount(address token, uint256 amount);\n    event CollectSwapFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event CollectMarginFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event IncreasePoolAmount(address token, uint256 amount);\n    event DecreasePoolAmount(address token, uint256 amount);\n    event UpdateFundingRate(address token, uint256 fundingRate);\n    event UpdatePnl(bytes32 key, bool hasProfit, uint256 delta);\n    event IncreaseReservedAmount(address token, uint256 amount);\n    event DecreaseReservedAmount(address token, uint256 amount);\n    event IncreaseGuaranteedUsd(address token, uint256 amount);\n    event DecreaseGuaranteedUsd(address token, uint256 amount);\n\n    function _getNextFundingRate(\n        LibAppStorage.Storage storage s,\n        address _token\n    ) internal view returns (uint256) {\n        if (\n            s.lastFundingTimes[_token].add(FUNDING_INTERVAL) > block.timestamp\n        ) {\n            return 0;\n        }\n\n        uint256 _intervals = block\n            .timestamp\n            .sub(s.lastFundingTimes[_token])\n            .div(FUNDING_INTERVAL);\n        uint256 _poolAmount = s.poolAmounts[_token];\n        if (_poolAmount == 0) {\n            return 0;\n        }\n\n        return\n            FUNDING_RATE_FACTOR\n                .mul(s.reservedAmounts[_token])\n                .mul(_intervals)\n                .div(_poolAmount);\n    }\n\n    function updateCumulativeFundingRate(\n        LibAppStorage.Storage storage s,\n        address _token\n    ) internal {\n        if (s.lastFundingTimes[_token] == 0) {\n            s.lastFundingTimes[_token] = block\n                .timestamp\n                .div(FUNDING_INTERVAL)\n                .mul(FUNDING_INTERVAL);\n            return;\n        }\n\n        if (\n            s.lastFundingTimes[_token].add(FUNDING_INTERVAL) > block.timestamp\n        ) {\n            return;\n        }\n\n        uint256 fundingRate = _getNextFundingRate(s, _token);\n        s.cumulativeFundingRates[_token] = s.cumulativeFundingRates[_token].add(\n            fundingRate\n        );\n        s.lastFundingTimes[_token] = block.timestamp.div(FUNDING_INTERVAL).mul(\n            FUNDING_INTERVAL\n        );\n\n        emit UpdateFundingRate(_token, s.cumulativeFundingRates[_token]);\n    }\n\n    function adjustForDecimals(\n        LibAppStorage.Storage storage s,\n        uint256 _amount,\n        address _tokenDiv,\n        address _tokenMul\n    ) internal view returns (uint256) {\n        uint256 _decimalsDiv = _tokenDiv == s.nusd\n            ? NUSD_DECIMALS\n            : s.tokenDecimals[_tokenDiv];\n        uint256 _decimalsMul = _tokenMul == s.nusd\n            ? NUSD_DECIMALS\n            : s.tokenDecimals[_tokenMul];\n\n        return _amount.mul(10**_decimalsMul).div(10**_decimalsDiv);\n    }\n\n    function getMinPrice(address _token, bool includeAmmPrice)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            IVaultPriceFeed(address(this)).getPrice(\n                _token,\n                false,\n                includeAmmPrice\n            );\n    }\n\n    function getMaxPrice(address _token, bool includeAmmPrice)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            IVaultPriceFeed(address(this)).getPrice(\n                _token,\n                true,\n                includeAmmPrice\n            );\n    }\n\n    function isTokenWhitelisted(LibAppStorage.Storage storage s, address _token)\n        internal\n        view\n    {\n        require(s.whitelistedTokens[_token], \"Vault: token not whitelisted\");\n    }\n\n    function isPoolAmountBelowBalance(\n        LibAppStorage.Storage storage s,\n        address _token\n    ) internal view {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        require(s.poolAmounts[_token] <= balance, \"Vault: invalid increase\");\n    }\n\n    function transferIn(LibAppStorage.Storage storage s, address _token)\n        internal\n        returns (uint256)\n    {\n        uint256 prevBalance = s.tokenBalances[_token];\n        uint256 nextBalance = IERC20(_token).balanceOf(address(this));\n        s.tokenBalances[_token] = nextBalance;\n\n        return nextBalance.sub(prevBalance);\n    }\n\n    function transferOut(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _amount,\n        address _receiver\n    ) internal {\n        IERC20(_token).safeTransfer(_receiver, _amount);\n        s.tokenBalances[_token] = IERC20(_token).balanceOf(address(this));\n    }\n\n    function tokenToUsdMin(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _tokenAmount\n    ) internal view returns (uint256) {\n        if (_tokenAmount == 0) {\n            return 0;\n        }\n        uint256 _price = getMinPrice(_token, s.includeAmmPrice);\n        uint256 _decimals = s.tokenDecimals[_token];\n\n        return _tokenAmount.mul(_price).div(10**_decimals);\n    }\n\n    function usdToTokenMin(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _usdAmount\n    ) internal view returns (uint256) {\n        if (_usdAmount == 0) {\n            return 0;\n        }\n        return\n            usdToToken(\n                s,\n                _token,\n                _usdAmount,\n                getMaxPrice(_token, s.includeAmmPrice)\n            );\n    }\n\n    function usdToToken(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _usdAmount,\n        uint256 _price\n    ) internal view returns (uint256) {\n        if (_usdAmount == 0) {\n            return 0;\n        }\n        uint256 _decimals = s.tokenDecimals[_token];\n\n        return _usdAmount.mul(10**_decimals).div(_price);\n    }\n\n    function tokenToUsdMax(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _tokenAmount,\n        bool includeAmmPrice\n    ) internal view returns (uint256) {\n        if (_tokenAmount == 0) {\n            return 0;\n        }\n        uint256 _price = getMaxPrice(_token, includeAmmPrice);\n        uint256 _decimals = s.tokenDecimals[_token];\n        return _tokenAmount.mul(_price).div(10**_decimals);\n    }\n\n    function usdToTokenMax(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _usdAmount,\n        bool includeAmmPrice\n    ) internal view returns (uint256) {\n        if (_usdAmount == 0) {\n            return 0;\n        }\n        return\n            usdToToken(\n                s,\n                _token,\n                _usdAmount,\n                getMinPrice(_token, includeAmmPrice)\n            );\n    }\n\n    function updateTokenBalance(LibAppStorage.Storage storage s, address _token)\n        internal\n    {\n        uint256 _nextBalance = IERC20(_token).balanceOf(address(this));\n\n        s.tokenBalances[_token] = _nextBalance;\n    }\n\n    function validatePosition(uint256 _size, uint256 _collateral)\n        internal\n        pure\n    {\n        if (_size == 0) {\n            require(_collateral == 0, \"Vault: collateral should be withdrawn\");\n            return;\n        }\n        require(\n            _size >= _collateral,\n            \"Vault: _size must be more than _collateral\"\n        );\n    }\n\n    function validateTokens(\n        LibAppStorage.Storage storage s,\n        address _collateralToken,\n        address _indexToken\n    ) internal view {\n        require(_collateralToken == _indexToken, \"Vault: mismatched tokens\");\n        isTokenWhitelisted(s, _collateralToken);\n        isTokenWhitelisted(s, _indexToken);\n    }\n\n    function getPositionKey(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    _account,\n                    _collateralToken,\n                    _indexToken,\n                    _isLong\n                )\n            );\n    }\n\n    function _collectSwapFees(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _amount\n    ) internal returns (uint256, uint256) {\n        uint256 _afterFeeAmount = _amount\n            .mul(BASIS_POINTS_DIVISOR.sub(SWAP_FEE_BASIS_POINTS))\n            .div(BASIS_POINTS_DIVISOR);\n        uint256 _feeAmount = _amount.sub(_afterFeeAmount);\n\n        s.feeReserves[_token] = s.feeReserves[_token].add(_feeAmount);\n\n        emit CollectSwapFees(\n            _token,\n            VaultLib.tokenToUsdMin(s, _token, _feeAmount),\n            _feeAmount\n        );\n        return (_feeAmount, _afterFeeAmount);\n    }\n\n    function _increasePoolAmount(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _amount\n    ) internal returns (uint256) {\n        s.poolAmounts[_token] = s.poolAmounts[_token].add(_amount);\n        isPoolAmountBelowBalance(s, _token);\n\n        emit IncreasePoolAmount(_token, _amount);\n\n        return s.poolAmounts[_token];\n    }\n\n    function _decreasePoolAmount(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _amount\n    ) internal {\n        s.poolAmounts[_token] = s.poolAmounts[_token].sub(\n            _amount,\n            \"Vault: poolAmount exceeded\"\n        );\n        require(\n            s.reservedAmounts[_token] <= s.poolAmounts[_token],\n            \"Vault: reserve exceeds pool\"\n        );\n\n        emit DecreasePoolAmount(_token, _amount);\n    }\n\n    function _transferRemainingCollateral(\n        LibAppStorage.Storage storage s,\n        address _collateralToken,\n        address _receiver,\n        uint256 _usdOut,\n        uint256 _usdOutAfterFee\n    ) internal returns (uint256) {\n        if (_usdOut > 0) {\n            VaultLib._decreasePoolAmount(\n                s,\n                _collateralToken,\n                VaultLib.usdToTokenMin(s, _collateralToken, _usdOut)\n            );\n            uint256 _amountOutAfterFees = VaultLib.usdToTokenMin(\n                s,\n                _collateralToken,\n                _usdOutAfterFee\n            );\n            VaultLib.transferOut(\n                s,\n                _collateralToken,\n                _amountOutAfterFees,\n                _receiver\n            );\n\n            return _amountOutAfterFees;\n        } else {\n            return 0;\n        }\n    }\n\n    function _increaseNUSDAmount(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _amount\n    ) internal {\n        s.nusdAmounts[_token] = s.nusdAmounts[_token].add(_amount);\n\n        emit IncreaseNUSDAmount(_token, _amount);\n    }\n\n    function _decreaseNUSDAmount(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _amount\n    ) internal {\n        uint256 _value = s.nusdAmounts[_token];\n        // since NUSD can be minted using multiple assets\n        // it is possible for the NUSD debt for a single asset to be less than zero\n        // the NUSD debt is capped to zero for this case\n        if (_value <= _amount) {\n            s.nusdAmounts[_token] = 0;\n            emit DecreaseNUSDAmount(_token, _value);\n            return;\n        }\n        s.nusdAmounts[_token] = _value.sub(_amount);\n\n        emit DecreaseNUSDAmount(_token, _amount);\n    }\n\n    function _reduceCollateral(\n        LibAppStorage.Storage storage s,\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong\n    ) internal returns (uint256, uint256) {\n        LibAppStorage.Position storage position = s.positions[\n            getPositionKey(_account, _collateralToken, _indexToken, _isLong)\n        ];\n\n        uint256 fee = _collectMarginFees(\n            s,\n            _collateralToken,\n            _sizeDelta,\n            position.size,\n            position.entryFundingRate\n        );\n        bool hasProfit;\n        uint256 adjustedDelta;\n\n        // scope variables to avoid stack too deep errors\n        {\n            (bool _hasProfit, uint256 delta) = _getDelta(\n                s,\n                _indexToken,\n                position.size,\n                position.averagePrice,\n                _isLong,\n                position.lastIncreasedTime\n            );\n            hasProfit = _hasProfit;\n            // get the proportional change in pnl\n            adjustedDelta = _sizeDelta.mul(delta).div(position.size);\n        }\n\n        uint256 usdOut;\n        // transfer profits out\n        {\n            if (hasProfit && adjustedDelta > 0) {\n                usdOut = adjustedDelta;\n                position.realisedPnl =\n                    position.realisedPnl +\n                    int256(adjustedDelta);\n            }\n\n            if (!hasProfit && adjustedDelta > 0) {\n                position.collateral = position.collateral.sub(adjustedDelta);\n                position.realisedPnl =\n                    position.realisedPnl -\n                    int256(adjustedDelta);\n            }\n\n            // reduce the position's collateral by _collateralDelta\n            // transfer _collateralDelta out\n            if (_collateralDelta > 0) {\n                usdOut = usdOut.add(_collateralDelta);\n                position.collateral = position.collateral.sub(_collateralDelta);\n            }\n\n            // if the position will be closed, then transfer the remaining collateral out\n            if (position.size == _sizeDelta) {\n                usdOut = usdOut.add(position.collateral);\n                position.collateral = 0;\n            }\n\n            // if the usdOut is more than the fee then deduct the fee from the usdOut directly\n            // else deduct the fee from the position's collateral\n            if (usdOut < fee) {\n                position.collateral = position.collateral.sub(fee);\n                uint256 feeTokens = VaultLib.usdToTokenMin(\n                    s,\n                    _collateralToken,\n                    fee\n                );\n                VaultLib._decreasePoolAmount(s, _collateralToken, feeTokens);\n            }\n        }\n\n        emit UpdatePnl(\n            getPositionKey(_account, _collateralToken, _indexToken, _isLong),\n            hasProfit,\n            adjustedDelta\n        );\n\n        return (usdOut, usdOut > fee ? usdOut.sub(fee) : usdOut);\n    }\n\n    function _collectMarginFees(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _sizeDelta,\n        uint256 _size,\n        uint256 _entryFundingRate\n    ) internal returns (uint256) {\n        uint256 feeUsd = _getPositionFee(_sizeDelta);\n\n        uint256 fundingFee = _getFundingFee(\n            s,\n            _token,\n            _size,\n            _entryFundingRate\n        );\n        feeUsd = feeUsd.add(fundingFee);\n\n        uint256 feeTokens = VaultLib.usdToTokenMin(s, _token, feeUsd);\n        s.feeReserves[_token] = s.feeReserves[_token].add(feeTokens);\n\n        emit CollectMarginFees(_token, feeUsd, feeTokens);\n        return feeUsd;\n    }\n\n    function _increaseReservedAmount(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _amount\n    ) internal {\n        s.reservedAmounts[_token] = s.reservedAmounts[_token].add(_amount);\n        require(\n            s.reservedAmounts[_token] <= s.poolAmounts[_token],\n            \"Vault: reserve exceeds pool\"\n        );\n\n        emit IncreaseReservedAmount(_token, _amount);\n    }\n\n    function _decreaseReservedAmount(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _amount\n    ) internal {\n        s.reservedAmounts[_token] = s.reservedAmounts[_token].sub(\n            _amount,\n            \"Vault: insufficient reserve\"\n        );\n\n        emit DecreaseReservedAmount(_token, _amount);\n    }\n\n    function _increaseGuaranteedUsd(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _usdAmount\n    ) internal {\n        s.guaranteedUsd[_token] = s.guaranteedUsd[_token].add(_usdAmount);\n\n        emit IncreaseGuaranteedUsd(_token, _usdAmount);\n    }\n\n    function _decreaseGuaranteedUsd(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _usdAmount\n    ) internal {\n        s.guaranteedUsd[_token] = s.guaranteedUsd[_token].sub(_usdAmount);\n\n        emit DecreaseGuaranteedUsd(_token, _usdAmount);\n    }\n\n    function _getDelta(\n        LibAppStorage.Storage storage s,\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _lastIncreasedTime\n    ) internal view returns (bool, uint256) {\n        require(_averagePrice > 0, \"Vault: invalid _averagePrice\");\n        uint256 price = _isLong\n            ? VaultLib.getMinPrice(_indexToken, s.includeAmmPrice)\n            : VaultLib.getMaxPrice(_indexToken, s.includeAmmPrice);\n        uint256 priceDelta = _averagePrice > price\n            ? _averagePrice.sub(price)\n            : price.sub(_averagePrice);\n        uint256 delta = _size.mul(priceDelta).div(_averagePrice);\n\n        bool hasProfit;\n\n        if (_isLong) {\n            hasProfit = price > _averagePrice;\n        } else {\n            hasProfit = _averagePrice > price;\n        }\n\n        // if the minProfitTime has passed then there will be no min profit threshold\n        // the min profit threshold helps to prevent front-running issues\n        uint256 minBps = block.timestamp >\n            _lastIncreasedTime.add(MIN_PROFIT_TIME)\n            ? 0\n            : s.minProfitBasisPoints[_indexToken];\n        if (hasProfit && delta.mul(BASIS_POINTS_DIVISOR) <= _size.mul(minBps)) {\n            delta = 0;\n        }\n\n        return (hasProfit, delta);\n    }\n\n    function _getFundingFee(\n        LibAppStorage.Storage storage s,\n        address _token,\n        uint256 _size,\n        uint256 _entryFundingRate\n    ) internal view returns (uint256) {\n        if (_size == 0) {\n            return 0;\n        }\n\n        uint256 fundingRate = s.cumulativeFundingRates[_token].sub(\n            _entryFundingRate\n        );\n        if (fundingRate == 0) {\n            return 0;\n        }\n\n        return _size.mul(fundingRate).div(FUNDING_RATE_PRECISION);\n    }\n\n    function _getPositionFee(uint256 _sizeDelta)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_sizeDelta == 0) {\n            return 0;\n        }\n        uint256 afterFeeUsd = _sizeDelta\n            .mul(BASIS_POINTS_DIVISOR.sub(MARGIN_FEE_BASIS_POINTS))\n            .div(BASIS_POINTS_DIVISOR);\n        return _sizeDelta.sub(afterFeeUsd);\n    }\n}\n"
    },
    "contracts/lib/Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"./LibAppStorage.sol\";\nimport \"./LibDiamond.sol\";\n\ncontract Facet {\n    LibAppStorage.Storage internal s;\n\n    constructor() {\n        s.contractEntered = false;\n    }\n\n    function onlyGov() internal view {\n        LibDiamond.enforceIsContractOwner();\n    }\n\n    function contractEntered() internal {\n        require(!s.contractEntered);\n        s.contractEntered = true;\n    }\n\n    function contractExited() internal {\n        s.contractEntered = false;\n    }\n}\n"
    },
    "contracts/lib/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\n// import \"hardhat/console.sol\";\nuint256 constant _NOT_ENTERED = 1;\nuint256 constant _ENTERED = 2;\n\nuint256 constant BASIS_POINTS_DIVISOR = 10000;\nuint256 constant FUNDING_RATE_PRECISION = 1000000;\nuint256 constant PRICE_PRECISION = 10**30;\nuint256 constant NUSD_DECIMALS = 18;\nuint256 constant MAX_FEE_BASIS_POINTS = 500; // 5%\nuint256 constant MAX_LIQUIDATION_FEE_USD = 100 * PRICE_PRECISION; // 100 USD\nuint256 constant MIN_FUNDING_RATE_INTERVAL = 1 hours;\nuint256 constant MAX_FUNDING_RATE_FACTOR = 10000; // 1%\nuint256 constant MAX_LEVERAGE = 50 * 10000; // 50x\n\nuint256 constant LIQUIDATION_FEE_USD = 10;\nuint256 constant SWAP_FEE_BASIS_POINTS = 30; // 0.3%\nuint256 constant MARGIN_FEE_BASIS_POINTS = 10; // 0.1%\nuint256 constant MIN_PROFIT_TIME = 60 * 15; // 15 minutes\n\nuint256 constant FUNDING_INTERVAL = 8 hours;\nuint256 constant FUNDING_RATE_FACTOR = 600; // out of 1000\n\nuint256 constant MAX_STRICT_PRICE_DEVIATION = 0;\nuint256 constant SPREAD_THRESHOLD_BASIS_POINTS = 30;\nuint256 constant SECONDARY_PRICE_PRECISION = 10**18;\nuint256 constant ONE_USD = PRICE_PRECISION;\nuint256 constant MAX_SPREAD_BASIS_POINTS = 50;\nuint256 constant POSITION_PROPS_LENGTH = 9;\n\nlibrary LibAppStorage {\n    bytes32 constant STORAGE_POSITION = keccak256(\"necc.dao.based.storage\");\n\n    struct Position {\n        uint256 size;\n        uint256 collateral;\n        uint256 averagePrice;\n        uint256 entryFundingRate;\n        uint256 reserveAmount;\n        int256 realisedPnl;\n        uint256 lastIncreasedTime;\n    }\n\n    // Single global store\n    struct Storage {\n        bool contractEntered;\n        address router;\n        address priceFeed;\n        address btc;\n        address weth;\n        address nusd;\n        bool includeAmmPrice;\n        bool isInitialized;\n        mapping(address => bool) whitelistedTokens;\n        mapping(bytes32 => Position) positions;\n        mapping(address => uint256) tokenDecimals;\n        mapping(address => uint256) redemptionBasisPoints;\n        mapping(address => uint256) minProfitBasisPoints;\n        mapping(address => uint256) tokenBalances;\n        mapping(address => uint256) nusdAmounts;\n        mapping(address => uint256) poolAmounts;\n        mapping(address => uint256) reservedAmounts;\n        mapping(address => uint256) guaranteedUsd;\n        mapping(address => uint256) cumulativeFundingRates;\n        mapping(address => uint256) lastFundingTimes;\n        mapping(address => uint256) feeReserves;\n        // Router\n        mapping(address => bool) plugins;\n        // PriceFeed\n        mapping(address => address) priceFeeds;\n        mapping(address => uint256) priceDecimals;\n        mapping(address => uint256) spreadBasisPoints;\n        uint256 priceSampleSpace;\n        //\n        int256 answer;\n        uint80 roundId;\n        mapping(uint80 => int256) answers;\n        // Always add new storage variable to the end of this struct\n    }\n}\n"
    },
    "contracts/facets/VaultPriceFeed/VaultPriceFeedFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../../lib/Facet.sol\";\n\n// import \"../../amm/interfaces/IUniswapV2Pair.sol\";\ncontract VaultPriceFeedFacet is Facet {\n    using SafeMath for uint256;\n\n    function getPrimaryPrice(address _token, bool _maximise)\n        public\n        view\n        returns (uint256)\n    {\n        address priceFeedAddress = s.priceFeeds[_token];\n        require(\n            priceFeedAddress != address(0),\n            \"PriceFeed: invalid price feed\"\n        );\n        IPriceFeed priceFeed = IPriceFeed(priceFeedAddress);\n\n        uint256 price = 0;\n        uint80 roundId = priceFeed.latestRound();\n\n        for (uint80 i = 0; i < s.priceSampleSpace; i++) {\n            if (roundId <= i) {\n                break;\n            }\n            uint256 p;\n\n            if (i == 0) {\n                int256 _p = priceFeed.latestAnswer();\n                require(_p > 0, \"PriceFeed: invalid price\");\n                p = uint256(_p);\n            } else {\n                (, int256 _p, , , ) = priceFeed.getRoundData(roundId - i);\n                require(_p > 0, \"PriceFeed: invalid price\");\n                p = uint256(_p);\n            }\n\n            if (price == 0) {\n                price = p;\n                continue;\n            }\n\n            if (_maximise && p > price) {\n                price = p;\n                continue;\n            }\n\n            if (!_maximise && p < price) {\n                price = p;\n            }\n        }\n\n        require(price > 0, \"PriceFeed: could not fetch price\");\n        // normalise price precision\n        uint256 _priceDecimals = s.priceDecimals[_token];\n        return price.mul(PRICE_PRECISION).div(10**_priceDecimals);\n    }\n\n    function getPrice(\n        address _token,\n        bool _maximise,\n        bool\n    ) public view returns (uint256) {\n        uint256 price = getPrimaryPrice(_token, _maximise);\n        uint256 _spreadBasisPoints = s.spreadBasisPoints[_token];\n\n        if (_maximise) {\n            return\n                price.mul(BASIS_POINTS_DIVISOR.add(_spreadBasisPoints)).div(\n                    BASIS_POINTS_DIVISOR\n                );\n        }\n\n        return\n            price.mul(BASIS_POINTS_DIVISOR.sub(_spreadBasisPoints)).div(\n                BASIS_POINTS_DIVISOR\n            );\n    }\n}\n"
    },
    "contracts/facets/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IPriceFeed {\n    function description() external view returns (string memory);\n\n    function aggregator() external view returns (address);\n\n    function latestAnswer() external view returns (int256);\n\n    function latestRound() external view returns (uint80);\n\n    function getRoundData(uint80 roundId)\n        external\n        view\n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        );\n}\n"
    },
    "contracts/facets/VaultPriceFeed/PriceFeedFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"../../lib/Facet.sol\";\n\ncontract PriceFeedFacet is Facet {\n    function latestAnswer() public view returns (int256) {\n        return s.answer;\n    }\n\n    function latestRound() public view returns (uint80) {\n        return s.roundId;\n    }\n\n    function setLatestAnswer(int256 _answer) public {\n        onlyGov();\n        s.roundId = s.roundId + 1;\n        s.answer = _answer;\n        s.answers[s.roundId] = _answer;\n    }\n\n    // returns roundId, answer, startedAt, updatedAt, answeredInRound\n    function getRoundData(uint80 _roundId)\n        public\n        view\n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        )\n    {\n        return (_roundId, s.answers[_roundId], 0, 0, 0);\n    }\n}\n"
    },
    "contracts/facets/Vault/VaultNUSDFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../tokens/interfaces/INUSD.sol\";\nimport \"../../lib/Facet.sol\";\nimport \"./VaultLib.sol\";\n\ncontract VaultNUSDFacet is Facet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event BuyNUSD(\n        address account,\n        address token,\n        uint256 tokenAmount,\n        uint256 nusdAmount\n    );\n    event SellNUSD(\n        address account,\n        address token,\n        uint256 nusdAmount,\n        uint256 tokenAmount\n    );\n    event Swap(\n        address account,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    function buyNUSD(address _token, address _receiver)\n        external\n        returns (uint256)\n    {\n        contractEntered();\n        require(s.isInitialized, \"Vault: not initialized\");\n        VaultLib.isTokenWhitelisted(s, _token);\n\n        uint256 _tokenAmount = VaultLib.transferIn(s, _token);\n        require(_tokenAmount > 0, \"Vault: invalid tokenAmount\");\n\n        VaultLib.updateCumulativeFundingRate(s, _token);\n\n        uint256 _price = VaultLib.getMinPrice(_token, s.includeAmmPrice);\n\n        (, uint256 _amountAfterFees) = VaultLib._collectSwapFees(\n            s,\n            _token,\n            _tokenAmount\n        );\n\n        uint256 _nusdAmount = _amountAfterFees.mul(_price).div(PRICE_PRECISION);\n        _nusdAmount = VaultLib.adjustForDecimals(\n            s,\n            _nusdAmount,\n            _token,\n            s.nusd\n        );\n\n        require(_nusdAmount > 0, \"Vault: invalid nusdAmount\");\n\n        VaultLib._increaseNUSDAmount(s, _token, _nusdAmount);\n        VaultLib._increasePoolAmount(s, _token, _amountAfterFees);\n\n        INUSD(s.nusd).mint(_receiver, _nusdAmount);\n\n        emit BuyNUSD(_receiver, _token, _tokenAmount, _nusdAmount);\n\n        contractExited();\n        return _nusdAmount;\n    }\n\n    function getRedemptionCollateral(address _token)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 _collateral = VaultLib.usdToTokenMin(\n            s,\n            _token,\n            s.guaranteedUsd[_token]\n        );\n        return\n            _collateral.add(s.poolAmounts[_token]).sub(\n                s.reservedAmounts[_token]\n            );\n    }\n\n    function getRedemptionCollateralUsd(address _token)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            VaultLib.tokenToUsdMin(s, _token, getRedemptionCollateral(_token));\n    }\n\n    function availableReserve(address _token) public view returns (uint256) {\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        return _balance.sub(s.reservedAmounts[_token]);\n    }\n\n    function getRedemptionAmount(address _token, uint256 _nusdAmount)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 _price = VaultLib.getMaxPrice(_token, s.includeAmmPrice);\n        uint256 _priceBasedAmount = _nusdAmount.mul(PRICE_PRECISION).div(\n            _price\n        );\n\n        _priceBasedAmount = VaultLib.adjustForDecimals(\n            s,\n            _priceBasedAmount,\n            s.nusd,\n            _token\n        );\n\n        uint256 _redemptionCollateral = getRedemptionCollateral(_token);\n        if (_redemptionCollateral == 0) {\n            return 0;\n        }\n\n        uint256 _totalNUSDAmount = s.nusdAmounts[_token];\n\n        // if there is no NUSD debt then the redemption amount based just on price can be supported\n        if (_totalNUSDAmount == 0) {\n            return _priceBasedAmount;\n        }\n\n        // calculate the collateralBasedAmount from the amount of backing collateral and the\n        // total debt in NUSD tokens for the asset\n        uint256 _collateralBasedAmount = _nusdAmount\n            .mul(_redemptionCollateral)\n            .div(_totalNUSDAmount);\n        uint256 basisPoints = getRedemptionBasisPoints(_token);\n        _collateralBasedAmount = _collateralBasedAmount.mul(basisPoints).div(\n            BASIS_POINTS_DIVISOR\n        );\n\n        return\n            _collateralBasedAmount < _priceBasedAmount\n                ? _collateralBasedAmount\n                : _priceBasedAmount;\n    }\n\n    function sellNUSD(address _token, address _receiver)\n        external\n        returns (uint256)\n    {\n        contractEntered();\n        VaultLib.isTokenWhitelisted(s, _token);\n\n        uint256 _nusdAmount = VaultLib.transferIn(s, s.nusd);\n        require(_nusdAmount > 0, \"Vault: invalid nusdAmount\");\n\n        VaultLib.updateCumulativeFundingRate(s, _token);\n\n        uint256 _redemptionAmount = getRedemptionAmount(_token, _nusdAmount);\n        require(_redemptionAmount > 0, \"Vault: invalid redemptionAmount\");\n\n        VaultLib._decreaseNUSDAmount(s, _token, _nusdAmount);\n        VaultLib._decreasePoolAmount(s, _token, _redemptionAmount);\n\n        INUSD(s.nusd).burn(address(this), _nusdAmount);\n\n        // the _transferIn call increased the value of tokenBalances[nusd]\n        // usually decreases in token balances are synced by calling _transferOut\n        // however, for nusd, the tokens are burnt, so updateTokenBalance should\n        // be manually called to record the decrease in tokens\n        VaultLib.updateTokenBalance(s, s.nusd);\n\n        (, uint256 _tokenAmount) = VaultLib._collectSwapFees(\n            s,\n            _token,\n            _redemptionAmount\n        );\n        require(_tokenAmount > 0, \"Vault: invalid tokenAmount\");\n\n        VaultLib.transferOut(s, _token, _tokenAmount, _receiver);\n\n        emit SellNUSD(_receiver, _token, _nusdAmount, _tokenAmount);\n\n        contractExited();\n        return _tokenAmount;\n    }\n\n    function swap(\n        address _tokenIn,\n        address _tokenOut,\n        address _receiver\n    ) external returns (uint256) {\n        contractEntered();\n        require(s.isInitialized, \"Vault: not initialized\");\n        require(_tokenIn != _tokenOut, \"Vault: invalid tokens\");\n        VaultLib.isTokenWhitelisted(s, _tokenIn);\n        VaultLib.isTokenWhitelisted(s, _tokenOut);\n\n        VaultLib.updateCumulativeFundingRate(s, _tokenIn);\n        VaultLib.updateCumulativeFundingRate(s, _tokenOut);\n\n        uint256 amountIn = VaultLib.transferIn(s, _tokenIn);\n        require(amountIn > 0, \"Vault: invalid amountIn\");\n\n        uint256 priceIn = VaultLib.getMinPrice(_tokenIn, s.includeAmmPrice);\n        uint256 priceOut = VaultLib.getMaxPrice(_tokenOut, s.includeAmmPrice);\n\n        uint256 amountOut = amountIn.mul(priceIn).div(priceOut);\n        amountOut = VaultLib.adjustForDecimals(\n            s,\n            amountOut,\n            _tokenIn,\n            _tokenOut\n        );\n        (, uint256 amountOutAfterFees) = VaultLib._collectSwapFees(\n            s,\n            _tokenOut,\n            amountOut\n        );\n\n        // adjust nusdAmounts by the same nusdAmount as debt is shifted between the assets\n        uint256 nusdAmount = amountIn.mul(priceIn).div(PRICE_PRECISION);\n        nusdAmount = VaultLib.adjustForDecimals(\n            s,\n            nusdAmount,\n            _tokenIn,\n            s.nusd\n        );\n\n        VaultLib._increaseNUSDAmount(s, _tokenIn, nusdAmount);\n        VaultLib._decreaseNUSDAmount(s, _tokenOut, nusdAmount);\n\n        VaultLib._increasePoolAmount(s, _tokenIn, amountIn);\n        VaultLib._decreasePoolAmount(s, _tokenOut, amountOut);\n\n        VaultLib.transferOut(s, _tokenOut, amountOutAfterFees, _receiver);\n\n        emit Swap(_receiver, _tokenIn, _tokenOut, amountIn, amountOutAfterFees);\n\n        contractExited();\n        return amountOutAfterFees;\n    }\n\n    function getRedemptionBasisPoints(address _token)\n        public\n        view\n        returns (uint256)\n    {\n        return s.redemptionBasisPoints[_token];\n    }\n\n    function poolAmounts(address _token) public view returns (uint256) {\n        return s.poolAmounts[_token];\n    }\n\n    function reservedAmounts(address _token) public view returns (uint256) {\n        return s.reservedAmounts[_token];\n    }\n\n    function nusdAmounts(address _token) public view returns (uint256) {\n        return s.nusdAmounts[_token];\n    }\n}\n"
    },
    "contracts/tokens/interfaces/INUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface INUSD {\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/facets/Vault/VaultFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"../../lib/Facet.sol\";\nimport \"./VaultLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract VaultFacet is Facet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event IncreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event DecreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event LiquidatePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        bool isLong,\n        uint256 size,\n        uint256 collateral,\n        uint256 reserveAmount,\n        int256 realisedPnl,\n        uint256 markPrice\n    );\n    event UpdatePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n    event ClosePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n\n    // once the parameters are verified to be working correctly,\n    // gov should be set to a timelock contract or a governance contract\n\n    function increasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _sizeDelta,\n        bool _isLong\n    ) external {\n        contractEntered();\n        VaultLib.validateTokens(s, _collateralToken, _indexToken);\n        VaultLib.updateCumulativeFundingRate(s, _collateralToken);\n\n        bytes32 key = VaultLib.getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        LibAppStorage.Position storage position = s.positions[key];\n\n        uint256 price = _isLong\n            ? VaultLib.getMaxPrice(_indexToken, s.includeAmmPrice)\n            : VaultLib.getMinPrice(_indexToken, s.includeAmmPrice);\n\n        if (position.size == 0) {\n            position.averagePrice = price;\n        }\n\n        if (position.size > 0 && _sizeDelta > 0) {\n            position.averagePrice = getNextAveragePrice(\n                _indexToken,\n                position.size,\n                position.averagePrice,\n                _isLong,\n                price,\n                _sizeDelta,\n                position.lastIncreasedTime\n            );\n        }\n\n        uint256 fee = VaultLib._collectMarginFees(\n            s,\n            _collateralToken,\n            _sizeDelta,\n            position.size,\n            position.entryFundingRate\n        );\n        uint256 collateralDelta = VaultLib.transferIn(s, _collateralToken);\n        uint256 collateralDeltaUsd = VaultLib.tokenToUsdMin(\n            s,\n            _collateralToken,\n            collateralDelta\n        );\n\n        position.collateral = position.collateral.add(collateralDeltaUsd);\n        require(\n            position.collateral >= fee,\n            \"Vault: insufficient collateral for fees\"\n        );\n\n        position.collateral = position.collateral.sub(fee);\n        position.entryFundingRate = s.cumulativeFundingRates[_collateralToken];\n        position.size = position.size.add(_sizeDelta);\n        position.lastIncreasedTime = block.timestamp;\n\n        require(position.size > 0, \"Vault: invalid position.size\");\n        VaultLib.validatePosition(position.size, position.collateral);\n        validateLiquidation(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong,\n            true\n        );\n\n        // reserve tokens to pay profits on the position\n        uint256 reserveDelta = VaultLib.usdToTokenMax(\n            s,\n            _collateralToken,\n            _sizeDelta,\n            s.includeAmmPrice\n        );\n        position.reserveAmount = position.reserveAmount.add(reserveDelta);\n        VaultLib._increaseReservedAmount(s, _collateralToken, reserveDelta);\n\n        // guaranteedUsd stores the sum of (position.size - position.collateral) for all positions\n        // if a fee is charged on the collateral then guaranteedUsd should be increased by that fee amount\n        // since (position.size - position.collateral) would have increased by `fee`\n        VaultLib._increaseGuaranteedUsd(\n            s,\n            _collateralToken,\n            _sizeDelta.add(fee)\n        );\n        VaultLib._decreaseGuaranteedUsd(\n            s,\n            _collateralToken,\n            collateralDeltaUsd\n        );\n        // treat the deposited collateral as part of the pool\n        VaultLib._increasePoolAmount(s, _collateralToken, collateralDelta);\n        // fees need to be deducted from the pool since fees are deducted from position.collateral\n        // and collateral is treated as part of the pool\n        VaultLib._decreasePoolAmount(\n            s,\n            _collateralToken,\n            VaultLib.usdToTokenMin(s, _collateralToken, fee)\n        );\n\n        emit IncreasePosition(\n            key,\n            _account,\n            _collateralToken,\n            _indexToken,\n            collateralDeltaUsd,\n            _sizeDelta,\n            _isLong,\n            price,\n            fee\n        );\n        emit UpdatePosition(\n            key,\n            position.size,\n            position.collateral,\n            position.averagePrice,\n            position.entryFundingRate,\n            position.reserveAmount,\n            position.realisedPnl\n        );\n\n        contractExited();\n    }\n\n    function decreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) external returns (uint256) {\n        contractEntered();\n        VaultLib.validateTokens(s, _collateralToken, _indexToken);\n\n        contractExited();\n        return\n            _decreasePosition(\n                _account,\n                _collateralToken,\n                _indexToken,\n                _collateralDelta,\n                _sizeDelta,\n                _isLong,\n                _receiver\n            );\n    }\n\n    function _decreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) private returns (uint256) {\n        VaultLib.updateCumulativeFundingRate(s, _collateralToken);\n\n        bytes32 key = VaultLib.getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        LibAppStorage.Position storage position = s.positions[key];\n        require(position.size > 0, \"Vault: empty position\");\n        require(position.size >= _sizeDelta, \"Vault: position size exceeded\");\n        require(\n            position.collateral >= _collateralDelta,\n            \"Vault: position collateral exceeded\"\n        );\n\n        uint256 collateral = position.collateral;\n        // scope variables to avoid stack too deep errors\n        {\n            uint256 reserveDelta = position.reserveAmount.mul(_sizeDelta).div(\n                position.size\n            );\n            position.reserveAmount = position.reserveAmount.sub(reserveDelta);\n            VaultLib._decreaseReservedAmount(s, _collateralToken, reserveDelta);\n        }\n\n        (uint256 _usdOut, uint256 _usdOutAfterFee) = VaultLib._reduceCollateral(\n            s,\n            _account,\n            _collateralToken,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong\n        );\n\n        if (position.size != _sizeDelta) {\n            position.entryFundingRate = s.cumulativeFundingRates[\n                _collateralToken\n            ];\n            position.size = position.size.sub(_sizeDelta);\n\n            VaultLib.validatePosition(position.size, position.collateral);\n            validateLiquidation(\n                _account,\n                _collateralToken,\n                _indexToken,\n                _isLong,\n                true\n            );\n\n            VaultLib._increaseGuaranteedUsd(\n                s,\n                _collateralToken,\n                collateral.sub(position.collateral)\n            );\n            VaultLib._decreaseGuaranteedUsd(s, _collateralToken, _sizeDelta);\n\n            uint256 price = _isLong\n                ? VaultLib.getMinPrice(_indexToken, s.includeAmmPrice)\n                : VaultLib.getMaxPrice(_indexToken, s.includeAmmPrice);\n            emit DecreasePosition(\n                key,\n                _account,\n                _collateralToken,\n                _indexToken,\n                _collateralDelta,\n                _sizeDelta,\n                _isLong,\n                price,\n                _usdOut.sub(_usdOutAfterFee)\n            );\n            emit UpdatePosition(\n                key,\n                position.size,\n                position.collateral,\n                position.averagePrice,\n                position.entryFundingRate,\n                position.reserveAmount,\n                position.realisedPnl\n            );\n        } else {\n            VaultLib._increaseGuaranteedUsd(s, _collateralToken, collateral);\n            VaultLib._decreaseGuaranteedUsd(s, _collateralToken, _sizeDelta);\n\n            uint256 price = _isLong\n                ? VaultLib.getMinPrice(_indexToken, s.includeAmmPrice)\n                : VaultLib.getMaxPrice(_indexToken, s.includeAmmPrice);\n            emit DecreasePosition(\n                key,\n                _account,\n                _collateralToken,\n                _indexToken,\n                _collateralDelta,\n                _sizeDelta,\n                _isLong,\n                price,\n                _usdOut.sub(_usdOutAfterFee)\n            );\n            emit ClosePosition(\n                key,\n                position.size,\n                position.collateral,\n                position.averagePrice,\n                position.entryFundingRate,\n                position.reserveAmount,\n                position.realisedPnl\n            );\n\n            delete s.positions[key];\n        }\n\n        return\n            VaultLib._transferRemainingCollateral(\n                s,\n                _collateralToken,\n                _receiver,\n                _usdOut,\n                _usdOutAfterFee\n            );\n    }\n\n    function liquidatePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        address _feeReceiver\n    ) external {\n        contractEntered();\n        // set INCLUDE_AMM_PRICE to false prevent manipulated liquidations\n        s.includeAmmPrice = false;\n\n        VaultLib.validateTokens(s, _collateralToken, _indexToken);\n        VaultLib.updateCumulativeFundingRate(s, _collateralToken);\n\n        bytes32 key = VaultLib.getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        LibAppStorage.Position memory position = s.positions[key];\n        require(position.size > 0, \"Vault: empty position\");\n\n        (uint256 liquidationState, uint256 marginFees) = validateLiquidation(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong,\n            false\n        );\n        require(liquidationState != 0, \"Vault: position cannot be liquidated\");\n        // max leverage exceeded but there is collateral remaining after deducting losses\n        // so decreasePosition instead by a half to keep alive\n        if (liquidationState == 2) {\n            _decreasePosition(\n                _account,\n                _collateralToken,\n                _indexToken,\n                0,\n                position.size.mul(5).div(10), // div by 2\n                _isLong,\n                _account\n            );\n            return;\n        }\n\n        s.feeReserves[_collateralToken] = s.feeReserves[_collateralToken].add(\n            VaultLib.usdToTokenMin(s, _collateralToken, marginFees)\n        );\n\n        VaultLib._decreaseReservedAmount(\n            s,\n            _collateralToken,\n            position.reserveAmount\n        );\n        VaultLib._decreaseGuaranteedUsd(\n            s,\n            _collateralToken,\n            position.size.sub(position.collateral)\n        );\n\n        uint256 markPrice = _isLong\n            ? VaultLib.getMinPrice(_indexToken, s.includeAmmPrice)\n            : VaultLib.getMaxPrice(_indexToken, s.includeAmmPrice);\n\n        emit LiquidatePosition(\n            key,\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong,\n            position.size,\n            position.collateral,\n            position.reserveAmount,\n            position.realisedPnl,\n            markPrice\n        );\n\n        delete s.positions[key];\n\n        // pay the fee receiver using the pool, we assume that in general the liquidated amount should be sufficient to cover\n        // the liquidation fees\n        VaultLib._decreasePoolAmount(\n            s,\n            _collateralToken,\n            VaultLib.usdToTokenMin(s, _collateralToken, LIQUIDATION_FEE_USD)\n        );\n        VaultLib.transferOut(\n            s,\n            _collateralToken,\n            VaultLib.usdToTokenMin(s, _collateralToken, LIQUIDATION_FEE_USD),\n            _feeReceiver\n        );\n\n        s.includeAmmPrice = true;\n        contractExited();\n    }\n\n    function validateLiquidation(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        bool _raise\n    )\n        public\n        view\n        returns (\n            // returns (state, fees)\n            uint256,\n            uint256\n        )\n    {\n        bytes32 key = VaultLib.getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        LibAppStorage.Position memory position = s.positions[key];\n\n        (bool hasProfit, uint256 delta) = getDelta(\n            _indexToken,\n            position.size,\n            position.averagePrice,\n            _isLong,\n            position.lastIncreasedTime\n        );\n        uint256 marginFees = getFundingFee(\n            _collateralToken,\n            position.size,\n            position.entryFundingRate\n        );\n        marginFees = marginFees.add(getPositionFee(position.size));\n\n        if (!hasProfit && position.collateral < delta) {\n            if (_raise) {\n                revert(\"Vault: losses exceed collateral\");\n            }\n            return (1, marginFees);\n        }\n\n        uint256 remainingCollateral = position.collateral;\n        if (!hasProfit) {\n            remainingCollateral = position.collateral.sub(delta);\n        }\n\n        if (remainingCollateral < marginFees) {\n            if (_raise) {\n                revert(\"Vault: fees exceed collateral\");\n            }\n            // cap the fees to the remainingCollateral\n            return (1, remainingCollateral);\n        }\n\n        if (remainingCollateral < marginFees.add(LIQUIDATION_FEE_USD)) {\n            if (_raise) {\n                revert(\"Vault: liquidation fees exceed collateral\");\n            }\n            return (1, marginFees);\n        }\n\n        if (\n            remainingCollateral.mul(MAX_LEVERAGE) <\n            position.size.mul(BASIS_POINTS_DIVISOR)\n        ) {\n            if (_raise) {\n                revert(\"Vault: maxLeverage exceeded\");\n            }\n            return (2, marginFees);\n        }\n\n        return (0, marginFees);\n    }\n\n    function getPosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256\n        )\n    {\n        bytes32 key = VaultLib.getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        LibAppStorage.Position memory position = s.positions[key];\n        uint256 realisedPnl = position.realisedPnl > 0\n            ? uint256(position.realisedPnl)\n            : uint256(-position.realisedPnl);\n        return (\n            position.size, // 0\n            position.collateral, // 1\n            position.averagePrice, // 2\n            position.entryFundingRate, // 3\n            position.reserveAmount, // 4\n            realisedPnl, // 5\n            position.realisedPnl >= 0, // 6\n            position.lastIncreasedTime // 7\n        );\n    }\n\n    function getNextFundingRate(address _token) public view returns (uint256) {\n        return VaultLib._getNextFundingRate(s, _token);\n    }\n\n    function getUtilisation(address _token) public view returns (uint256) {\n        uint256 poolAmount = s.poolAmounts[_token];\n        if (poolAmount == 0) {\n            return 0;\n        }\n\n        return\n            s.reservedAmounts[_token].mul(FUNDING_RATE_PRECISION).div(\n                poolAmount\n            );\n    }\n\n    function getPositionLeverage(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) public view returns (uint256) {\n        bytes32 key = VaultLib.getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        LibAppStorage.Position memory position = s.positions[key];\n        require(position.collateral > 0, \"Vault: invalid position\");\n        return position.size.mul(BASIS_POINTS_DIVISOR).div(position.collateral);\n    }\n\n    // // for longs: nextAveragePrice = (nextPrice * nextSize)/ (nextSize + delta)\n    // // for shorts: nextAveragePrice = (nextPrice * nextSize) / (nextSize - delta)\n    function getNextAveragePrice(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _nextPrice,\n        uint256 _sizeDelta,\n        uint256 _lastIncreasedTime\n    ) public view returns (uint256) {\n        (bool hasProfit, uint256 delta) = getDelta(\n            _indexToken,\n            _size,\n            _averagePrice,\n            _isLong,\n            _lastIncreasedTime\n        );\n        uint256 nextSize = _size.add(_sizeDelta);\n        uint256 divisor;\n        if (_isLong) {\n            divisor = hasProfit ? nextSize.add(delta) : nextSize.sub(delta);\n        } else {\n            divisor = hasProfit ? nextSize.sub(delta) : nextSize.add(delta);\n        }\n        return _nextPrice.mul(nextSize).div(divisor);\n    }\n\n    function getPositionDelta(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) public view returns (bool, uint256) {\n        bytes32 key = VaultLib.getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        LibAppStorage.Position memory position = s.positions[key];\n        return\n            getDelta(\n                _indexToken,\n                position.size,\n                position.averagePrice,\n                _isLong,\n                position.lastIncreasedTime\n            );\n    }\n\n    function getDelta(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _lastIncreasedTime\n    ) public view returns (bool, uint256) {\n        return\n            VaultLib._getDelta(\n                s,\n                _indexToken,\n                _size,\n                _averagePrice,\n                _isLong,\n                _lastIncreasedTime\n            );\n    }\n\n    function getFundingFee(\n        address _token,\n        uint256 _size,\n        uint256 _entryFundingRate\n    ) public view returns (uint256) {\n        return VaultLib._getFundingFee(s, _token, _size, _entryFundingRate);\n    }\n\n    function getPositionFee(uint256 _sizeDelta) public pure returns (uint256) {\n        return VaultLib._getPositionFee(_sizeDelta);\n    }\n\n    function priceFeed() public view returns (address) {\n        return s.priceFeed;\n    }\n\n    function feeReserves(address _token) public view returns (uint256) {\n        return s.feeReserves[_token];\n    }\n}\n"
    },
    "contracts/tokens/Necc/Treasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ninterface IBondCalculator {\n    function valuation(address pair_, uint256 amount_)\n        external\n        view\n        returns (uint256 _value);\n}\n\ninterface IOwnable {\n    function manager() external view returns (address);\n\n    function renounceManagement() external;\n\n    function pushManagement(address newOwner_) external;\n\n    function pullManagement() external;\n}\n\ncontract Ownable is IOwnable {\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipPulled(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipPushed(address(0), _owner);\n    }\n\n    function manager() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyManager() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyManager {\n        emit OwnershipPushed(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function pushManagement(address newOwner_)\n        public\n        virtual\n        override\n        onlyManager\n    {\n        require(\n            newOwner_ != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipPushed(_owner, newOwner_);\n        _newOwner = newOwner_;\n    }\n\n    function pullManagement() public virtual override {\n        require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled(_owner, _newOwner);\n        _owner = _newOwner;\n    }\n}\n\ninterface IERC20Mintable {\n    function decimals() external view returns (uint256);\n\n    function mint(uint256 amount_) external;\n\n    function mint(address account_, uint256 ammount_) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n\ncontract Treasury is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed token, uint256 amount, uint256 value);\n    event Withdrawal(address indexed token, uint256 amount, uint256 value);\n    event CreateDebt(\n        address indexed debtor,\n        address indexed token,\n        uint256 amount,\n        uint256 value\n    );\n    event RepayDebt(\n        address indexed debtor,\n        address indexed token,\n        uint256 amount,\n        uint256 value\n    );\n    event ReservesManaged(address indexed token, uint256 amount);\n    event ReservesUpdated(uint256 indexed totalReserves);\n    event ReservesAudited(uint256 indexed totalReserves);\n    event RewardsMinted(\n        address indexed caller,\n        address indexed recipient,\n        uint256 amount\n    );\n    event ChangeQueued(MANAGING indexed managing, address queued);\n    event ChangeActivated(\n        MANAGING indexed managing,\n        address activated,\n        bool result\n    );\n\n    enum MANAGING {\n        RESERVEDEPOSITOR,\n        RESERVESPENDER,\n        RESERVETOKEN,\n        RESERVEMANAGER,\n        LIQUIDITYDEPOSITOR,\n        LIQUIDITYTOKEN,\n        LIQUIDITYMANAGER,\n        DEBTOR,\n        REWARDMANAGER,\n        nNecc\n    }\n\n    address public immutable Necc;\n    uint256 public immutable blocksNeededForQueue;\n\n    address[] public reserveTokens; // Push only, beware false-positives.\n    mapping(address => bool) public isReserveToken;\n    mapping(address => uint256) public reserveTokenQueue; // Delays changes to mapping.\n\n    address[] public reserveDepositors; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isReserveDepositor;\n    mapping(address => uint256) public reserveDepositorQueue; // Delays changes to mapping.\n\n    address[] public reserveSpenders; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isReserveSpender;\n    mapping(address => uint256) public reserveSpenderQueue; // Delays changes to mapping.\n\n    address[] public liquidityTokens; // Push only, beware false-positives.\n    mapping(address => bool) public isLiquidityToken;\n    mapping(address => uint256) public LiquidityTokenQueue; // Delays changes to mapping.\n\n    address[] public liquidityDepositors; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isLiquidityDepositor;\n    mapping(address => uint256) public LiquidityDepositorQueue; // Delays changes to mapping.\n\n    mapping(address => address) public bondCalculator; // bond calculator for liquidity token\n\n    address[] public reserveManagers; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isReserveManager;\n    mapping(address => uint256) public ReserveManagerQueue; // Delays changes to mapping.\n\n    address[] public liquidityManagers; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isLiquidityManager;\n    mapping(address => uint256) public LiquidityManagerQueue; // Delays changes to mapping.\n\n    address[] public debtors; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isDebtor;\n    mapping(address => uint256) public debtorQueue; // Delays changes to mapping.\n    mapping(address => uint256) public debtorBalance;\n\n    address[] public rewardManagers; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isRewardManager;\n    mapping(address => uint256) public rewardManagerQueue; // Delays changes to mapping.\n\n    address public nNecc;\n    uint256 public nNeccQueue; // Delays change to nNecc address\n\n    uint256 public totalReserves; // Risk-free value of all assets\n    uint256 public totalDebt;\n\n    constructor(\n        address _Necc,\n        address _NUSD,\n        uint256 _blocksNeededForQueue\n    ) {\n        require(_Necc != address(0));\n        Necc = _Necc;\n\n        isReserveToken[_NUSD] = true;\n        reserveTokens.push(_NUSD);\n\n        // isLiquidityToken[ _NeccNUSD ] = true;\n        // liquidityTokens.push( _NeccNUSD );\n\n        blocksNeededForQueue = _blocksNeededForQueue;\n    }\n\n    /**\n        @notice allow approved address to deposit an asset for Necc\n        @param _amount uint\n        @param _token address\n        @param _profit uint\n        @return send_ uint\n     */\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256 send_) {\n        require(\n            isReserveToken[_token] || isLiquidityToken[_token],\n            \"Not accepted\"\n        );\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (isReserveToken[_token]) {\n            require(isReserveDepositor[msg.sender], \"Not approved\");\n        } else {\n            require(isLiquidityDepositor[msg.sender], \"Not approved\");\n        }\n\n        uint256 value = valueOfToken(_token, _amount);\n        (_token, _amount);\n        // mint Necc needed and store amount of rewards for distribution\n        send_ = value.sub(_profit);\n        IERC20Mintable(Necc).mint(msg.sender, send_);\n\n        totalReserves = totalReserves.add(value);\n        emit ReservesUpdated(totalReserves);\n\n        emit Deposit(_token, _amount, value);\n    }\n\n    /**\n        @notice allow approved address to burn Necc for reserves\n        @param _amount uint\n        @param _token address\n     */\n    function withdraw(uint256 _amount, address _token) external {\n        require(isReserveToken[_token], \"Not accepted\"); // Only reserves can be used for redemptions\n        require(isReserveSpender[msg.sender] == true, \"Not approved\");\n\n        uint256 value = valueOfToken(_token, _amount);\n        IERC20Mintable(Necc).burnFrom(msg.sender, value);\n\n        totalReserves = totalReserves.sub(value);\n        emit ReservesUpdated(totalReserves);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n\n        emit Withdrawal(_token, _amount, value);\n    }\n\n    /**\n        @notice allow approved address to borrow reserves\n        @param _amount uint\n        @param _token address\n     */\n    function incurDebt(uint256 _amount, address _token) external {\n        require(isDebtor[msg.sender], \"Not approved\");\n        require(isReserveToken[_token], \"Not accepted\");\n\n        uint256 value = valueOfToken(_token, _amount);\n\n        uint256 maximumDebt = IERC20(nNecc).balanceOf(msg.sender); // Can only borrow against nNecc held\n        uint256 availableDebt = maximumDebt.sub(debtorBalance[msg.sender]);\n        require(value <= availableDebt, \"Exceeds debt limit\");\n\n        debtorBalance[msg.sender] = debtorBalance[msg.sender].add(value);\n        totalDebt = totalDebt.add(value);\n\n        totalReserves = totalReserves.sub(value);\n        emit ReservesUpdated(totalReserves);\n\n        IERC20(_token).transfer(msg.sender, _amount);\n\n        emit CreateDebt(msg.sender, _token, _amount, value);\n    }\n\n    /**\n        @notice allow approved address to repay borrowed reserves with reserves\n        @param _amount uint\n        @param _token address\n     */\n    function repayDebtWithReserve(uint256 _amount, address _token) external {\n        require(isDebtor[msg.sender], \"Not approved\");\n        require(isReserveToken[_token], \"Not accepted\");\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 value = valueOfToken(_token, _amount);\n        debtorBalance[msg.sender] = debtorBalance[msg.sender].sub(value);\n        totalDebt = totalDebt.sub(value);\n\n        totalReserves = totalReserves.add(value);\n        emit ReservesUpdated(totalReserves);\n\n        emit RepayDebt(msg.sender, _token, _amount, value);\n    }\n\n    /**\n        @notice allow approved address to repay borrowed reserves with Necc\n        @param _amount uint\n     */\n    function repayDebtWithNecc(uint256 _amount) external {\n        require(isDebtor[msg.sender], \"Not approved\");\n\n        IERC20Mintable(Necc).burnFrom(msg.sender, _amount);\n\n        debtorBalance[msg.sender] = debtorBalance[msg.sender].sub(_amount);\n        totalDebt = totalDebt.sub(_amount);\n\n        emit RepayDebt(msg.sender, Necc, _amount, _amount);\n    }\n\n    /**\n        @notice allow approved address to withdraw assets\n        @param _token address\n        @param _amount uint\n     */\n    function manage(address _token, uint256 _amount) external {\n        if (isLiquidityToken[_token]) {\n            require(isLiquidityManager[msg.sender], \"Not approved\");\n        } else {\n            require(isReserveManager[msg.sender], \"Not approved\");\n        }\n\n        uint256 value = valueOfToken(_token, _amount);\n        (_token, _amount);\n        require(value <= excessReserves(), \"Insufficient reserves\");\n\n        totalReserves = totalReserves.sub(value);\n        emit ReservesUpdated(totalReserves);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n\n        emit ReservesManaged(_token, _amount);\n    }\n\n    /**\n        @notice send epoch reward to staking contract\n     */\n    function mintRewards(address _recipient, uint256 _amount) external {\n        require(isRewardManager[msg.sender], \"Not approved\");\n        require(_amount <= excessReserves(), \"Insufficient reserves\");\n\n        IERC20Mintable(Necc).mint(_recipient, _amount);\n\n        emit RewardsMinted(msg.sender, _recipient, _amount);\n    }\n\n    /**\n        @notice returns excess reserves not backing tokens\n        @return uint\n     */\n    function excessReserves() public view returns (uint256) {\n        return totalReserves.sub(IERC20(Necc).totalSupply().sub(totalDebt));\n    }\n\n    /**\n        @notice takes inventory of all tracked assets\n        @notice always consolidate to recognized reserves before audit\n     */\n    function auditReserves() external onlyManager {\n        uint256 reserves;\n        for (uint256 i = 0; i < reserveTokens.length; i++) {\n            reserves = reserves.add(\n                valueOfToken(\n                    reserveTokens[i],\n                    IERC20(reserveTokens[i]).balanceOf(address(this))\n                )\n            );\n        }\n        for (uint256 i = 0; i < liquidityTokens.length; i++) {\n            reserves = reserves.add(\n                valueOfToken(\n                    liquidityTokens[i],\n                    IERC20(liquidityTokens[i]).balanceOf(address(this))\n                )\n            );\n        }\n        totalReserves = reserves;\n        emit ReservesUpdated(reserves);\n        emit ReservesAudited(reserves);\n    }\n\n    /**\n        @notice returns Necc valuation of asset\n        @param _token address\n        @param _amount uint\n        @return value_ uint\n     */\n    function valueOfToken(address _token, uint256 _amount)\n        public\n        view\n        returns (uint256 value_)\n    {\n        if (isReserveToken[_token]) {\n            // convert amount to match Necc decimals\n            value_ = _amount.mul(10**IERC20Mintable(Necc).decimals()).div(\n                10**IERC20Mintable(_token).decimals()\n            );\n        } else if (isLiquidityToken[_token]) {\n            value_ = IBondCalculator(bondCalculator[_token]).valuation(\n                _token,\n                _amount\n            );\n        }\n    }\n\n    /**\n        @notice queue address to change boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n    function queue(MANAGING _managing, address _address)\n        external\n        onlyManager\n        returns (bool)\n    {\n        require(_address != address(0));\n        if (_managing == MANAGING.RESERVEDEPOSITOR) {\n            // 0\n            reserveDepositorQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVESPENDER) {\n            // 1\n            reserveSpenderQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVETOKEN) {\n            // 2\n            reserveTokenQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVEMANAGER) {\n            // 3\n            ReserveManagerQueue[_address] = block.number.add(\n                blocksNeededForQueue.mul(2)\n            );\n        } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n            // 4\n            LiquidityDepositorQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n            // 5\n            LiquidityTokenQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n            // 6\n            LiquidityManagerQueue[_address] = block.number.add(\n                blocksNeededForQueue.mul(2)\n            );\n        } else if (_managing == MANAGING.DEBTOR) {\n            // 7\n            debtorQueue[_address] = block.number.add(blocksNeededForQueue);\n        } else if (_managing == MANAGING.REWARDMANAGER) {\n            // 8\n            rewardManagerQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.nNecc) {\n            // 9\n            nNeccQueue = block.number.add(blocksNeededForQueue);\n        } else return false;\n\n        emit ChangeQueued(_managing, _address);\n        return true;\n    }\n\n    /**\n        @notice verify queue then set boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @param _calculator address\n        @return bool\n     */\n    function toggle(\n        MANAGING _managing,\n        address _address,\n        address _calculator\n    ) external onlyManager returns (bool) {\n        require(_address != address(0));\n        bool result;\n        if (_managing == MANAGING.RESERVEDEPOSITOR) {\n            // 0\n            if (\n                requirements(\n                    reserveDepositorQueue,\n                    isReserveDepositor,\n                    _address\n                )\n            ) {\n                reserveDepositorQueue[_address] = 0;\n                if (!listContains(reserveDepositors, _address)) {\n                    reserveDepositors.push(_address);\n                }\n            }\n            result = !isReserveDepositor[_address];\n            isReserveDepositor[_address] = result;\n        } else if (_managing == MANAGING.RESERVESPENDER) {\n            // 1\n            if (requirements(reserveSpenderQueue, isReserveSpender, _address)) {\n                reserveSpenderQueue[_address] = 0;\n                if (!listContains(reserveSpenders, _address)) {\n                    reserveSpenders.push(_address);\n                }\n            }\n            result = !isReserveSpender[_address];\n            isReserveSpender[_address] = result;\n        } else if (_managing == MANAGING.RESERVETOKEN) {\n            // 2\n            if (requirements(reserveTokenQueue, isReserveToken, _address)) {\n                reserveTokenQueue[_address] = 0;\n                if (!listContains(reserveTokens, _address)) {\n                    reserveTokens.push(_address);\n                }\n            }\n            result = !isReserveToken[_address];\n            isReserveToken[_address] = result;\n        } else if (_managing == MANAGING.RESERVEMANAGER) {\n            // 3\n            if (requirements(ReserveManagerQueue, isReserveManager, _address)) {\n                reserveManagers.push(_address);\n                ReserveManagerQueue[_address] = 0;\n                if (!listContains(reserveManagers, _address)) {\n                    reserveManagers.push(_address);\n                }\n            }\n            result = !isReserveManager[_address];\n            isReserveManager[_address] = result;\n        } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n            // 4\n            if (\n                requirements(\n                    LiquidityDepositorQueue,\n                    isLiquidityDepositor,\n                    _address\n                )\n            ) {\n                liquidityDepositors.push(_address);\n                LiquidityDepositorQueue[_address] = 0;\n                if (!listContains(liquidityDepositors, _address)) {\n                    liquidityDepositors.push(_address);\n                }\n            }\n            result = !isLiquidityDepositor[_address];\n            isLiquidityDepositor[_address] = result;\n        } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n            // 5\n            if (requirements(LiquidityTokenQueue, isLiquidityToken, _address)) {\n                LiquidityTokenQueue[_address] = 0;\n                if (!listContains(liquidityTokens, _address)) {\n                    liquidityTokens.push(_address);\n                }\n            }\n            result = !isLiquidityToken[_address];\n            isLiquidityToken[_address] = result;\n            bondCalculator[_address] = _calculator;\n        } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n            // 6\n            if (\n                requirements(\n                    LiquidityManagerQueue,\n                    isLiquidityManager,\n                    _address\n                )\n            ) {\n                LiquidityManagerQueue[_address] = 0;\n                if (!listContains(liquidityManagers, _address)) {\n                    liquidityManagers.push(_address);\n                }\n            }\n            result = !isLiquidityManager[_address];\n            isLiquidityManager[_address] = result;\n        } else if (_managing == MANAGING.DEBTOR) {\n            // 7\n            if (requirements(debtorQueue, isDebtor, _address)) {\n                debtorQueue[_address] = 0;\n                if (!listContains(debtors, _address)) {\n                    debtors.push(_address);\n                }\n            }\n            result = !isDebtor[_address];\n            isDebtor[_address] = result;\n        } else if (_managing == MANAGING.REWARDMANAGER) {\n            // 8\n            if (requirements(rewardManagerQueue, isRewardManager, _address)) {\n                rewardManagerQueue[_address] = 0;\n                if (!listContains(rewardManagers, _address)) {\n                    rewardManagers.push(_address);\n                }\n            }\n            result = !isRewardManager[_address];\n            isRewardManager[_address] = result;\n        } else if (_managing == MANAGING.nNecc) {\n            // 9\n            nNeccQueue = 0;\n            nNecc = _address;\n            result = true;\n        } else return false;\n\n        emit ChangeActivated(_managing, _address, result);\n        return true;\n    }\n\n    /**\n        @notice checks requirements and returns altered structs\n        @param queue_ mapping( address => uint )\n        @param status_ mapping( address => bool )\n        @param _address address\n        @return bool \n     */\n    function requirements(\n        mapping(address => uint256) storage queue_,\n        mapping(address => bool) storage status_,\n        address _address\n    ) internal view returns (bool) {\n        if (!status_[_address]) {\n            require(queue_[_address] != 0, \"Must queue\");\n            require(queue_[_address] <= block.number, \"Queue not expired\");\n            return true;\n        }\n        return false;\n    }\n\n    /**\n        @notice checks array to ensure against duplicate\n        @param _list address[]\n        @param _token address\n        @return bool\n     */\n    function listContains(address[] storage _list, address _token)\n        internal\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _list.length; i++) {\n            if (_list[i] == _token) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/tokens/Necc/Staking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/InNecc.sol\";\nimport \"./interfaces/IWarmup.sol\";\nimport \"./interfaces/IDistributor.sol\";\n\ninterface IOwnable {\n    function manager() external view returns (address);\n\n    function renounceManagement() external;\n\n    function pushManagement(address newOwner_) external;\n\n    function pullManagement() external;\n}\n\ncontract Ownable is IOwnable {\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipPulled(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipPushed(address(0), _owner);\n    }\n\n    function manager() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyManager() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyManager {\n        emit OwnershipPushed(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function pushManagement(address newOwner_)\n        public\n        virtual\n        override\n        onlyManager\n    {\n        require(\n            newOwner_ != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipPushed(_owner, newOwner_);\n        _newOwner = newOwner_;\n    }\n\n    function pullManagement() public virtual override {\n        require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled(_owner, _newOwner);\n        _owner = _newOwner;\n    }\n}\n\ncontract Staking is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public immutable Necc;\n    address public immutable nNecc;\n\n    struct Epoch {\n        uint256 number;\n        uint256 distribute;\n        uint256 length;\n        uint256 endTime;\n    }\n    Epoch public epoch;\n\n    address public distributor;\n\n    address public locker;\n    uint256 public totalBonus;\n\n    address public warmupContract;\n    uint256 public warmupPeriod;\n\n    constructor(\n        address _Necc,\n        address _nNecc,\n        uint32 _epochLength,\n        uint256 _firstEpochNumber,\n        uint32 _firstEpochTime\n    ) {\n        require(_Necc != address(0));\n        Necc = _Necc;\n        require(_nNecc != address(0));\n        nNecc = _nNecc;\n\n        epoch = Epoch({\n            length: _epochLength,\n            number: _firstEpochNumber,\n            endTime: _firstEpochTime,\n            distribute: 0\n        });\n    }\n\n    struct Claim {\n        uint256 deposit;\n        uint256 gons;\n        uint256 expiry;\n        bool lock; // prevents malicious delays\n    }\n    mapping(address => Claim) public warmupInfo;\n\n    /**\n        @notice stake Necc to enter warmup\n        @param _amount uint\n        @return bool\n     */\n    function stake(uint256 _amount, address _recipient)\n        external\n        returns (bool)\n    {\n        rebase();\n\n        IERC20(Necc).safeTransferFrom(msg.sender, address(this), _amount);\n\n        Claim memory info = warmupInfo[_recipient];\n        require(!info.lock, \"Deposits for account are locked\");\n\n        warmupInfo[_recipient] = Claim({\n            deposit: info.deposit.add(_amount),\n            gons: info.gons.add(InNecc(nNecc).gonsForBalance(_amount)),\n            expiry: epoch.number.add(warmupPeriod),\n            lock: false\n        });\n\n        IERC20(nNecc).safeTransfer(warmupContract, _amount);\n        return true;\n    }\n\n    /**\n        @notice retrieve nNecc from warmup\n        @param _recipient address\n     */\n    function claim(address _recipient) public {\n        Claim memory info = warmupInfo[_recipient];\n        if (epoch.number >= info.expiry && info.expiry != 0) {\n            delete warmupInfo[_recipient];\n            IWarmup(warmupContract).retrieve(\n                _recipient,\n                InNecc(nNecc).balanceForGons(info.gons)\n            );\n        }\n    }\n\n    /**\n        @notice forfeit nNecc in warmup and retrieve Necc\n     */\n    function forfeit() external {\n        Claim memory info = warmupInfo[msg.sender];\n        delete warmupInfo[msg.sender];\n\n        IWarmup(warmupContract).retrieve(\n            address(this),\n            InNecc(nNecc).balanceForGons(info.gons)\n        );\n        IERC20(Necc).safeTransfer(msg.sender, info.deposit);\n    }\n\n    /**\n        @notice prevent new deposits to address (protection from malicious activity)\n     */\n    function toggleDepositLock() external {\n        warmupInfo[msg.sender].lock = !warmupInfo[msg.sender].lock;\n    }\n\n    /**\n        @notice redeem nNecc for Necc\n        @param _amount uint\n        @param _trigger bool\n     */\n    function unstake(uint256 _amount, bool _trigger) external {\n        if (_trigger) {\n            rebase();\n        }\n        IERC20(nNecc).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(Necc).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n        @notice returns the nNecc index, which tracks rebase growth\n        @return uint\n     */\n    function index() public view returns (uint256) {\n        return InNecc(nNecc).index();\n    }\n\n    /**\n        @notice trigger rebase if epoch over\n     */\n    function rebase() public {\n        if (epoch.endTime <= uint32(block.timestamp)) {\n            InNecc(nNecc).rebase(epoch.distribute, epoch.number);\n\n            epoch.endTime = epoch.endTime.add(epoch.length);\n            epoch.number++;\n\n            if (distributor != address(0)) {\n                IDistributor(distributor).distribute();\n            }\n\n            uint256 balance = contractBalance();\n            uint256 staked = InNecc(nNecc).circulatingSupply();\n\n            if (balance <= staked) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance.sub(staked);\n            }\n        }\n    }\n\n    /**\n        @notice returns contract Necc holdings, including bonuses provided\n        @return uint\n     */\n    function contractBalance() public view returns (uint256) {\n        return IERC20(Necc).balanceOf(address(this)).add(totalBonus);\n    }\n\n    /**\n        @notice provide bonus to locked staking contract\n        @param _amount uint\n     */\n    function giveLockBonus(uint256 _amount) external {\n        require(msg.sender == locker);\n        totalBonus = totalBonus.add(_amount);\n        IERC20(nNecc).safeTransfer(locker, _amount);\n    }\n\n    /**\n        @notice reclaim bonus from locked staking contract\n        @param _amount uint\n     */\n    function returnLockBonus(uint256 _amount) external {\n        require(msg.sender == locker);\n        totalBonus = totalBonus.sub(_amount);\n        IERC20(nNecc).safeTransferFrom(locker, address(this), _amount);\n    }\n\n    enum CONTRACTS {\n        DISTRIBUTOR,\n        WARMUP,\n        LOCKER\n    }\n\n    /**\n        @notice sets the contract address for LP staking\n        @param _contract address\n     */\n    function setContract(CONTRACTS _contract, address _address)\n        external\n        onlyManager\n    {\n        if (_contract == CONTRACTS.DISTRIBUTOR) {\n            // 0\n            distributor = _address;\n        } else if (_contract == CONTRACTS.WARMUP) {\n            // 1\n            require(\n                warmupContract == address(0),\n                \"Warmup cannot be set more than once\"\n            );\n            warmupContract = _address;\n        } else if (_contract == CONTRACTS.LOCKER) {\n            // 2\n            require(\n                locker == address(0),\n                \"Locker cannot be set more than once\"\n            );\n            locker = _address;\n        }\n    }\n\n    /**\n     * @notice set warmup period in epoch's numbers for new stakers\n     * @param _warmupPeriod uint\n     */\n    function setWarmup(uint256 _warmupPeriod) external onlyManager {\n        warmupPeriod = _warmupPeriod;\n    }\n}\n"
    },
    "contracts/tokens/Necc/interfaces/InNecc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface InNecc is IERC20 {\n    function rebase(uint256 neccProfit_, uint256 epoch_)\n        external\n        returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view override returns (uint256);\n\n    function gonsForBalance(uint256 amount) external view returns (uint256);\n\n    function balanceForGons(uint256 gons) external view returns (uint256);\n\n    function index() external view returns (uint256);\n}\n"
    },
    "contracts/tokens/Necc/interfaces/IWarmup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IWarmup {\n    function retrieve(address staker_, uint256 amount_) external;\n}\n"
    },
    "contracts/tokens/Necc/interfaces/IDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IDistributor {\n    function distribute() external returns (bool);\n}\n"
    },
    "contracts/tokens/Necc/nNecc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./types/Ownable.sol\";\n\nimport \"./types/ManagerOwnable.sol\";\nimport \"./types/ERC20Permit.sol\";\n\nimport \"./interfaces/IOracle.sol\";\n\ncontract nNecc is ERC20Permit, ManagerOwnable {\n    /* ========== DEPENDENCIES ========== */\n\n    using SafeMath for uint256;\n\n    /* ========== EVENTS ========== */\n\n    event LogSupply(\n        uint256 indexed epoch,\n        uint256 timestamp,\n        uint256 totalSupply\n    );\n    event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n    event LogStakingContractUpdated(address stakingContract);\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyStakingContract() {\n        require(msg.sender == stakingContract);\n        _;\n    }\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct Rebase {\n        uint256 epoch;\n        uint256 rebase; // 18 decimals\n        uint256 totalStakedBefore;\n        uint256 totalStakedAfter;\n        uint256 amountRebased;\n        uint256 index;\n        uint256 blockNumberOccured;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    address initializer;\n\n    uint256 INDEX; // Index Gons - tracks rebase growth\n\n    address public stakingContract; // balance used to calc rebase\n\n    IOracle oracle; // pulls price from pool\n    address pool;\n\n    Rebase[] public rebases; // past rebase data\n\n    uint256 private constant MAX_UINT256 = ~uint256(0);\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 5000000 * 10**9;\n\n    // TOTAL_GONS is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\n    // Use the highest value that fits in a uint256 for max granularity.\n    uint256 private constant TOTAL_GONS =\n        MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\n\n    // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_GONS + 1) - 1) / 2\n    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n\n    uint256 private _gonsPerFragment;\n    mapping(address => uint256) private _gonBalances;\n\n    mapping(address => mapping(address => uint256)) private _allowedValue;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor() ERC20(\"Staked Necc\", \"nNecc\", 9) ERC20Permit() {\n        initializer = msg.sender;\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n    }\n\n    function initialize(address stakingContract_) external returns (bool) {\n        require(msg.sender == initializer);\n        require(stakingContract_ != address(0));\n        stakingContract = stakingContract_;\n        _gonBalances[stakingContract] = TOTAL_GONS;\n\n        emit Transfer(address(0x0), stakingContract, _totalSupply);\n        emit LogStakingContractUpdated(stakingContract_);\n\n        initializer = address(0);\n        return true;\n    }\n\n    function setIndex(uint256 _INDEX) external onlyManager returns (bool) {\n        require(INDEX == 0);\n        INDEX = gonsForBalance(_INDEX);\n        return true;\n    }\n\n    /**\n        @notice increases nNecc supply to increase staking balances relative to profit_\n        @param profit_ uint256\n        @return uint256\n     */\n    function rebase(uint256 profit_, uint256 epoch_)\n        public\n        onlyStakingContract\n        returns (uint256)\n    {\n        uint256 rebaseAmount;\n        uint256 circulatingSupply_ = circulatingSupply();\n\n        if (profit_ == 0) {\n            emit LogSupply(epoch_, block.timestamp, _totalSupply);\n            emit LogRebase(epoch_, 0, index());\n            return _totalSupply;\n        } else if (circulatingSupply_ > 0) {\n            rebaseAmount = profit_.mul(_totalSupply).div(circulatingSupply_);\n        } else {\n            rebaseAmount = profit_;\n        }\n\n        _totalSupply = _totalSupply.add(rebaseAmount);\n\n        if (_totalSupply > MAX_SUPPLY) {\n            _totalSupply = MAX_SUPPLY;\n        }\n\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n\n        _storeRebase(circulatingSupply_, profit_, epoch_);\n\n        return _totalSupply;\n    }\n\n    /**\n        @notice emits event with data about rebase\n        @param previousCirculating_ uint\n        @param profit_ uint\n        @param epoch_ uint\n        @return bool\n     */\n    function _storeRebase(\n        uint256 previousCirculating_,\n        uint256 profit_,\n        uint256 epoch_\n    ) internal returns (bool) {\n        uint256 rebasePercent = profit_.mul(1e18).div(previousCirculating_);\n\n        rebases.push(\n            Rebase({\n                epoch: epoch_,\n                rebase: rebasePercent, // 18 decimals\n                totalStakedBefore: previousCirculating_,\n                totalStakedAfter: circulatingSupply(),\n                amountRebased: profit_,\n                index: index(),\n                blockNumberOccured: block.number\n            })\n        );\n\n        emit LogSupply(epoch_, block.timestamp, _totalSupply);\n        emit LogRebase(epoch_, rebasePercent, index());\n\n        return true;\n    }\n\n    function balanceOf(address who) public view override returns (uint256) {\n        return _gonBalances[who].div(_gonsPerFragment);\n    }\n\n    function gonsForBalance(uint256 amount) public view returns (uint256) {\n        return amount.mul(_gonsPerFragment);\n    }\n\n    function balanceForGons(uint256 gons) public view returns (uint256) {\n        return gons.div(_gonsPerFragment);\n    }\n\n    // Staking contract holds excess nNecc\n    function circulatingSupply() public view returns (uint256) {\n        return _totalSupply.sub(balanceOf(stakingContract));\n    }\n\n    function index() public view returns (uint256) {\n        return balanceForGons(INDEX);\n    }\n\n    function transfer(address to, uint256 value)\n        public\n        override\n        returns (bool)\n    {\n        uint256 gonValue = value.mul(_gonsPerFragment);\n        _gonBalances[msg.sender] = _gonBalances[msg.sender].sub(gonValue);\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner_, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowedValue[owner_][spender];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public override returns (bool) {\n        _allowedValue[from][msg.sender] = _allowedValue[from][msg.sender].sub(\n            value\n        );\n        emit Approval(from, msg.sender, _allowedValue[from][msg.sender]);\n\n        uint256 gonValue = gonsForBalance(value);\n        _gonBalances[from] = _gonBalances[from].sub(gonValue);\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 value)\n        public\n        override\n        returns (bool)\n    {\n        _allowedValue[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // What gets called in a permit\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal virtual override {\n        _allowedValue[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        override\n        returns (bool)\n    {\n        _allowedValue[msg.sender][spender] = _allowedValue[msg.sender][spender]\n            .add(addedValue);\n        emit Approval(msg.sender, spender, _allowedValue[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        override\n        returns (bool)\n    {\n        uint256 oldValue = _allowedValue[msg.sender][spender];\n        if (subtractedValue >= oldValue) {\n            _allowedValue[msg.sender][spender] = 0;\n        } else {\n            _allowedValue[msg.sender][spender] = oldValue.sub(subtractedValue);\n        }\n        emit Approval(msg.sender, spender, _allowedValue[msg.sender][spender]);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/tokens/Necc/types/Ownable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"../interfaces/IOwnable.sol\";\n\nabstract contract Ownable is IOwnable {\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipPulled(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipPushed(address(0), _owner);\n    }\n\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyOwner {\n        emit OwnershipPushed(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function pushManagement(address newOwner_)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        require(\n            newOwner_ != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipPushed(_owner, newOwner_);\n        _newOwner = newOwner_;\n    }\n\n    function pullManagement() public virtual override {\n        require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled(_owner, _newOwner);\n        _owner = _newOwner;\n    }\n}\n"
    },
    "contracts/tokens/Necc/types/ManagerOwnable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"./Ownable.sol\";\n\ncontract ManagerOwnable is Ownable {\n    modifier onlyManager() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "contracts/tokens/Necc/types/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"../libraries/Counters.sol\";\n\nimport \"../interfaces/IERC2612Permit.sol\";\nimport \"./ERC20.sol\";\n\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    constructor() {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name())),\n                keccak256(bytes(\"1\")), // Version\n                chainID,\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev See {IERC2612Permit-permit}.\n     *\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"Permit: expired deadline\");\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                _nonces[owner].current(),\n                deadline\n            )\n        );\n\n        bytes32 _hash = keccak256(\n            abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct)\n        );\n\n        address signer = ecrecover(_hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            \"ZeroSwapPermit: Invalid signature\"\n        );\n\n        _nonces[owner].increment();\n        _approve(owner, spender, amount);\n    }\n\n    /**\n     * @dev See {IERC2612Permit-nonces}.\n     */\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner].current();\n    }\n}\n"
    },
    "contracts/tokens/Necc/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IOracle {\n    function getPrice(address _pool) external returns (uint256);\n}\n"
    },
    "contracts/tokens/Necc/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n\n    function renounceManagement() external;\n\n    function pushManagement(address newOwner_) external;\n\n    function pullManagement() external;\n}\n"
    },
    "contracts/tokens/Necc/libraries/Counters.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "contracts/tokens/Necc/interfaces/IERC2612Permit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IERC2612Permit {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/tokens/Necc/types/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    // TODO comment actual hash value.\n    bytes32 private constant ERC20TOKEN_ERC1820_INTERFACE_ID =\n        keccak256(\"ERC20Token\");\n\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string internal _name;\n\n    string internal _symbol;\n\n    uint8 internal _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account_, uint256 ammount_) internal virtual {\n        require(account_ != address(0), \"ERC20: mint to the zero address\");\n        _beforeTokenTransfer(address(this), account_, ammount_);\n        _totalSupply = _totalSupply.add(ammount_);\n        _balances[account_] = _balances[account_].add(ammount_);\n        emit Transfer(address(this), account_, ammount_);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(\n            amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from_,\n        address to_,\n        uint256 amount_\n    ) internal virtual {}\n}\n"
    },
    "contracts/tokens/Necc/Necc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./interfaces/IERC2612Permit.sol\";\n\nimport \"./types/ERC20Permit.sol\";\nimport \"./types/Ownable.sol\";\nimport \"./types/VaultOwned.sol\";\n\ncontract Necc is ERC20Permit, VaultOwned {\n    using SafeMath for uint256;\n\n    constructor() ERC20(\"Necc\", \"Necc\", 9) {}\n\n    function mint(address account_, uint256 amount_) external onlyVault {\n        _mint(account_, amount_);\n    }\n\n    function burn(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account_, uint256 amount_) public virtual {\n        _burnFrom(account_, amount_);\n    }\n\n    function _burnFrom(address account_, uint256 amount_) public virtual {\n        uint256 decreasedAllowance_ = allowance(account_, msg.sender).sub(\n            amount_,\n            \"ERC20: burn amount exceeds allowance\"\n        );\n\n        _approve(account_, msg.sender, decreasedAllowance_);\n        _burn(account_, amount_);\n    }\n}\n"
    },
    "contracts/tokens/Necc/types/VaultOwned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"./Ownable.sol\";\n\ncontract VaultOwned is Ownable {\n    address internal _vault;\n\n    function setVault(address vault_) external onlyOwner returns (bool) {\n        _vault = vault_;\n\n        return true;\n    }\n\n    function vault() public view returns (address) {\n        return _vault;\n    }\n\n    modifier onlyVault() {\n        require(_vault == msg.sender, \"VaultOwned: caller is not the Vault\");\n        _;\n    }\n}\n"
    },
    "contracts/facets/Vault/VaultConfigFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./VaultLib.sol\";\nimport \"../../lib/Facet.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract VaultConfigFacet is Facet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event DirectPoolDeposit(address token, uint256 amount);\n    event WithdrawFees(address _token, address _receiver, uint256 _amount);\n\n    function initialize(address _weth, address _nusd) external {\n        onlyGov();\n        require(!s.isInitialized, \"Vault: already initialized\");\n\n        s.isInitialized = true;\n        s.includeAmmPrice = true;\n\n        s.weth = _weth;\n        s.nusd = _nusd;\n        // VaultPriceFeedFacet\n        s.priceSampleSpace = 1;\n    }\n\n    function isInitialized() public view returns (bool) {\n        return s.isInitialized;\n    }\n\n    function setNUSD(address _nusd) public {\n        onlyGov();\n        s.nusd = _nusd;\n    }\n\n    function setPriceFeed(address _priceFeed) external {\n        onlyGov();\n        s.priceFeed = _priceFeed;\n    }\n\n    function setTokenConfig(\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _redemptionBasisPoints,\n        uint256 _minProfitBasisPoints,\n        address _priceFeed,\n        uint256 _priceDecimals,\n        uint256 _spreadBasisPoints\n    ) external {\n        onlyGov();\n        s.whitelistedTokens[_token] = true;\n        s.tokenDecimals[_token] = _tokenDecimals;\n        s.redemptionBasisPoints[_token] = _redemptionBasisPoints;\n        s.minProfitBasisPoints[_token] = _minProfitBasisPoints;\n        s.priceFeeds[_token] = _priceFeed;\n        s.priceDecimals[_token] = _priceDecimals;\n        s.spreadBasisPoints[_token] = _spreadBasisPoints;\n\n        // validate price feed\n        VaultLib.getMaxPrice(_token, s.includeAmmPrice);\n    }\n\n    function clearTokenConfig(address _token) external {\n        onlyGov();\n        VaultLib.isTokenWhitelisted(s, _token);\n\n        delete s.whitelistedTokens[_token];\n        delete s.tokenDecimals[_token];\n        delete s.redemptionBasisPoints[_token];\n        delete s.minProfitBasisPoints[_token];\n        delete s.priceFeeds[_token];\n        delete s.priceDecimals[_token];\n        delete s.spreadBasisPoints[_token];\n    }\n\n    function withdrawFees(address _token, address _receiver)\n        external\n        returns (uint256)\n    {\n        onlyGov();\n        uint256 _amount = s.feeReserves[_token];\n        if (_amount == 0) {\n            return 0;\n        }\n        s.feeReserves[_token] = 0;\n        VaultLib.transferOut(s, _token, _amount, _receiver);\n\n        emit WithdrawFees(_token, _receiver, _amount);\n        return _amount;\n    }\n\n    function directPoolDeposit(address _token) external {\n        contractEntered();\n        VaultLib.isTokenWhitelisted(s, _token);\n        uint256 _tokenAmount = VaultLib.transferIn(s, _token);\n        require(_tokenAmount > 0, \"Vault: invalid _tokenAmount\");\n        VaultLib._increasePoolAmount(s, _token, _tokenAmount);\n\n        emit DirectPoolDeposit(_token, _tokenAmount);\n        contractExited();\n    }\n}\n"
    },
    "contracts/facets/Treasury/TreasuryFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./Facet.sol\";\n\ninterface IBondCalculator {\n    function valuation(address pair_, uint256 amount_)\n        external\n        view\n        returns (uint256 _value);\n}\n\ninterface IERC20Mintable {\n    function decimals() external view returns (uint256);\n\n    function mint(uint256 amount_) external;\n\n    function mint(address account_, uint256 ammount_) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n\ncontract TreasuryFacet is Facet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed token, uint256 amount, uint256 value);\n    event Withdrawal(address indexed token, uint256 amount, uint256 value);\n    event CreateDebt(\n        address indexed debtor,\n        address indexed token,\n        uint256 amount,\n        uint256 value\n    );\n    event RepayDebt(\n        address indexed debtor,\n        address indexed token,\n        uint256 amount,\n        uint256 value\n    );\n    event ReservesManaged(address indexed token, uint256 amount);\n    event ReservesUpdated(uint256 indexed totalReserves);\n    event ReservesAudited(uint256 indexed totalReserves);\n    event RewardsMinted(\n        address indexed caller,\n        address indexed recipient,\n        uint256 amount\n    );\n    event ChangeQueued(MANAGING indexed managing, address queued);\n    event ChangeActivated(\n        MANAGING indexed managing,\n        address activated,\n        bool result\n    );\n\n    enum MANAGING {\n        RESERVEDEPOSITOR,\n        RESERVESPENDER,\n        RESERVETOKEN,\n        RESERVEMANAGER,\n        LIQUIDITYDEPOSITOR,\n        LIQUIDITYTOKEN,\n        LIQUIDITYMANAGER,\n        DEBTOR,\n        REWARDMANAGER,\n        NNECC\n    }\n\n    function initializeTreasury(\n        address _Necc,\n        address _NUSD,\n        uint256 _blocksNeededForQueue\n    ) external {\n        onlyGov();\n        require(_Necc != address(0));\n        s.Necc = _Necc;\n\n        s.isReserveToken[_NUSD] = true;\n        s.reserveTokens.push(_NUSD);\n\n        // s.isLiquidityToken[ _NeccNUSD ] = true;\n        // s.liquidityTokens.push( _NeccNUSD );\n\n        s.blocksNeededForQueue = _blocksNeededForQueue;\n    }\n\n    /**\n        @notice allow approved address to deposit an asset for Necc\n        @param _amount uint\n        @param _token address\n        @param _profit uint\n        @return send_ uint\n     */\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256 send_) {\n        require(\n            s.isReserveToken[_token] || s.isLiquidityToken[_token],\n            \"Not accepted\"\n        );\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (s.isReserveToken[_token]) {\n            require(s.isReserveDepositor[msg.sender], \"Not approved\");\n        } else {\n            require(s.isLiquidityDepositor[msg.sender], \"Not approved\");\n        }\n\n        uint256 value = valueOfToken(_token, _amount);\n        (_token, _amount);\n        // mint Necc needed and store amount of rewards for distribution\n        send_ = value.sub(_profit);\n        IERC20Mintable(s.Necc).mint(msg.sender, send_);\n\n        s.totalReserves = s.totalReserves.add(value);\n        emit ReservesUpdated(s.totalReserves);\n\n        emit Deposit(_token, _amount, value);\n\n        return send_;\n    }\n\n    /**\n        @notice allow approved address to burn Necc for reserves\n        @param _amount uint\n        @param _token address\n     */\n    function withdraw(uint256 _amount, address _token) external {\n        require(s.isReserveToken[_token], \"Not accepted\"); // Only reserves can be used for redemptions\n        require(s.isReserveSpender[msg.sender] == true, \"Not approved\");\n\n        uint256 _value = valueOfToken(_token, _amount);\n        IERC20Mintable(s.Necc).burnFrom(msg.sender, _value);\n\n        s.totalReserves = s.totalReserves.sub(_value);\n        emit ReservesUpdated(s.totalReserves);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n\n        emit Withdrawal(_token, _amount, _value);\n    }\n\n    /**\n        @notice allow approved address to borrow reserves\n        @param _amount uint\n        @param _token address\n     */\n    function incurDebt(uint256 _amount, address _token) external {\n        require(s.isDebtor[msg.sender], \"Not approved\");\n        require(s.isReserveToken[_token], \"Not accepted\");\n\n        uint256 _value = valueOfToken(_token, _amount);\n\n        uint256 maximumDebt = IERC20(s.nNecc).balanceOf(msg.sender); // Can only borrow against nNecc held\n        uint256 availableDebt = maximumDebt.sub(s.debtorBalance[msg.sender]);\n        require(_value <= availableDebt, \"Exceeds debt limit\");\n\n        s.debtorBalance[msg.sender] = s.debtorBalance[msg.sender].add(_value);\n        s.totalDebt = s.totalDebt.add(_value);\n\n        s.totalReserves = s.totalReserves.sub(_value);\n        emit ReservesUpdated(s.totalReserves);\n\n        IERC20(_token).transfer(msg.sender, _amount);\n\n        emit CreateDebt(msg.sender, _token, _amount, _value);\n    }\n\n    /**\n        @notice allow approved address to repay borrowed reserves with reserves\n        @param _amount uint\n        @param _token address\n     */\n    function repayDebtWithReserve(uint256 _amount, address _token) external {\n        require(s.isDebtor[msg.sender], \"Not approved\");\n        require(s.isReserveToken[_token], \"Not accepted\");\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 _value = valueOfToken(_token, _amount);\n        s.debtorBalance[msg.sender] = s.debtorBalance[msg.sender].sub(_value);\n        s.totalDebt = s.totalDebt.sub(_value);\n\n        s.totalReserves = s.totalReserves.add(_value);\n        emit ReservesUpdated(s.totalReserves);\n\n        emit RepayDebt(msg.sender, _token, _amount, _value);\n    }\n\n    /**\n        @notice allow approved address to repay borrowed reserves with Necc\n        @param _amount uint\n     */\n    function repayDebtWithNecc(uint256 _amount) external {\n        require(s.isDebtor[msg.sender], \"Not approved\");\n\n        IERC20Mintable(s.Necc).burnFrom(msg.sender, _amount);\n\n        s.debtorBalance[msg.sender] = s.debtorBalance[msg.sender].sub(_amount);\n        s.totalDebt = s.totalDebt.sub(_amount);\n\n        emit RepayDebt(msg.sender, s.Necc, _amount, _amount);\n    }\n\n    /**\n        @notice allow approved address to withdraw assets\n        @param _token address\n        @param _amount uint\n     */\n    function manage(address _token, uint256 _amount) external {\n        if (s.isLiquidityToken[_token]) {\n            require(s.isLiquidityManager[msg.sender], \"Not approved\");\n        } else {\n            require(s.isReserveManager[msg.sender], \"Not approved\");\n        }\n\n        uint256 _value = valueOfToken(_token, _amount);\n        (_token, _amount);\n        require(_value <= excessReserves(), \"Insufficient reserves\");\n\n        s.totalReserves = s.totalReserves.sub(_value);\n        emit ReservesUpdated(s.totalReserves);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n\n        emit ReservesManaged(_token, _amount);\n    }\n\n    /**\n        @notice send epoch reward to staking contract\n     */\n    function mintRewards(address _recipient, uint256 _amount) external {\n        require(s.isRewardManager[msg.sender], \"Not approved\");\n        require(_amount <= excessReserves(), \"Insufficient reserves\");\n\n        IERC20Mintable(s.Necc).mint(_recipient, _amount);\n\n        emit RewardsMinted(msg.sender, _recipient, _amount);\n    }\n\n    /**\n        @notice returns excess reserves not backing tokens\n        @return uint\n     */\n    function excessReserves() public view returns (uint256) {\n        return\n            s.totalReserves.sub(IERC20(s.Necc).totalSupply().sub(s.totalDebt));\n    }\n\n    /**\n        @notice takes inventory of all tracked assets\n        @notice always consolidate to recognized reserves before audit\n     */\n    function auditReserves() external {\n        onlyGov();\n        uint256 reserves;\n        for (uint256 i = 0; i < s.reserveTokens.length; i++) {\n            reserves = reserves.add(\n                valueOfToken(\n                    s.reserveTokens[i],\n                    IERC20(s.reserveTokens[i]).balanceOf(address(this))\n                )\n            );\n        }\n        for (uint256 i = 0; i < s.liquidityTokens.length; i++) {\n            reserves = reserves.add(\n                valueOfToken(\n                    s.liquidityTokens[i],\n                    IERC20(s.liquidityTokens[i]).balanceOf(address(this))\n                )\n            );\n        }\n        s.totalReserves = reserves;\n        emit ReservesUpdated(reserves);\n        emit ReservesAudited(reserves);\n    }\n\n    /**\n        @notice returns Necc valuation of asset\n        @param _token address\n        @param _amount uint\n        @return _value uint\n     */\n    function valueOfToken(address _token, uint256 _amount)\n        public\n        view\n        returns (uint256 _value)\n    {\n        if (s.isReserveToken[_token]) {\n            // convert amount to match Necc decimals\n            _value = _amount.mul(10**IERC20Mintable(s.Necc).decimals()).div(\n                10**IERC20Mintable(_token).decimals()\n            );\n        } else if (s.isLiquidityToken[_token]) {\n            _value = IBondCalculator(address(this)).valuation(_token, _amount);\n        }\n    }\n\n    /**\n        @notice queue address to change boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n    function queue(MANAGING _managing, address _address)\n        external\n        returns (bool)\n    {\n        onlyGov();\n        require(_address != address(0));\n        if (_managing == MANAGING.RESERVEDEPOSITOR) {\n            // 0\n            s.reserveDepositorQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVESPENDER) {\n            // 1\n            s.reserveSpenderQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVETOKEN) {\n            // 2\n            s.reserveTokenQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVEMANAGER) {\n            // 3\n            s.ReserveManagerQueue[_address] = block.number.add(\n                s.blocksNeededForQueue.mul(2)\n            );\n        } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n            // 4\n            s.LiquidityDepositorQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n            // 5\n            s.LiquidityTokenQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n            // 6\n            s.LiquidityManagerQueue[_address] = block.number.add(\n                s.blocksNeededForQueue.mul(2)\n            );\n        } else if (_managing == MANAGING.DEBTOR) {\n            // 7\n            s.debtorQueue[_address] = block.number.add(s.blocksNeededForQueue);\n        } else if (_managing == MANAGING.REWARDMANAGER) {\n            // 8\n            s.rewardManagerQueue[_address] = block.number.add(\n                s.blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.NNECC) {\n            // 9\n            s.nNeccQueue = block.number.add(s.blocksNeededForQueue);\n        } else return false;\n\n        emit ChangeQueued(_managing, _address);\n        return true;\n    }\n\n    /**\n        @notice verify queue then set boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n    function toggle(MANAGING _managing, address _address)\n        external\n        returns (bool)\n    {\n        onlyGov();\n        require(_address != address(0));\n        bool _result;\n        if (_managing == MANAGING.RESERVEDEPOSITOR) {\n            // 0\n            if (\n                requirements(\n                    s.reserveDepositorQueue,\n                    s.isReserveDepositor,\n                    _address\n                )\n            ) {\n                s.reserveDepositorQueue[_address] = 0;\n                if (!listContains(s.reserveDepositors, _address)) {\n                    s.reserveDepositors.push(_address);\n                }\n            }\n            _result = !s.isReserveDepositor[_address];\n            s.isReserveDepositor[_address] = _result;\n        } else if (_managing == MANAGING.RESERVESPENDER) {\n            // 1\n            if (\n                requirements(\n                    s.reserveSpenderQueue,\n                    s.isReserveSpender,\n                    _address\n                )\n            ) {\n                s.reserveSpenderQueue[_address] = 0;\n                if (!listContains(s.reserveSpenders, _address)) {\n                    s.reserveSpenders.push(_address);\n                }\n            }\n            _result = !s.isReserveSpender[_address];\n            s.isReserveSpender[_address] = _result;\n        } else if (_managing == MANAGING.RESERVETOKEN) {\n            // 2\n            if (requirements(s.reserveTokenQueue, s.isReserveToken, _address)) {\n                s.reserveTokenQueue[_address] = 0;\n                if (!listContains(s.reserveTokens, _address)) {\n                    s.reserveTokens.push(_address);\n                }\n            }\n            _result = !s.isReserveToken[_address];\n            s.isReserveToken[_address] = _result;\n        } else if (_managing == MANAGING.RESERVEMANAGER) {\n            // 3\n            if (\n                requirements(\n                    s.ReserveManagerQueue,\n                    s.isReserveManager,\n                    _address\n                )\n            ) {\n                s.reserveManagers.push(_address);\n                s.ReserveManagerQueue[_address] = 0;\n                if (!listContains(s.reserveManagers, _address)) {\n                    s.reserveManagers.push(_address);\n                }\n            }\n            _result = !s.isReserveManager[_address];\n            s.isReserveManager[_address] = _result;\n        } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n            // 4\n            if (\n                requirements(\n                    s.LiquidityDepositorQueue,\n                    s.isLiquidityDepositor,\n                    _address\n                )\n            ) {\n                s.liquidityDepositors.push(_address);\n                s.LiquidityDepositorQueue[_address] = 0;\n                if (!listContains(s.liquidityDepositors, _address)) {\n                    s.liquidityDepositors.push(_address);\n                }\n            }\n            _result = !s.isLiquidityDepositor[_address];\n            s.isLiquidityDepositor[_address] = _result;\n        } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n            // 5\n            if (\n                requirements(\n                    s.LiquidityTokenQueue,\n                    s.isLiquidityToken,\n                    _address\n                )\n            ) {\n                s.LiquidityTokenQueue[_address] = 0;\n                if (!listContains(s.liquidityTokens, _address)) {\n                    s.liquidityTokens.push(_address);\n                }\n            }\n            _result = !s.isLiquidityToken[_address];\n            s.isLiquidityToken[_address] = _result;\n        } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n            // 6\n            if (\n                requirements(\n                    s.LiquidityManagerQueue,\n                    s.isLiquidityManager,\n                    _address\n                )\n            ) {\n                s.LiquidityManagerQueue[_address] = 0;\n                if (!listContains(s.liquidityManagers, _address)) {\n                    s.liquidityManagers.push(_address);\n                }\n            }\n            _result = !s.isLiquidityManager[_address];\n            s.isLiquidityManager[_address] = _result;\n        } else if (_managing == MANAGING.DEBTOR) {\n            // 7\n            if (requirements(s.debtorQueue, s.isDebtor, _address)) {\n                s.debtorQueue[_address] = 0;\n                if (!listContains(s.debtors, _address)) {\n                    s.debtors.push(_address);\n                }\n            }\n            _result = !s.isDebtor[_address];\n            s.isDebtor[_address] = _result;\n        } else if (_managing == MANAGING.REWARDMANAGER) {\n            // 8\n            if (\n                requirements(s.rewardManagerQueue, s.isRewardManager, _address)\n            ) {\n                s.rewardManagerQueue[_address] = 0;\n                if (!listContains(s.rewardManagers, _address)) {\n                    s.rewardManagers.push(_address);\n                }\n            }\n            _result = !s.isRewardManager[_address];\n            s.isRewardManager[_address] = _result;\n        } else if (_managing == MANAGING.NNECC) {\n            // 9\n            s.nNeccQueue = 0;\n            s.nNecc = _address;\n            _result = true;\n        } else return false;\n\n        emit ChangeActivated(_managing, _address, _result);\n        return true;\n    }\n\n    /**\n        @notice checks requirements and returns altered structs\n        @param queue_ mapping( address => uint )\n        @param status_ mapping( address => bool )\n        @param _address address\n        @return bool \n     */\n    function requirements(\n        mapping(address => uint256) storage queue_,\n        mapping(address => bool) storage status_,\n        address _address\n    ) internal view returns (bool) {\n        if (!status_[_address]) {\n            require(queue_[_address] != 0, \"Must queue\");\n            require(queue_[_address] <= block.number, \"Queue not expired\");\n            return true;\n        }\n        return false;\n    }\n\n    /**\n        @notice checks array to ensure against duplicate\n        @param _list address[]\n        @param _token address\n        @return bool\n     */\n    function listContains(address[] storage _list, address _token)\n        internal\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _list.length; i++) {\n            if (_list[i] == _token) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/facets/Bond/DistributorFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./Facet.sol\";\nimport \"./LibBondStorage.sol\";\nimport \"./BondDepositoryLib.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\ninterface ITreasury {\n    function mintRewards(address _recipient, uint256 _amount) external;\n}\n\ninterface IBCVPC {\n    function updateBCVs() external;\n}\n\ncontract DistributorFacet is Facet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using BondDepositoryLib for LibBondStorage.Storage;\n\n    function initializeDistributor(\n        uint256 _epochLength,\n        uint256 _nextEpochTimestamp,\n        address _principle\n    ) public {\n        uint256 _principleIndex = s.getIndexAt(_principle);\n        s.epochLength = _epochLength;\n        s.nextEpochTimestamp[_principleIndex] = _nextEpochTimestamp;\n    }\n\n    /* ====== PUBLIC FUNCTIONS ====== */\n\n    /**\n        @notice send epoch reward to staking contract\n     */\n    function distribute() external returns (bool) {\n        uint256 _principleLength = EnumerableSet.length(s.principles);\n        bool _success = true;\n        for (\n            uint256 _principleIndex = 0;\n            _principleIndex < _principleLength;\n            _principleIndex++\n        ) {\n            // address _principle = EnumerableSet.at(\n            //     s.principles,\n            //     _principleIndex\n            // );\n\n            if (s.nextEpochTimestamp[_principleIndex] <= block.timestamp) {\n                s.nextEpochTimestamp[_principleIndex] = s\n                    .nextEpochTimestamp[_principleIndex]\n                    .add(s.epochLength); // set next epoch block\n\n                // distribute rewards to each recipient\n                for (uint256 i = 0; i < s.info.length; i++) {\n                    if (s.info[i].rate > 0) {\n                        ITreasury(s.treasury).mintRewards( // mint and send from treasury\n                            s.info[i].recipient,\n                            nextRewardAt(s.info[i].rate)\n                        );\n                        adjust(i); // check for adjustment\n                    }\n                }\n            } else {\n                _success = false;\n            }\n        }\n\n        if (_success) {\n            IBCVPC(address(this)).updateBCVs();\n        }\n\n        return _success;\n    }\n\n    /* ====== INTERNAL FUNCTIONS ====== */\n\n    /**\n        @notice increment reward rate for collector\n     */\n    function adjust(uint256 _index) internal {\n        LibBondStorage.DistributorAdjustment storage distributorAdjustment = s\n            .distributorAdjustments[_index];\n\n        if (distributorAdjustment.rate != 0) {\n            if (distributorAdjustment.add) {\n                // if rate should increase\n                s.info[_index].rate = s.info[_index].rate.add(\n                    distributorAdjustment.rate\n                ); // raise rate\n                if (s.info[_index].rate >= distributorAdjustment.target) {\n                    // if target met\n                    s.distributorAdjustments[_index].rate = 0; // turn off distributorAdjustment\n                }\n            } else {\n                // if rate should decrease\n                s.info[_index].rate = s.info[_index].rate.sub(\n                    distributorAdjustment.rate\n                ); // lower rate\n                if (s.info[_index].rate <= distributorAdjustment.target) {\n                    // if target met\n                    s.distributorAdjustments[_index].rate = 0; // turn off adjustment\n                }\n            }\n        }\n    }\n\n    /* ====== VIEW FUNCTIONS ====== */\n\n    /**\n        @notice view function for next reward at given rate\n        @param _rate uint\n        @return uint\n     */\n    function nextRewardAt(uint256 _rate) public view returns (uint256) {\n        return IERC20(s.Necc).totalSupply().mul(_rate).div(1000000);\n    }\n\n    /**\n        @notice view function for next reward for specified address\n        @param _recipient address\n        @return uint\n     */\n    function nextRewardFor(address _recipient) public view returns (uint256) {\n        uint256 reward;\n        for (uint256 i = 0; i < s.info.length; i++) {\n            if (s.info[i].recipient == _recipient) {\n                reward = nextRewardAt(s.info[i].rate);\n            }\n        }\n        return reward;\n    }\n\n    /* ====== POLICY FUNCTIONS ====== */\n\n    /**\n        @notice adds recipient for distributions\n        @param _recipient address\n        @param _rewardRate uint\n     */\n    function addRecipient(address _recipient, uint256 _rewardRate) external {\n        onlyGov();\n        require(_recipient != address(0));\n        s.info.push(\n            LibBondStorage.Info({recipient: _recipient, rate: _rewardRate})\n        );\n    }\n\n    /**\n        @notice removes recipient for distributions\n        @param _index uint\n        @param _recipient address\n     */\n    function removeRecipient(uint256 _index, address _recipient) external {\n        onlyGov();\n        require(_recipient == s.info[_index].recipient);\n        s.info[_index].recipient = address(0);\n        s.info[_index].rate = 0;\n    }\n\n    /**\n        @notice set adjustment info for a collector's reward rate\n        @param _index uint\n        @param _add bool\n        @param _rate uint\n        @param _target uint\n     */\n    function setAdjustment(\n        uint256 _index,\n        bool _add,\n        uint256 _rate,\n        uint256 _target\n    ) external {\n        onlyGov();\n        s.distributorAdjustments[_index] = LibBondStorage\n            .DistributorAdjustment({add: _add, rate: _rate, target: _target});\n    }\n}\n"
    },
    "contracts/facets/Bond/StakingFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma abicoder v2;\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./LibBondStorage.sol\";\nimport \"./Facet.sol\";\n\ninterface IDistributor {\n    function distribute() external returns (uint256);\n}\n\ninterface InNecc is IERC20 {\n    function rebase(uint256 neccProfit_, uint256 epoch_)\n        external\n        returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view override returns (uint256);\n\n    function gonsForBalance(uint256 amount) external view returns (uint256);\n\n    function balanceForGons(uint256 gons) external view returns (uint256);\n\n    function index() external view returns (uint256);\n}\n\ninterface IWarmup {\n    function retrieve(address staker_, uint256 amount_) external;\n}\n\ncontract StakingFacet is Facet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    function initializeStaking(\n        uint256 _firstEpochNumber,\n        uint32 _firstEpochTime\n    ) public {\n        s.epoch = LibBondStorage.Epoch({\n            length: s.epochLength,\n            number: _firstEpochNumber,\n            endTime: _firstEpochTime,\n            distribute: 0\n        });\n    }\n\n    /**\n        @notice stake Necc to enter warmup\n        @param _amount uint\n        @return bool\n     */\n    function stake(uint256 _amount, address _recipient)\n        external\n        returns (bool)\n    {\n        rebase();\n\n        IERC20(s.Necc).safeTransferFrom(msg.sender, address(this), _amount);\n\n        LibBondStorage.Claim memory info = s.warmupInfo[_recipient];\n        require(!info.lock, \"Deposits for account are locked\");\n\n        s.warmupInfo[_recipient] = LibBondStorage.Claim({\n            deposit: info.deposit.add(_amount),\n            gons: info.gons.add(InNecc(s.nNecc).gonsForBalance(_amount)),\n            expiry: s.epoch.number.add(s.warmupPeriod),\n            lock: false\n        });\n\n        IERC20(s.nNecc).safeTransfer(address(this), _amount);\n        return true;\n    }\n\n    /**\n        @notice retrieve nNecc from warmup\n        @param _recipient address\n     */\n    function claim(address _recipient) public {\n        LibBondStorage.Claim memory info = s.warmupInfo[_recipient];\n        if (s.epoch.number >= info.expiry && info.expiry != 0) {\n            delete s.warmupInfo[_recipient];\n            IWarmup(address(this)).retrieve(\n                _recipient,\n                InNecc(s.nNecc).balanceForGons(info.gons)\n            );\n        }\n    }\n\n    /**\n        @notice forfeit nNecc in warmup and retrieve Necc\n     */\n    function forfeit() external {\n        LibBondStorage.Claim memory info = s.warmupInfo[msg.sender];\n        delete s.warmupInfo[msg.sender];\n\n        IWarmup(address(this)).retrieve(\n            address(this),\n            InNecc(s.nNecc).balanceForGons(info.gons)\n        );\n        IERC20(s.Necc).safeTransfer(msg.sender, info.deposit);\n    }\n\n    /**\n        @notice prevent new deposits to address (protection from malicious activity)\n     */\n    function toggleDepositLock() external {\n        s.warmupInfo[msg.sender].lock = !s.warmupInfo[msg.sender].lock;\n    }\n\n    /**\n        @notice redeem nNecc for Necc\n        @param _amount uint\n        @param _trigger bool\n     */\n    function unstake(uint256 _amount, bool _trigger) external {\n        if (_trigger) {\n            rebase();\n        }\n        IERC20(s.nNecc).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(s.Necc).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n        @notice returns the nNecc index, which tracks rebase growth\n        @return uint\n     */\n    function index() public view returns (uint256) {\n        return InNecc(s.nNecc).index();\n    }\n\n    /**\n        @notice trigger rebase if epoch over\n     */\n    function rebase() public {\n        if (s.epoch.endTime <= uint32(block.timestamp)) {\n            InNecc(s.nNecc).rebase(s.epoch.distribute, s.epoch.number);\n\n            s.epoch.endTime = s.epoch.endTime.add(s.epoch.length);\n            s.epoch.number++;\n\n            IDistributor(address(this)).distribute();\n\n            uint256 balance = contractBalance();\n            uint256 staked = InNecc(s.nNecc).circulatingSupply();\n\n            if (balance <= staked) {\n                s.epoch.distribute = 0;\n            } else {\n                s.epoch.distribute = balance.sub(staked);\n            }\n        }\n    }\n\n    /**\n        @notice returns contract Necc holdings, including bonuses provided\n        @return uint\n     */\n    function contractBalance() public view returns (uint256) {\n        return IERC20(s.Necc).balanceOf(address(this)).add(s.totalBonus);\n    }\n\n    /**\n        @notice provide bonus to locked staking contract\n        @param _amount uint\n     */\n    function giveLockBonus(uint256 _amount) external {\n        require(msg.sender == s.locker);\n        s.totalBonus = s.totalBonus.add(_amount);\n        IERC20(s.nNecc).safeTransfer(s.locker, _amount);\n    }\n\n    /**\n        @notice reclaim bonus from locked staking contract\n        @param _amount uint\n     */\n    function returnLockBonus(uint256 _amount) external {\n        require(msg.sender == s.locker);\n        s.totalBonus = s.totalBonus.sub(_amount);\n        IERC20(s.nNecc).safeTransferFrom(s.locker, address(this), _amount);\n    }\n\n    /**\n        @notice sets the contract address for LP staking\n        @param _contract address\n     */\n    function setContract(CONTRACTS _contract, address _address) external {\n        onlyGov();\n        if (_contract == CONTRACTS.LOCKER) {\n            // 2\n            require(\n                s.locker == address(0),\n                \"Locker cannot be set more than once\"\n            );\n            s.locker = _address;\n        }\n    }\n\n    /**\n     * @notice set warmup period in epoch's numbers for new stakers\n     * @param _warmupPeriod uint\n     */\n    function setWarmup(uint256 _warmupPeriod) external {\n        onlyGov();\n        s.warmupPeriod = _warmupPeriod;\n    }\n\n    function epoch() public view returns (LibBondStorage.Epoch memory) {\n        return s.epoch;\n    }\n\n    function warmupInfo(address _recipient)\n        public\n        view\n        returns (LibBondStorage.Claim memory)\n    {\n        return s.warmupInfo[_recipient];\n    }\n}\n"
    },
    "contracts/facets/Bond/BCVPCFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./Facet.sol\";\nimport \"./LibBondStorage.sol\";\nimport \"./BondDepositoryLib.sol\";\n\ninterface IDepository {\n    function setAdjustment(\n        bool _addition,\n        uint256 _delta,\n        uint256 _seconds,\n        address _principle\n    ) external;\n\n    function terms(address _principle)\n        external\n        view\n        returns (LibBondStorage.Terms memory);\n}\n\ncontract BCVPCFacet is Facet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ========== MUTABLE FUNCTIONS ========== */\n\n    // anyone can trigger a BCV update\n    // if a bond is 20% underweight for the period, its BCV will increase 20% over next period\n    function updateBCVs() external {\n        uint256 _principlesLength = EnumerableSet.length(s.principles);\n\n        for (\n            uint256 _principleIndex = 0;\n            _principleIndex < _principlesLength;\n            _principleIndex++\n        ) {\n            address _principle = EnumerableSet.at(\n                s.principles,\n                _principleIndex\n            );\n\n            LibBondStorage.Terms memory _terms = IDepository(address(this))\n                .terms(_principle);\n            uint256 BCV = _terms.controlVariable;\n            uint256 _principlePayoutSum = getPayoutSum(_principle);\n\n            uint256 newBCV = _principlePayoutSum != 0 && s.targetSum != 0\n                ? BCV.mul(_principlePayoutSum).div(s.targetSum)\n                : BCV;\n\n            if (s.weights[_principleIndex] != 0 && s.totalWeight != 0) {\n                // higher weight means lower BCV meaning cheaper bond pricing\n                // hence we do (total weight - principle weight) / total weight\n                newBCV = newBCV\n                    .mul(s.totalWeight.sub(s.weights[_principleIndex]))\n                    .div(s.totalWeight);\n            }\n\n            if (newBCV > BCV) {\n                IDepository(address(this)).setAdjustment(\n                    true,\n                    newBCV.sub(BCV),\n                    s.epochLength * BCV_ADJUSTMENT_EPOCH_PERIOD,\n                    _principle\n                );\n            } else {\n                IDepository(address(this)).setAdjustment(\n                    false,\n                    BCV.sub(newBCV),\n                    s.epochLength * BCV_ADJUSTMENT_EPOCH_PERIOD,\n                    _principle\n                );\n            }\n        }\n    }\n\n    /* ========== ONLY IDepository(address(this)) ========== */\n\n    // IDepository(address(this)) stores the payout amount and block timestamp it occurred for each bond\n    function storePayout(address _principle, uint256 _amount) public {\n        require(msg.sender == address(this), \"Only depository\");\n        uint256 _principleIndex = BondDepositoryLib.getIndexAt(s, _principle);\n\n        s.payouts[_principleIndex].push(\n            LibBondStorage.Payout({\n                amount: _amount,\n                blockTimestamp: block.timestamp\n            })\n        );\n    }\n\n    /* ========== ONLY POLICY ========== */\n\n    // sets target sum of Necc paid per period length\n    // (in 9 Necc decimals)\n    function setTargetSum(uint256 _targetSum) external {\n        onlyGov();\n        s.targetSum = _targetSum;\n    }\n\n    // policy sets a weight for each bond (determines portion of target sum allocated)\n    function setWeight(address _principle, uint256 _weight) external {\n        onlyGov();\n        uint256 _principleIndex = BondDepositoryLib.getIndexAt(s, _principle);\n        s.totalWeight = s.totalWeight.add(_weight).sub(\n            s.weights[_principleIndex]\n        );\n        s.weights[_principleIndex] = _weight;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function targetSum() public view returns (uint256) {\n        return s.targetSum;\n    }\n\n    // returns sum of Necc paid for a bond in the past period\n    function getPayoutSum(address _principle)\n        public\n        view\n        returns (uint256 sum_)\n    {\n        uint256 _principleIndex = BondDepositoryLib.getIndexAt(s, _principle);\n        uint256 blockTimestampAfter = block.timestamp.sub(s.epochLength);\n\n        LibBondStorage.Payout[] storage _principlePayouts = s.payouts[\n            _principleIndex\n        ];\n\n        for (uint256 i = 0; i < _principlePayouts.length; i++) {\n            if (_principlePayouts[i].blockTimestamp > blockTimestampAfter) {\n                sum_ = sum_.add(_principlePayouts[i].amount);\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../tokens/interfaces/INUSD.sol\";\nimport \"./interfaces/IVaultPriceFeed.sol\";\nimport \"./interfaces/IVault.sol\";\n\ncontract Vault is ReentrancyGuard, IVault {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct Position {\n        uint256 size;\n        uint256 collateral;\n        uint256 averagePrice;\n        uint256 entryFundingRate;\n        uint256 reserveAmount;\n        int256 realisedPnl;\n        uint256 lastIncreasedTime;\n    }\n\n    uint256 public constant override BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant FUNDING_RATE_PRECISION = 1000000;\n    uint256 public constant PRICE_PRECISION = 10**30;\n    uint256 public constant NUSD_DECIMALS = 18;\n    uint256 public constant MAX_FEE_BASIS_POINTS = 500; // 5%\n    uint256 public constant MAX_LIQUIDATION_FEE_USD = 100 * PRICE_PRECISION; // 100 USD\n    uint256 public constant MIN_FUNDING_RATE_INTERVAL = 1 hours;\n    uint256 public constant MAX_FUNDING_RATE_FACTOR = 10000; // 1%\n\n    bool public isInitialized;\n    bool public isMintingEnabled = false;\n    bool public isSwapEnabled = true;\n\n    address public router;\n    address public override priceFeed;\n\n    address public nusd;\n    address public gov;\n\n    uint256 public maxNUSDBatchSize;\n    uint256 public maxNUSDBuffer;\n    uint256 public whitelistedTokenCount;\n\n    uint256 public maxLeverage = 50 * 10000; // 50x\n\n    uint256 public liquidationFeeUsd;\n    uint256 public override swapFeeBasisPoints = 30; // 0.3%\n    uint256 public marginFeeBasisPoints = 10; // 0.1%\n    uint256 public minProfitTime = 1800; // 30 minutes\n\n    uint256 public fundingInterval = 8 hours;\n    uint256 public override fundingRateFactor;\n\n    uint256 public maxDebtBasisPoints;\n\n    bool public includeAmmPrice = true;\n\n    mapping(address => mapping(address => bool)) public approvedRouters;\n\n    mapping(address => bool) public whitelistedTokens;\n    mapping(address => uint256) public override tokenDecimals;\n    mapping(address => uint256) public redemptionBasisPoints;\n    mapping(address => uint256) public minProfitBasisPoints;\n    mapping(address => bool) public shortableTokens;\n\n    // tokenBalances is used only to determine _transferIn values\n    mapping(address => uint256) public tokenBalances;\n\n    // nusdAmounts tracks the amount of NUSD debt for each whitelisted token\n    mapping(address => uint256) public override nusdAmounts;\n\n    // poolAmounts tracks the number of received tokens that can be used for leverage\n    // this is tracked separately from tokenBalances to exclude funds that are deposited as margin collateral\n    mapping(address => uint256) public override poolAmounts;\n\n    // reservedAmounts tracks the number of tokens reserved for open leverage positions\n    mapping(address => uint256) public override reservedAmounts;\n\n    // guaranteedUsd tracks the amount of USD that is \"guaranteed\" by opened leverage positions\n    // this value is used to calculate the redemption values for selling of NUSD\n    // this is an estimated amount, it is possible for the actual guaranteed value to be lower\n    // in the case of sudden price decreases, the guaranteed value should be corrected\n    // after liquidations are carried out\n    mapping(address => uint256) public override guaranteedUsd;\n\n    mapping(address => uint256) public override cumulativeFundingRates;\n    mapping(address => uint256) public lastFundingTimes;\n\n    mapping(bytes32 => Position) public positions;\n\n    mapping(address => uint256) public override feeReserves;\n\n    event BuyNUSD(\n        address account,\n        address token,\n        uint256 tokenAmount,\n        uint256 nusdAmount\n    );\n    event SellNUSD(\n        address account,\n        address token,\n        uint256 nusdAmount,\n        uint256 tokenAmount\n    );\n    event Swap(\n        address account,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    event IncreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event DecreasePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 price,\n        uint256 fee\n    );\n    event LiquidatePosition(\n        bytes32 key,\n        address account,\n        address collateralToken,\n        address indexToken,\n        bool isLong,\n        uint256 size,\n        uint256 collateral,\n        uint256 reserveAmount,\n        int256 realisedPnl,\n        uint256 markPrice\n    );\n    event UpdatePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n    event ClosePosition(\n        bytes32 key,\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        int256 realisedPnl\n    );\n\n    event UpdateFundingRate(address token, uint256 fundingRate);\n    event UpdatePnl(bytes32 key, bool hasProfit, uint256 delta);\n\n    event CollectSwapFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event CollectMarginFees(address token, uint256 feeUsd, uint256 feeTokens);\n\n    event DirectPoolDeposit(address token, uint256 amount);\n    event IncreasePoolAmount(address token, uint256 amount);\n    event DecreasePoolAmount(address token, uint256 amount);\n    event IncreaseNUSDAmount(address token, uint256 amount);\n    event DecreaseNUSDAmount(address token, uint256 amount);\n    event IncreaseReservedAmount(address token, uint256 amount);\n    event DecreaseReservedAmount(address token, uint256 amount);\n    event IncreaseGuaranteedUsd(address token, uint256 amount);\n    event DecreaseGuaranteedUsd(address token, uint256 amount);\n\n    // once the parameters are verified to be working correctly,\n    // gov should be set to a timelock contract or a governance contract\n    constructor() {\n        gov = msg.sender;\n    }\n\n    function initialize(\n        address _router,\n        address _nusd,\n        address _priceFeed,\n        uint256 _maxNUSDBatchSize,\n        uint256 _maxNUSDBuffer,\n        uint256 _liquidationFeeUsd,\n        uint256 _fundingRateFactor,\n        uint256 _maxDebtBasisPoints\n    ) external {\n        _onlyGov();\n        require(!isInitialized, \"Vault: already initialized\");\n        isInitialized = true;\n\n        router = _router;\n        nusd = _nusd;\n        priceFeed = _priceFeed;\n        maxNUSDBatchSize = _maxNUSDBatchSize;\n        maxNUSDBuffer = _maxNUSDBuffer;\n        liquidationFeeUsd = _liquidationFeeUsd;\n        fundingRateFactor = _fundingRateFactor;\n        maxDebtBasisPoints = _maxDebtBasisPoints;\n    }\n\n    function setIsMintingEnabled(bool _isMintingEnabled) external override {\n        _onlyGov();\n        isMintingEnabled = _isMintingEnabled;\n    }\n\n    function setGov(address _gov) external {\n        _onlyGov();\n        gov = _gov;\n    }\n\n    function setPriceFeed(address _priceFeed) external override {\n        _onlyGov();\n        priceFeed = _priceFeed;\n    }\n\n    function setMaxNUSD(uint256 _maxNUSDBatchSize, uint256 _maxNUSDBuffer)\n        external\n        override\n    {\n        _onlyGov();\n        maxNUSDBatchSize = _maxNUSDBatchSize;\n        maxNUSDBuffer = _maxNUSDBuffer;\n    }\n\n    function setMaxDebtBasisPoints(uint256 _maxDebtBasisPoints) external {\n        _onlyGov();\n        require(_maxDebtBasisPoints > 0, \"Vault: invalid _maxDebtBasisPoints\");\n        maxDebtBasisPoints = _maxDebtBasisPoints;\n    }\n\n    function setFees(\n        uint256 _swapFeeBasisPoints,\n        uint256 _marginFeeBasisPoints,\n        uint256 _liquidationFeeUsd\n    ) external override {\n        _onlyGov();\n        require(\n            _swapFeeBasisPoints <= MAX_FEE_BASIS_POINTS,\n            \"Vault: invalid _swapFeeBasisPoints\"\n        );\n        require(\n            _marginFeeBasisPoints <= MAX_FEE_BASIS_POINTS,\n            \"Vault: invalid _marginFeeBasisPoints\"\n        );\n        require(\n            _liquidationFeeUsd <= MAX_LIQUIDATION_FEE_USD,\n            \"Vault: invalid _liquidationFeeUsd\"\n        );\n        swapFeeBasisPoints = _swapFeeBasisPoints;\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        liquidationFeeUsd = _liquidationFeeUsd;\n    }\n\n    function setFundingRate(\n        uint256 _fundingInterval,\n        uint256 _fundingRateFactor\n    ) external {\n        _onlyGov();\n        require(\n            _fundingInterval >= MIN_FUNDING_RATE_INTERVAL,\n            \"Vault: invalid _fundingInterval\"\n        );\n        require(\n            _fundingRateFactor <= MAX_FUNDING_RATE_FACTOR,\n            \"Vault: invalid _fundingRateFactor\"\n        );\n        fundingInterval = _fundingInterval;\n        fundingRateFactor = _fundingRateFactor;\n    }\n\n    function setTokenConfig(\n        address _token,\n        uint256 _tokenDecimals,\n        uint256 _redemptionBps,\n        uint256 _minProfitBps,\n        bool _isShortable\n    ) external {\n        _onlyGov();\n        // increment token count for the first time\n        if (!whitelistedTokens[_token]) {\n            whitelistedTokenCount = whitelistedTokenCount.add(1);\n        }\n        whitelistedTokens[_token] = true;\n        tokenDecimals[_token] = _tokenDecimals;\n        redemptionBasisPoints[_token] = _redemptionBps;\n        minProfitBasisPoints[_token] = _minProfitBps;\n        shortableTokens[_token] = _isShortable;\n\n        // validate price feed\n        getMaxPrice(_token);\n    }\n\n    function clearTokenConfig(address _token) external {\n        _onlyGov();\n        require(whitelistedTokens[_token], \"Vault: token not whitelisted\");\n        delete whitelistedTokens[_token];\n        delete tokenDecimals[_token];\n        delete redemptionBasisPoints[_token];\n        delete minProfitBasisPoints[_token];\n        delete shortableTokens[_token];\n        whitelistedTokenCount = whitelistedTokenCount.sub(1);\n    }\n\n    function addRouter(address _router) external {\n        approvedRouters[msg.sender][_router] = true;\n    }\n\n    function removeRouter(address _router) external {\n        approvedRouters[msg.sender][_router] = false;\n    }\n\n    // deposit into the pool without minting NUSD tokens\n    // useful in allowing the pool to become over-collaterised\n    function directPoolDeposit(address _token) external override nonReentrant {\n        require(whitelistedTokens[_token], \"Vault: _token not whitelisted\");\n        uint256 tokenAmount = _transferIn(_token);\n        require(tokenAmount > 0, \"Vault: invalid tokenAmount\");\n        _increasePoolAmount(_token, tokenAmount);\n        emit DirectPoolDeposit(_token, tokenAmount);\n    }\n\n    function withdrawFees(address _token, address _receiver)\n        external\n        override\n        returns (uint256)\n    {\n        _onlyGov();\n        uint256 amount = feeReserves[_token];\n        if (amount == 0) {\n            return 0;\n        }\n        feeReserves[_token] = 0;\n        _transferOut(_token, amount, _receiver);\n        return amount;\n    }\n\n    function buyNUSD(address _token, address _receiver)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        if (_receiver != gov) {\n            require(isMintingEnabled, \"Vault: minting not enabled\");\n        }\n        require(whitelistedTokens[_token], \"Vault: _token not whitelisted\");\n\n        uint256 tokenAmount = _transferIn(_token);\n        require(tokenAmount > 0, \"Vault: invalid tokenAmount\");\n\n        updateCumulativeFundingRate(_token);\n\n        uint256 price = getMinPrice(_token);\n\n        uint256 amountAfterFees = _collectSwapFees(_token, tokenAmount);\n        uint256 nusdAmount = amountAfterFees.mul(price).div(PRICE_PRECISION);\n        nusdAmount = adjustForDecimals(nusdAmount, _token, nusd);\n        require(nusdAmount > 0, \"Vault: invalid nusdAmount\");\n\n        _increaseNUSDAmount(_token, nusdAmount);\n        _increasePoolAmount(_token, amountAfterFees);\n\n        INUSD(nusd).mint(_receiver, nusdAmount);\n\n        emit BuyNUSD(_receiver, _token, tokenAmount, nusdAmount);\n\n        return nusdAmount;\n    }\n\n    function sellNUSD(address _token, address _receiver)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(whitelistedTokens[_token], \"Vault: _token not whitelisted\");\n\n        uint256 nusdAmount = _transferIn(nusd);\n        require(nusdAmount > 0, \"Vault: invalid nusdAmount\");\n\n        updateCumulativeFundingRate(_token);\n\n        uint256 redemptionAmount = getRedemptionAmount(_token, nusdAmount);\n        require(redemptionAmount > 0, \"Vault: invalid redemptionAmount\");\n\n        _decreaseNUSDAmount(_token, nusdAmount);\n        _decreasePoolAmount(_token, redemptionAmount);\n\n        INUSD(nusd).burn(address(this), nusdAmount);\n\n        // the _transferIn call increased the value of tokenBalances[nusd]\n        // usually decreases in token balances are synced by calling _transferOut\n        // however, for nusd, the tokens are burnt, so _updateTokenBalance should\n        // be manually called to record the decrease in tokens\n        _updateTokenBalance(nusd);\n\n        uint256 tokenAmount = _collectSwapFees(_token, redemptionAmount);\n        require(tokenAmount > 0, \"Vault: invalid tokenAmount\");\n        _transferOut(_token, tokenAmount, _receiver);\n\n        emit SellNUSD(_receiver, _token, nusdAmount, tokenAmount);\n\n        return tokenAmount;\n    }\n\n    function swap(\n        address _tokenIn,\n        address _tokenOut,\n        address _receiver\n    ) external override nonReentrant returns (uint256) {\n        require(isSwapEnabled, \"Vault: swaps not enabled\");\n        require(whitelistedTokens[_tokenIn], \"Vault: _tokenIn not whitelisted\");\n        require(\n            whitelistedTokens[_tokenOut],\n            \"Vault: _tokenOut not whitelisted\"\n        );\n        require(_tokenIn != _tokenOut, \"Vault: invalid tokens\");\n        updateCumulativeFundingRate(_tokenIn);\n        updateCumulativeFundingRate(_tokenOut);\n\n        uint256 amountIn = _transferIn(_tokenIn);\n        require(amountIn > 0, \"Vault: invalid amountIn\");\n\n        uint256 priceIn = getMinPrice(_tokenIn);\n        uint256 priceOut = getMaxPrice(_tokenOut);\n\n        uint256 amountOut = amountIn.mul(priceIn).div(priceOut);\n        amountOut = adjustForDecimals(amountOut, _tokenIn, _tokenOut);\n        uint256 amountOutAfterFees = _collectSwapFees(_tokenOut, amountOut);\n\n        // adjust nusdAmounts by the same nusdAmount as debt is shifted between the assets\n        uint256 nusdAmount = amountIn.mul(priceIn).div(PRICE_PRECISION);\n        nusdAmount = adjustForDecimals(nusdAmount, _tokenIn, nusd);\n\n        _increaseNUSDAmount(_tokenIn, nusdAmount);\n        _decreaseNUSDAmount(_tokenOut, nusdAmount);\n\n        _increasePoolAmount(_tokenIn, amountIn);\n        _decreasePoolAmount(_tokenOut, amountOut);\n\n        uint256 nusdDebt = nusdAmounts[_tokenOut].mul(PRICE_PRECISION).div(\n            10**NUSD_DECIMALS\n        );\n        if (\n            getRedemptionCollateralUsd(_tokenOut).mul(maxDebtBasisPoints) <\n            nusdDebt.mul(BASIS_POINTS_DIVISOR)\n        ) {\n            revert(\"Vault: max debt exceeded\");\n        }\n\n        _transferOut(_tokenOut, amountOutAfterFees, _receiver);\n\n        emit Swap(_receiver, _tokenIn, _tokenOut, amountIn, amountOutAfterFees);\n\n        return amountOutAfterFees;\n    }\n\n    function increasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _sizeDelta,\n        bool _isLong\n    ) external override nonReentrant {\n        _validateRouter(_account);\n        _validateTokens(_collateralToken, _indexToken);\n        updateCumulativeFundingRate(_collateralToken);\n\n        bytes32 key = getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        Position storage position = positions[key];\n\n        uint256 price = _isLong\n            ? getMaxPrice(_indexToken)\n            : getMinPrice(_indexToken);\n\n        if (position.size == 0) {\n            position.averagePrice = price;\n        }\n\n        if (position.size > 0 && _sizeDelta > 0) {\n            position.averagePrice = getNextAveragePrice(\n                _indexToken,\n                position.size,\n                position.averagePrice,\n                _isLong,\n                price,\n                _sizeDelta,\n                position.lastIncreasedTime\n            );\n        }\n\n        uint256 fee = _collectMarginFees(\n            _collateralToken,\n            _sizeDelta,\n            position.size,\n            position.entryFundingRate\n        );\n        uint256 collateralDelta = _transferIn(_collateralToken);\n        uint256 collateralDeltaUsd = tokenToUsdMin(\n            _collateralToken,\n            collateralDelta\n        );\n\n        position.collateral = position.collateral.add(collateralDeltaUsd);\n        require(\n            position.collateral >= fee,\n            \"Vault: insufficient collateral for fees\"\n        );\n\n        position.collateral = position.collateral.sub(fee);\n        position.entryFundingRate = cumulativeFundingRates[_collateralToken];\n        position.size = position.size.add(_sizeDelta);\n        position.lastIncreasedTime = block.timestamp;\n\n        require(position.size > 0, \"Vault: invalid position.size\");\n        _validatePosition(position.size, position.collateral);\n        validateLiquidation(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong,\n            true\n        );\n\n        // reserve tokens to pay profits on the position\n        uint256 reserveDelta = usdToTokenMax(_collateralToken, _sizeDelta);\n        position.reserveAmount = position.reserveAmount.add(reserveDelta);\n        _increaseReservedAmount(_collateralToken, reserveDelta);\n\n        // guaranteedUsd stores the sum of (position.size - position.collateral) for all positions\n        // if a fee is charged on the collateral then guaranteedUsd should be increased by that fee amount\n        // since (position.size - position.collateral) would have increased by `fee`\n        _increaseGuaranteedUsd(_collateralToken, _sizeDelta.add(fee));\n        _decreaseGuaranteedUsd(_collateralToken, collateralDeltaUsd);\n        // treat the deposited collateral as part of the pool\n        _increasePoolAmount(_collateralToken, collateralDelta);\n        // fees need to be deducted from the pool since fees are deducted from position.collateral\n        // and collateral is treated as part of the pool\n        _decreasePoolAmount(\n            _collateralToken,\n            usdToTokenMin(_collateralToken, fee)\n        );\n\n        emit IncreasePosition(\n            key,\n            _account,\n            _collateralToken,\n            _indexToken,\n            collateralDeltaUsd,\n            _sizeDelta,\n            _isLong,\n            price,\n            fee\n        );\n        emit UpdatePosition(\n            key,\n            position.size,\n            position.collateral,\n            position.averagePrice,\n            position.entryFundingRate,\n            position.reserveAmount,\n            position.realisedPnl\n        );\n    }\n\n    function decreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) external override nonReentrant returns (uint256) {\n        _validateRouter(_account);\n        _validateTokens(_collateralToken, _indexToken);\n\n        return\n            _decreasePosition(\n                _account,\n                _collateralToken,\n                _indexToken,\n                _collateralDelta,\n                _sizeDelta,\n                _isLong,\n                _receiver\n            );\n    }\n\n    function _decreasePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver\n    ) private returns (uint256) {\n        updateCumulativeFundingRate(_collateralToken);\n\n        bytes32 key = getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        Position storage position = positions[key];\n        require(position.size > 0, \"Vault: empty position\");\n        require(position.size >= _sizeDelta, \"Vault: position size exceeded\");\n        require(\n            position.collateral >= _collateralDelta,\n            \"Vault: position collateral exceeded\"\n        );\n\n        uint256 collateral = position.collateral;\n        // scrop variables to avoid stack too deep errors\n        {\n            uint256 reserveDelta = position.reserveAmount.mul(_sizeDelta).div(\n                position.size\n            );\n            position.reserveAmount = position.reserveAmount.sub(reserveDelta);\n            _decreaseReservedAmount(_collateralToken, reserveDelta);\n        }\n\n        (uint256 usdOut, uint256 usdOutAfterFee) = _reduceCollateral(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong\n        );\n\n        if (position.size != _sizeDelta) {\n            position.entryFundingRate = cumulativeFundingRates[\n                _collateralToken\n            ];\n            position.size = position.size.sub(_sizeDelta);\n\n            _validatePosition(position.size, position.collateral);\n            validateLiquidation(\n                _account,\n                _collateralToken,\n                _indexToken,\n                _isLong,\n                true\n            );\n\n            _increaseGuaranteedUsd(\n                _collateralToken,\n                collateral.sub(position.collateral)\n            );\n            _decreaseGuaranteedUsd(_collateralToken, _sizeDelta);\n\n            uint256 price = _isLong\n                ? getMinPrice(_indexToken)\n                : getMaxPrice(_indexToken);\n            emit DecreasePosition(\n                key,\n                _account,\n                _collateralToken,\n                _indexToken,\n                _collateralDelta,\n                _sizeDelta,\n                _isLong,\n                price,\n                usdOut.sub(usdOutAfterFee)\n            );\n            emit UpdatePosition(\n                key,\n                position.size,\n                position.collateral,\n                position.averagePrice,\n                position.entryFundingRate,\n                position.reserveAmount,\n                position.realisedPnl\n            );\n        } else {\n            _increaseGuaranteedUsd(_collateralToken, collateral);\n            _decreaseGuaranteedUsd(_collateralToken, _sizeDelta);\n\n            uint256 price = _isLong\n                ? getMinPrice(_indexToken)\n                : getMaxPrice(_indexToken);\n            emit DecreasePosition(\n                key,\n                _account,\n                _collateralToken,\n                _indexToken,\n                _collateralDelta,\n                _sizeDelta,\n                _isLong,\n                price,\n                usdOut.sub(usdOutAfterFee)\n            );\n            emit ClosePosition(\n                key,\n                position.size,\n                position.collateral,\n                position.averagePrice,\n                position.entryFundingRate,\n                position.reserveAmount,\n                position.realisedPnl\n            );\n\n            delete positions[key];\n        }\n\n        if (usdOut > 0) {\n            _decreasePoolAmount(\n                _collateralToken,\n                usdToTokenMin(_collateralToken, usdOut)\n            );\n            uint256 amountOutAfterFees = usdToTokenMin(\n                _collateralToken,\n                usdOutAfterFee\n            );\n            _transferOut(_collateralToken, amountOutAfterFees, _receiver);\n            return amountOutAfterFees;\n        }\n\n        return 0;\n    }\n\n    function liquidatePosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        address _feeReceiver\n    ) external nonReentrant {\n        // set includeAmmPrice to false prevent manipulated liquidations\n        includeAmmPrice = false;\n\n        _validateTokens(_collateralToken, _indexToken);\n        updateCumulativeFundingRate(_collateralToken);\n\n        bytes32 key = getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        Position memory position = positions[key];\n        require(position.size > 0, \"Vault: empty position\");\n\n        (uint256 liquidationState, uint256 marginFees) = validateLiquidation(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong,\n            false\n        );\n        require(liquidationState != 0, \"Vault: position cannot be liquidated\");\n        // max leverage exceeded but there is collateral remaining after deducting losses\n        // so decreasePosition instead by a half to keep alive\n        if (liquidationState == 2) {\n            _decreasePosition(\n                _account,\n                _collateralToken,\n                _indexToken,\n                0,\n                position.size.mul(5).div(10), // div by 2\n                _isLong,\n                _account\n            );\n            return;\n        }\n\n        feeReserves[_collateralToken] = feeReserves[_collateralToken].add(\n            usdToTokenMin(_collateralToken, marginFees)\n        );\n\n        _decreaseReservedAmount(_collateralToken, position.reserveAmount);\n        _decreaseGuaranteedUsd(\n            _collateralToken,\n            position.size.sub(position.collateral)\n        );\n\n        uint256 markPrice = _isLong\n            ? getMinPrice(_indexToken)\n            : getMaxPrice(_indexToken);\n        emit LiquidatePosition(\n            key,\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong,\n            position.size,\n            position.collateral,\n            position.reserveAmount,\n            position.realisedPnl,\n            markPrice\n        );\n\n        delete positions[key];\n\n        // pay the fee receiver using the pool, we assume that in general the liquidated amount should be sufficient to cover\n        // the liquidation fees\n        _decreasePoolAmount(\n            _collateralToken,\n            usdToTokenMin(_collateralToken, liquidationFeeUsd)\n        );\n        _transferOut(\n            _collateralToken,\n            usdToTokenMin(_collateralToken, liquidationFeeUsd),\n            _feeReceiver\n        );\n\n        includeAmmPrice = true;\n    }\n\n    function validateLiquidation(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong,\n        bool _raise\n    )\n        public\n        view\n        returns (\n            // returns (state, fees)\n            uint256,\n            uint256\n        )\n    {\n        bytes32 key = getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        Position memory position = positions[key];\n\n        (bool hasProfit, uint256 delta) = getDelta(\n            _indexToken,\n            position.size,\n            position.averagePrice,\n            _isLong,\n            position.lastIncreasedTime\n        );\n        uint256 marginFees = getFundingFee(\n            _collateralToken,\n            position.size,\n            position.entryFundingRate\n        );\n        marginFees = marginFees.add(getPositionFee(position.size));\n\n        if (!hasProfit && position.collateral < delta) {\n            if (_raise) {\n                revert(\"Vault: losses exceed collateral\");\n            }\n            return (1, marginFees);\n        }\n\n        uint256 remainingCollateral = position.collateral;\n        if (!hasProfit) {\n            remainingCollateral = position.collateral.sub(delta);\n        }\n\n        if (remainingCollateral < marginFees) {\n            if (_raise) {\n                revert(\"Vault: fees exceed collateral\");\n            }\n            // cap the fees to the remainingCollateral\n            return (1, remainingCollateral);\n        }\n\n        if (remainingCollateral < marginFees.add(liquidationFeeUsd)) {\n            if (_raise) {\n                revert(\"Vault: liquidation fees exceed collateral\");\n            }\n            return (1, marginFees);\n        }\n\n        if (\n            remainingCollateral.mul(maxLeverage) <\n            position.size.mul(BASIS_POINTS_DIVISOR)\n        ) {\n            if (_raise) {\n                revert(\"Vault: maxLeverage exceeded\");\n            }\n            return (2, marginFees);\n        }\n\n        return (0, marginFees);\n    }\n\n    function getMaxPrice(address _token)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            IVaultPriceFeed(priceFeed).getPrice(_token, true, includeAmmPrice);\n    }\n\n    function getMinPrice(address _token)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            IVaultPriceFeed(priceFeed).getPrice(_token, false, includeAmmPrice);\n    }\n\n    function getRedemptionAmount(address _token, uint256 _nusdAmount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 price = getMaxPrice(_token);\n        uint256 priceBasedAmount = _nusdAmount.mul(PRICE_PRECISION).div(price);\n        priceBasedAmount = adjustForDecimals(priceBasedAmount, nusd, _token);\n\n        uint256 redemptionCollateral = getRedemptionCollateral(_token);\n        if (redemptionCollateral == 0) {\n            return 0;\n        }\n\n        uint256 totalNUSDAmount = nusdAmounts[_token];\n\n        // if there is no NUSD debt then the redemption amount based just on price can be supported\n        if (totalNUSDAmount == 0) {\n            return priceBasedAmount;\n        }\n\n        // calculate the collateralBasedAmount from the amount of backing collateral and the\n        // total debt in NUSD tokens for the asset\n        uint256 collateralBasedAmount = _nusdAmount\n            .mul(redemptionCollateral)\n            .div(totalNUSDAmount);\n        uint256 basisPoints = getRedemptionBasisPoints(_token);\n        collateralBasedAmount = collateralBasedAmount.mul(basisPoints).div(\n            BASIS_POINTS_DIVISOR\n        );\n\n        return\n            collateralBasedAmount < priceBasedAmount\n                ? collateralBasedAmount\n                : priceBasedAmount;\n    }\n\n    function getRedemptionCollateral(address _token)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 collateral = usdToTokenMin(_token, guaranteedUsd[_token]);\n        return collateral.add(poolAmounts[_token]).sub(reservedAmounts[_token]);\n    }\n\n    function getRedemptionCollateralUsd(address _token)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return tokenToUsdMin(_token, getRedemptionCollateral(_token));\n    }\n\n    function getRedemptionBasisPoints(address _token)\n        public\n        view\n        returns (uint256)\n    {\n        return redemptionBasisPoints[_token];\n    }\n\n    function adjustForDecimals(\n        uint256 _amount,\n        address _tokenDiv,\n        address _tokenMul\n    ) public view override returns (uint256) {\n        uint256 decimalsDiv = _tokenDiv == nusd\n            ? NUSD_DECIMALS\n            : tokenDecimals[_tokenDiv];\n        uint256 decimalsMul = _tokenMul == nusd\n            ? NUSD_DECIMALS\n            : tokenDecimals[_tokenMul];\n        return _amount.mul(10**decimalsMul).div(10**decimalsDiv);\n    }\n\n    function availableReserve(address _token) public view returns (uint256) {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        return balance.sub(reservedAmounts[_token]);\n    }\n\n    function tokenToUsdMax(address _token, uint256 _tokenAmount)\n        public\n        view\n        returns (uint256)\n    {\n        if (_tokenAmount == 0) {\n            return 0;\n        }\n        uint256 price = getMaxPrice(_token);\n        uint256 decimals = tokenDecimals[_token];\n        return _tokenAmount.mul(price).div(10**decimals);\n    }\n\n    function tokenToUsdMin(address _token, uint256 _tokenAmount)\n        public\n        view\n        returns (uint256)\n    {\n        if (_tokenAmount == 0) {\n            return 0;\n        }\n        uint256 price = getMinPrice(_token);\n        uint256 decimals = tokenDecimals[_token];\n        return _tokenAmount.mul(price).div(10**decimals);\n    }\n\n    function usdToTokenMax(address _token, uint256 _usdAmount)\n        public\n        view\n        returns (uint256)\n    {\n        if (_usdAmount == 0) {\n            return 0;\n        }\n        return usdToToken(_token, _usdAmount, getMinPrice(_token));\n    }\n\n    function usdToTokenMin(address _token, uint256 _usdAmount)\n        public\n        view\n        returns (uint256)\n    {\n        if (_usdAmount == 0) {\n            return 0;\n        }\n        return usdToToken(_token, _usdAmount, getMaxPrice(_token));\n    }\n\n    function usdToToken(\n        address _token,\n        uint256 _usdAmount,\n        uint256 _price\n    ) public view returns (uint256) {\n        if (_usdAmount == 0) {\n            return 0;\n        }\n        uint256 decimals = tokenDecimals[_token];\n        return _usdAmount.mul(10**decimals).div(_price);\n    }\n\n    function getPosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    )\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256\n        )\n    {\n        bytes32 key = getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        Position memory position = positions[key];\n        uint256 realisedPnl = position.realisedPnl > 0\n            ? uint256(position.realisedPnl)\n            : uint256(-position.realisedPnl);\n        return (\n            position.size, // 0\n            position.collateral, // 1\n            position.averagePrice, // 2\n            position.entryFundingRate, // 3\n            position.reserveAmount, // 4\n            realisedPnl, // 5\n            position.realisedPnl >= 0, // 6\n            position.lastIncreasedTime // 7\n        );\n    }\n\n    function getPositionKey(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) public pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    _account,\n                    _collateralToken,\n                    _indexToken,\n                    _isLong\n                )\n            );\n    }\n\n    function updateCumulativeFundingRate(address _token) public {\n        if (lastFundingTimes[_token] == 0) {\n            lastFundingTimes[_token] = block.timestamp.div(fundingInterval).mul(\n                fundingInterval\n            );\n            return;\n        }\n\n        if (lastFundingTimes[_token].add(fundingInterval) > block.timestamp) {\n            return;\n        }\n\n        uint256 fundingRate = getNextFundingRate(_token);\n        cumulativeFundingRates[_token] = cumulativeFundingRates[_token].add(\n            fundingRate\n        );\n        lastFundingTimes[_token] = block.timestamp.div(fundingInterval).mul(\n            fundingInterval\n        );\n\n        emit UpdateFundingRate(_token, cumulativeFundingRates[_token]);\n    }\n\n    function getNextFundingRate(address _token)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (lastFundingTimes[_token].add(fundingInterval) > block.timestamp) {\n            return 0;\n        }\n\n        uint256 intervals = block.timestamp.sub(lastFundingTimes[_token]).div(\n            fundingInterval\n        );\n        uint256 poolAmount = poolAmounts[_token];\n        if (poolAmount == 0) {\n            return 0;\n        }\n\n        return\n            fundingRateFactor.mul(reservedAmounts[_token]).mul(intervals).div(\n                poolAmount\n            );\n    }\n\n    function getUtilisation(address _token)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 poolAmount = poolAmounts[_token];\n        if (poolAmount == 0) {\n            return 0;\n        }\n\n        return\n            reservedAmounts[_token].mul(FUNDING_RATE_PRECISION).div(poolAmount);\n    }\n\n    function getPositionLeverage(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) public view returns (uint256) {\n        bytes32 key = getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        Position memory position = positions[key];\n        require(position.collateral > 0, \"Vault: invalid position\");\n        return position.size.mul(BASIS_POINTS_DIVISOR).div(position.collateral);\n    }\n\n    // for longs: nextAveragePrice = (nextPrice * nextSize)/ (nextSize + delta)\n    // for shorts: nextAveragePrice = (nextPrice * nextSize) / (nextSize - delta)\n    function getNextAveragePrice(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _nextPrice,\n        uint256 _sizeDelta,\n        uint256 _lastIncreasedTime\n    ) public view returns (uint256) {\n        (bool hasProfit, uint256 delta) = getDelta(\n            _indexToken,\n            _size,\n            _averagePrice,\n            _isLong,\n            _lastIncreasedTime\n        );\n        uint256 nextSize = _size.add(_sizeDelta);\n        uint256 divisor;\n        if (_isLong) {\n            divisor = hasProfit ? nextSize.add(delta) : nextSize.sub(delta);\n        } else {\n            divisor = hasProfit ? nextSize.sub(delta) : nextSize.add(delta);\n        }\n        return _nextPrice.mul(nextSize).div(divisor);\n    }\n\n    function getPositionDelta(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) public view returns (bool, uint256) {\n        bytes32 key = getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        Position memory position = positions[key];\n        return\n            getDelta(\n                _indexToken,\n                position.size,\n                position.averagePrice,\n                _isLong,\n                position.lastIncreasedTime\n            );\n    }\n\n    function getDelta(\n        address _indexToken,\n        uint256 _size,\n        uint256 _averagePrice,\n        bool _isLong,\n        uint256 _lastIncreasedTime\n    ) public view override returns (bool, uint256) {\n        require(_averagePrice > 0, \"Vault: invalid _averagePrice\");\n        uint256 price = _isLong\n            ? getMinPrice(_indexToken)\n            : getMaxPrice(_indexToken);\n        uint256 priceDelta = _averagePrice > price\n            ? _averagePrice.sub(price)\n            : price.sub(_averagePrice);\n        uint256 delta = _size.mul(priceDelta).div(_averagePrice);\n\n        bool hasProfit;\n\n        if (_isLong) {\n            hasProfit = price > _averagePrice;\n        } else {\n            hasProfit = _averagePrice > price;\n        }\n\n        // if the minProfitTime has passed then there will be no min profit threshold\n        // the min profit threshold helps to prevent front-running issues\n        uint256 minBps = block.timestamp > _lastIncreasedTime.add(minProfitTime)\n            ? 0\n            : minProfitBasisPoints[_indexToken];\n        if (hasProfit && delta.mul(BASIS_POINTS_DIVISOR) <= _size.mul(minBps)) {\n            delta = 0;\n        }\n\n        return (hasProfit, delta);\n    }\n\n    function getFundingFee(\n        address _token,\n        uint256 _size,\n        uint256 _entryFundingRate\n    ) public view returns (uint256) {\n        if (_size == 0) {\n            return 0;\n        }\n\n        uint256 fundingRate = cumulativeFundingRates[_token].sub(\n            _entryFundingRate\n        );\n        if (fundingRate == 0) {\n            return 0;\n        }\n\n        return _size.mul(fundingRate).div(FUNDING_RATE_PRECISION);\n    }\n\n    function getPositionFee(uint256 _sizeDelta) public view returns (uint256) {\n        if (_sizeDelta == 0) {\n            return 0;\n        }\n        uint256 afterFeeUsd = _sizeDelta\n            .mul(BASIS_POINTS_DIVISOR.sub(marginFeeBasisPoints))\n            .div(BASIS_POINTS_DIVISOR);\n        return _sizeDelta.sub(afterFeeUsd);\n    }\n\n    function getMaxNUSDAmount() public view returns (uint256) {\n        uint256 supply = IERC20(nusd).totalSupply();\n        uint256 bufferredSupply = supply.add(maxNUSDBuffer);\n        uint256 max = bufferredSupply.div(maxNUSDBatchSize).mul(\n            maxNUSDBatchSize\n        );\n        max = max.add(maxNUSDBatchSize);\n        return max.div(whitelistedTokenCount);\n    }\n\n    function _reduceCollateral(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong\n    ) private returns (uint256, uint256) {\n        bytes32 key = getPositionKey(\n            _account,\n            _collateralToken,\n            _indexToken,\n            _isLong\n        );\n        Position storage position = positions[key];\n\n        uint256 fee = _collectMarginFees(\n            _collateralToken,\n            _sizeDelta,\n            position.size,\n            position.entryFundingRate\n        );\n        bool hasProfit;\n        uint256 adjustedDelta;\n\n        // scope variables to avoid stack too deep errors\n        {\n            (bool _hasProfit, uint256 delta) = getDelta(\n                _indexToken,\n                position.size,\n                position.averagePrice,\n                _isLong,\n                position.lastIncreasedTime\n            );\n            hasProfit = _hasProfit;\n            // get the proportional change in pnl\n            adjustedDelta = _sizeDelta.mul(delta).div(position.size);\n        }\n\n        uint256 usdOut;\n        // transfer profits out\n        if (hasProfit && adjustedDelta > 0) {\n            usdOut = adjustedDelta;\n            position.realisedPnl = position.realisedPnl + int256(adjustedDelta);\n        }\n\n        if (!hasProfit && adjustedDelta > 0) {\n            position.collateral = position.collateral.sub(adjustedDelta);\n            position.realisedPnl = position.realisedPnl - int256(adjustedDelta);\n        }\n\n        // reduce the position's collateral by _collateralDelta\n        // transfer _collateralDelta out\n        if (_collateralDelta > 0) {\n            usdOut = usdOut.add(_collateralDelta);\n            position.collateral = position.collateral.sub(_collateralDelta);\n        }\n\n        // if the position will be closed, then transfer the remaining collateral out\n        if (position.size == _sizeDelta) {\n            usdOut = usdOut.add(position.collateral);\n            position.collateral = 0;\n        }\n\n        // if the usdOut is more than the fee then deduct the fee from the usdOut directly\n        // else deduct the fee from the position's collateral\n        uint256 usdOutAfterFee = usdOut;\n        if (usdOut > fee) {\n            usdOutAfterFee = usdOut.sub(fee);\n        } else {\n            position.collateral = position.collateral.sub(fee);\n            uint256 feeTokens = usdToTokenMin(_collateralToken, fee);\n            _decreasePoolAmount(_collateralToken, feeTokens);\n        }\n\n        emit UpdatePnl(key, hasProfit, adjustedDelta);\n\n        return (usdOut, usdOutAfterFee);\n    }\n\n    function _validatePosition(uint256 _size, uint256 _collateral)\n        private\n        pure\n    {\n        if (_size == 0) {\n            require(_collateral == 0, \"Vault: collateral should be withdrawn\");\n            return;\n        }\n        require(\n            _size >= _collateral,\n            \"Vault: _size must be more than _collateral\"\n        );\n    }\n\n    function _validateRouter(address _account) private view {\n        if (msg.sender == _account) {\n            return;\n        }\n        if (msg.sender == router) {\n            return;\n        }\n        require(\n            approvedRouters[_account][msg.sender],\n            \"Vault: invalid msg.sender\"\n        );\n    }\n\n    function _validateTokens(address _collateralToken, address _indexToken)\n        private\n        view\n    {\n        require(_collateralToken == _indexToken, \"Vault: mismatched tokens\");\n        require(\n            whitelistedTokens[_collateralToken],\n            \"Vault: _collateralToken not whitelisted\"\n        );\n        require(\n            shortableTokens[_indexToken],\n            \"Vault: _indexToken not shortable\"\n        );\n    }\n\n    function _collectSwapFees(address _token, uint256 _amount)\n        private\n        returns (uint256)\n    {\n        uint256 feeBasisPoints = swapFeeBasisPoints;\n        uint256 afterFeeAmount = _amount\n            .mul(BASIS_POINTS_DIVISOR.sub(feeBasisPoints))\n            .div(BASIS_POINTS_DIVISOR);\n        uint256 feeAmount = _amount.sub(afterFeeAmount);\n        feeReserves[_token] = feeReserves[_token].add(feeAmount);\n        emit CollectSwapFees(\n            _token,\n            tokenToUsdMin(_token, feeAmount),\n            feeAmount\n        );\n        return afterFeeAmount;\n    }\n\n    function _collectMarginFees(\n        address _token,\n        uint256 _sizeDelta,\n        uint256 _size,\n        uint256 _entryFundingRate\n    ) private returns (uint256) {\n        uint256 feeUsd = getPositionFee(_sizeDelta);\n\n        uint256 fundingFee = getFundingFee(_token, _size, _entryFundingRate);\n        feeUsd = feeUsd.add(fundingFee);\n\n        uint256 feeTokens = usdToTokenMin(_token, feeUsd);\n        feeReserves[_token] = feeReserves[_token].add(feeTokens);\n\n        emit CollectMarginFees(_token, feeUsd, feeTokens);\n        return feeUsd;\n    }\n\n    function _transferIn(address _token) private returns (uint256) {\n        uint256 prevBalance = tokenBalances[_token];\n        uint256 nextBalance = IERC20(_token).balanceOf(address(this));\n        tokenBalances[_token] = nextBalance;\n\n        return nextBalance.sub(prevBalance);\n    }\n\n    function _transferOut(\n        address _token,\n        uint256 _amount,\n        address _receiver\n    ) private {\n        IERC20(_token).safeTransfer(_receiver, _amount);\n        tokenBalances[_token] = IERC20(_token).balanceOf(address(this));\n    }\n\n    function _updateTokenBalance(address _token) private {\n        uint256 nextBalance = IERC20(_token).balanceOf(address(this));\n        tokenBalances[_token] = nextBalance;\n    }\n\n    function _increasePoolAmount(address _token, uint256 _amount) private {\n        poolAmounts[_token] = poolAmounts[_token].add(_amount);\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        require(poolAmounts[_token] <= balance, \"Vault: invalid increase\");\n        emit IncreasePoolAmount(_token, _amount);\n    }\n\n    function _decreasePoolAmount(address _token, uint256 _amount) private {\n        poolAmounts[_token] = poolAmounts[_token].sub(\n            _amount,\n            \"Vault: poolAmount exceeded\"\n        );\n        require(\n            reservedAmounts[_token] <= poolAmounts[_token],\n            \"Vault: reserve exceeds pool\"\n        );\n        emit DecreasePoolAmount(_token, _amount);\n    }\n\n    function _increaseNUSDAmount(address _token, uint256 _amount) private {\n        nusdAmounts[_token] = nusdAmounts[_token].add(_amount);\n        require(\n            nusdAmounts[_token] <= getMaxNUSDAmount(),\n            \"Vault: max NUSD exceeded\"\n        );\n        emit IncreaseNUSDAmount(_token, _amount);\n    }\n\n    function _decreaseNUSDAmount(address _token, uint256 _amount) private {\n        uint256 value = nusdAmounts[_token];\n        // since NUSD can be minted using multiple assets\n        // it is possible for the NUSD debt for a single asset to be less than zero\n        // the NUSD debt is capped to zero for this case\n        if (value <= _amount) {\n            nusdAmounts[_token] = 0;\n            emit DecreaseNUSDAmount(_token, value);\n            return;\n        }\n        nusdAmounts[_token] = value.sub(_amount);\n        emit DecreaseNUSDAmount(_token, _amount);\n    }\n\n    function _increaseReservedAmount(address _token, uint256 _amount) private {\n        reservedAmounts[_token] = reservedAmounts[_token].add(_amount);\n        require(\n            reservedAmounts[_token] <= poolAmounts[_token],\n            \"Vault: reserve exceeds pool\"\n        );\n        emit IncreaseReservedAmount(_token, _amount);\n    }\n\n    function _decreaseReservedAmount(address _token, uint256 _amount) private {\n        reservedAmounts[_token] = reservedAmounts[_token].sub(\n            _amount,\n            \"Vault: insufficient reserve\"\n        );\n        emit DecreaseReservedAmount(_token, _amount);\n    }\n\n    function _increaseGuaranteedUsd(address _token, uint256 _usdAmount)\n        private\n    {\n        guaranteedUsd[_token] = guaranteedUsd[_token].add(_usdAmount);\n        emit IncreaseGuaranteedUsd(_token, _usdAmount);\n    }\n\n    function _decreaseGuaranteedUsd(address _token, uint256 _usdAmount)\n        private\n    {\n        guaranteedUsd[_token] = guaranteedUsd[_token].sub(_usdAmount);\n        emit DecreaseGuaranteedUsd(_token, _usdAmount);\n    }\n\n    // we have this validation as a function instead of a modifier to reduce contract size\n    function _onlyGov() private view {\n        require(msg.sender == gov, \"Vault: forbidden\");\n    }\n}\n"
    },
    "contracts/core/VaultPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IVaultPriceFeed.sol\";\nimport \"../oracle/interfaces/IPriceFeed.sol\";\nimport \"../oracle/interfaces/ISecondaryPriceFeed.sol\";\nimport \"../amm/interfaces/IUniswapV2Pair.sol\";\n\npragma experimental ABIEncoderV2;\n\ncontract VaultPriceFeed is IVaultPriceFeed {\n    using SafeMath for uint256;\n\n    uint256 public constant PRICE_PRECISION = 10**30;\n    uint256 public constant SECONDARY_PRICE_PRECISION = 10**18;\n    uint256 public constant ONE_USD = PRICE_PRECISION;\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant MAX_SPREAD_BASIS_POINTS = 50;\n\n    address public gov;\n    bool public isAmmEnabled = true;\n    bool public isSecondaryPriceEnabled = true;\n    bool public favorPrimaryPrice = false;\n    uint256 public priceSampleSpace = 3;\n    uint256 public maxStrictPriceDeviation = 0;\n    address public secondaryPriceFeed;\n    uint256 public spreadThresholdBasisPoints = 30;\n\n    address public btc;\n    address public eth;\n    address public ethUsdc;\n    address public btcUsdc;\n\n    mapping(address => address) public priceFeeds;\n    mapping(address => uint256) public priceDecimals;\n    mapping(address => uint256) public spreadBasisPoints;\n    // Chainlink can return prices for stablecoins\n    // that differs from 1 USD by a larger percentage than stableSwapFeeBasisPoints\n    // we use strictStableTokens to cap the price to 1 USD\n    // this allows us to configure stablecoins like DAI as being a stableToken\n    // while not being a strictStableToken\n    mapping(address => bool) public strictStableTokens;\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"VaultPriceFeed: forbidden\");\n        _;\n    }\n\n    constructor() {\n        gov = msg.sender;\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice)\n        external\n        override\n        onlyGov\n    {\n        favorPrimaryPrice = _favorPrimaryPrice;\n    }\n\n    function setIsAmmEnabled(bool _isEnabled) external override onlyGov {\n        isAmmEnabled = _isEnabled;\n    }\n\n    function setIsSecondaryPriceEnabled(bool _isEnabled)\n        external\n        override\n        onlyGov\n    {\n        isSecondaryPriceEnabled = _isEnabled;\n    }\n\n    function setSecondaryPriceFeed(address _secondaryPriceFeed)\n        external\n        onlyGov\n    {\n        secondaryPriceFeed = _secondaryPriceFeed;\n    }\n\n    function setTokens(address _btc, address _eth) external onlyGov {\n        btc = _btc;\n        eth = _eth;\n    }\n\n    function setPairs(address _btcUsdc, address _ethUsdc) external onlyGov {\n        btcUsdc = _btcUsdc;\n        ethUsdc = _ethUsdc;\n    }\n\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints)\n        external\n        override\n        onlyGov\n    {\n        require(\n            _spreadBasisPoints <= MAX_SPREAD_BASIS_POINTS,\n            \"VaultPriceFeed: invalid _spreadBasisPoints\"\n        );\n        spreadBasisPoints[_token] = _spreadBasisPoints;\n    }\n\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints)\n        external\n        override\n        onlyGov\n    {\n        spreadThresholdBasisPoints = _spreadThresholdBasisPoints;\n    }\n\n    function setPriceSampleSpace(uint256 _priceSampleSpace)\n        external\n        override\n        onlyGov\n    {\n        require(\n            _priceSampleSpace > 0,\n            \"VaultPriceFeed: invalid _priceSampleSpace\"\n        );\n        priceSampleSpace = _priceSampleSpace;\n    }\n\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation)\n        external\n        override\n        onlyGov\n    {\n        maxStrictPriceDeviation = _maxStrictPriceDeviation;\n    }\n\n    function setVaultPriceFeedTokenConfig(\n        address _token,\n        address _priceFeed,\n        uint256 _priceDecimals,\n        bool _isStrictStable\n    ) external onlyGov {\n        priceFeeds[_token] = _priceFeed;\n        priceDecimals[_token] = _priceDecimals;\n        strictStableTokens[_token] = _isStrictStable;\n    }\n\n    function getPrice(\n        address _token,\n        bool _maximise,\n        bool _includeAmmPrice\n    ) public view override returns (uint256) {\n        uint256 price = getPrimaryPrice(_token, _maximise);\n\n        if (_includeAmmPrice && isAmmEnabled) {\n            price = getAmmPriceV2(_token, _maximise, price);\n        }\n\n        if (isSecondaryPriceEnabled) {\n            uint256 secondaryPrice = getSecondaryPrice(_token);\n            if (secondaryPrice > 0) {\n                if (_maximise && secondaryPrice > price) {\n                    price = secondaryPrice;\n                }\n                if (!_maximise && secondaryPrice < price) {\n                    price = secondaryPrice;\n                }\n            }\n        }\n\n        if (strictStableTokens[_token]) {\n            uint256 delta = price > ONE_USD\n                ? price.sub(ONE_USD)\n                : ONE_USD.sub(price);\n            if (delta <= maxStrictPriceDeviation) {\n                return ONE_USD;\n            }\n        }\n\n        uint256 _spreadBasisPoints = spreadBasisPoints[_token];\n\n        if (_maximise) {\n            return\n                price.mul(BASIS_POINTS_DIVISOR.add(_spreadBasisPoints)).div(\n                    BASIS_POINTS_DIVISOR\n                );\n        }\n\n        return\n            price.mul(BASIS_POINTS_DIVISOR.sub(_spreadBasisPoints)).div(\n                BASIS_POINTS_DIVISOR\n            );\n    }\n\n    function getAmmPriceV2(\n        address _token,\n        bool _maximise,\n        uint256 _primaryPrice\n    ) public view returns (uint256) {\n        uint256 ammPrice = getAmmPrice(_token);\n        if (ammPrice == 0) {\n            return _primaryPrice;\n        }\n\n        uint256 diff = ammPrice > _primaryPrice\n            ? ammPrice.sub(_primaryPrice)\n            : _primaryPrice.sub(ammPrice);\n        if (\n            diff.mul(BASIS_POINTS_DIVISOR) <\n            _primaryPrice.mul(spreadThresholdBasisPoints)\n        ) {\n            if (favorPrimaryPrice) {\n                return _primaryPrice;\n            }\n            return ammPrice;\n        }\n\n        if (_maximise && ammPrice > _primaryPrice) {\n            return ammPrice;\n        }\n\n        if (!_maximise && ammPrice < _primaryPrice) {\n            return ammPrice;\n        }\n\n        return _primaryPrice;\n    }\n\n    function getPrimaryPrice(address _token, bool _maximise)\n        public\n        view\n        returns (uint256)\n    {\n        address priceFeedAddress = priceFeeds[_token];\n        require(\n            priceFeedAddress != address(0),\n            \"VaultPriceFeed: invalid price feed\"\n        );\n        IPriceFeed priceFeed = IPriceFeed(priceFeedAddress);\n\n        uint256 price = 0;\n        uint80 roundId = priceFeed.latestRound();\n\n        for (uint80 i = 0; i < priceSampleSpace; i++) {\n            if (roundId <= i) {\n                break;\n            }\n            uint256 p;\n\n            if (i == 0) {\n                int256 _p = priceFeed.latestAnswer();\n                require(_p > 0, \"VaultPriceFeed: invalid price\");\n                p = uint256(_p);\n            } else {\n                (, int256 _p, , , ) = priceFeed.getRoundData(roundId - i);\n                require(_p > 0, \"VaultPriceFeed: invalid price\");\n                p = uint256(_p);\n            }\n\n            if (price == 0) {\n                price = p;\n                continue;\n            }\n\n            if (_maximise && p > price) {\n                price = p;\n                continue;\n            }\n\n            if (!_maximise && p < price) {\n                price = p;\n            }\n        }\n\n        require(price > 0, \"VaultPriceFeed: could not fetch price\");\n        // normalise price precision\n        uint256 _priceDecimals = priceDecimals[_token];\n        return price.mul(PRICE_PRECISION).div(10**_priceDecimals);\n    }\n\n    function getSecondaryPrice(address _token) public view returns (uint256) {\n        if (_token == btc) {\n            return getSecondaryPriceFromSymbol(\"BTC\");\n        }\n        if (_token == eth) {\n            return getSecondaryPriceFromSymbol(\"ETH\");\n        }\n        return 0;\n    }\n\n    function getSecondaryPriceFromSymbol(string memory _symbol)\n        public\n        view\n        returns (uint256)\n    {\n        if (secondaryPriceFeed == address(0)) {\n            return 0;\n        }\n\n        ISecondaryPriceFeed.ReferenceData memory data = ISecondaryPriceFeed(\n            secondaryPriceFeed\n        ).getReferenceData(_symbol, \"USD\");\n        return data.rate.mul(PRICE_PRECISION).div(SECONDARY_PRICE_PRECISION);\n    }\n\n    function getAmmPrice(address _token)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (_token == btc) {\n            // for btcUsdc, reserve0: BTC, reserve1: USDC\n            return getPairPrice(btcUsdc, true);\n        }\n\n        if (_token == eth) {\n            // for ethUsdc, reserve0: ETH, reserve1: USDC\n            return getPairPrice(ethUsdc, true);\n        }\n\n        return 0;\n    }\n\n    // if divByReserve0: calculate price as reserve1 / reserve0\n    // if !divByReserve1: calculate price as reserve0 / reserve1\n    function getPairPrice(address _pair, bool _divByReserve0)\n        public\n        view\n        returns (uint256)\n    {\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_pair)\n            .getReserves();\n        if (_divByReserve0) {\n            if (reserve0 == 0) {\n                return 0;\n            }\n            return reserve1.mul(PRICE_PRECISION).div(reserve0);\n        }\n        if (reserve1 == 0) {\n            return 0;\n        }\n        return reserve0.mul(PRICE_PRECISION).div(reserve1);\n    }\n}\n"
    },
    "contracts/oracle/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IPriceFeed {\n    function description() external view returns (string memory);\n\n    function aggregator() external view returns (address);\n\n    function latestAnswer() external view returns (int256);\n\n    function latestRound() external view returns (uint80);\n\n    function getRoundData(uint80 roundId)\n        external\n        view\n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        );\n}\n"
    },
    "contracts/oracle/interfaces/ISecondaryPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\ninterface ISecondaryPriceFeed {\n    struct ReferenceData {\n        uint256 rate; // base/quote exchange rate, multiplied by 1e18.\n        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\n        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\n    }\n\n    // Returns the price data for the given base/quote pair. Revert if not available.\n    function getReferenceData(string memory _base, string memory _quote)\n        external\n        view\n        returns (ReferenceData memory);\n}\n"
    },
    "contracts/oracle/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"./interfaces/IPriceFeed.sol\";\n\ncontract PriceFeed is IPriceFeed {\n    int256 public answer;\n    uint80 public roundId;\n    string public override description = \"PriceFeed\";\n    address public override aggregator;\n\n    address public gov;\n\n    mapping(uint80 => int256) answers;\n\n    constructor() {\n        gov = msg.sender;\n    }\n\n    function latestAnswer() public view override returns (int256) {\n        return answer;\n    }\n\n    function latestRound() public view override returns (uint80) {\n        return roundId;\n    }\n\n    function setLatestAnswer(int256 _answer) public {\n        require(msg.sender == gov, \"PriceFeed: forbidden\");\n        roundId = roundId + 1;\n        answer = _answer;\n        answers[roundId] = _answer;\n    }\n\n    // returns roundId, answer, startedAt, updatedAt, answeredInRound\n    function getRoundData(uint80 _roundId)\n        public\n        view\n        override\n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        )\n    {\n        return (_roundId, answers[_roundId], 0, 0, 0);\n    }\n}\n"
    },
    "contracts/tokens/NUSD/NUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"../interfaces/INUSD.sol\";\nimport \"./YieldToken.sol\";\n\ncontract NUSD is YieldToken, INUSD {\n    mapping(address => bool) public vaults;\n\n    modifier onlyVault() {\n        require(vaults[msg.sender], \"NUSD: forbidden\");\n        _;\n    }\n\n    constructor(address _vault) YieldToken(\"Necc USD\", \"NUSD\", 0) {\n        vaults[_vault] = true;\n    }\n\n    function addVault(address _vault) external onlyGov {\n        vaults[_vault] = true;\n    }\n\n    function removeVault(address _vault) external onlyGov {\n        vaults[_vault] = false;\n    }\n\n    function mint(address _account, uint256 _amount)\n        external\n        override\n        onlyVault\n    {\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount)\n        external\n        override\n        onlyVault\n    {\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/tokens/Necc/Distributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ITreasury.sol\";\n\nimport \"./types/Governable.sol\";\nimport \"./types/Guardable.sol\";\n\ninterface IPolicy {\n    function policy() external view returns (address);\n\n    function renouncePolicy() external;\n\n    function pushPolicy(address newPolicy_) external;\n\n    function pullPolicy() external;\n}\n\ncontract Policy is IPolicy {\n    address internal _policy;\n    address internal _newPolicy;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _policy = msg.sender;\n        emit OwnershipTransferred(address(0), _policy);\n    }\n\n    function policy() public view override returns (address) {\n        return _policy;\n    }\n\n    modifier onlyPolicy() {\n        require(_policy == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renouncePolicy() public virtual override onlyPolicy {\n        emit OwnershipTransferred(_policy, address(0));\n        _policy = address(0);\n    }\n\n    function pushPolicy(address newPolicy_) public virtual override onlyPolicy {\n        require(\n            newPolicy_ != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _newPolicy = newPolicy_;\n    }\n\n    function pullPolicy() public virtual override {\n        require(msg.sender == _newPolicy);\n        emit OwnershipTransferred(_policy, _newPolicy);\n        _policy = _newPolicy;\n    }\n}\n\ncontract Distributor is Policy {\n    /* ========== DEPENDENCIES ========== */\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ====== VARIABLES ====== */\n\n    IERC20 immutable Necc;\n    ITreasury immutable treasury;\n\n    uint256 public immutable epochLength;\n    uint256 public nextEpochBlock;\n\n    mapping(uint256 => Adjust) public adjustments;\n\n    /* ====== STRUCTS ====== */\n\n    struct Info {\n        uint256 rate; // in ten-thousandths ( 5000 = 0.5% )\n        address recipient;\n    }\n    Info[] public info;\n\n    struct Adjust {\n        bool add;\n        uint256 rate;\n        uint256 target;\n    }\n\n    /* ====== CONSTRUCTOR ====== */\n\n    constructor(\n        address _treasury,\n        address _necc,\n        uint256 _epochLength,\n        uint256 _nextEpochBlock\n    ) {\n        require(_treasury != address(0));\n        treasury = ITreasury(_treasury);\n        require(_necc != address(0));\n        Necc = IERC20(_necc);\n        epochLength = _epochLength;\n        nextEpochBlock = _nextEpochBlock;\n    }\n\n    /* ====== PUBLIC FUNCTIONS ====== */\n\n    /**\n        @notice send epoch reward to staking contract\n     */\n    function distribute() external returns (bool) {\n        if (nextEpochBlock <= block.number) {\n            nextEpochBlock = nextEpochBlock.add(epochLength); // set next epoch block\n\n            // distribute rewards to each recipient\n            for (uint256 i = 0; i < info.length; i++) {\n                if (info[i].rate > 0) {\n                    treasury.mintRewards( // mint and send from treasury\n                        info[i].recipient,\n                        nextRewardAt(info[i].rate)\n                    );\n                    adjust(i); // check for adjustment\n                }\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /* ====== INTERNAL FUNCTIONS ====== */\n\n    /**\n        @notice increment reward rate for collector\n     */\n    function adjust(uint256 _index) internal {\n        Adjust memory adjustment = adjustments[_index];\n        if (adjustment.rate != 0) {\n            if (adjustment.add) {\n                // if rate should increase\n                info[_index].rate = info[_index].rate.add(adjustment.rate); // raise rate\n                if (info[_index].rate >= adjustment.target) {\n                    // if target met\n                    adjustments[_index].rate = 0; // turn off adjustment\n                }\n            } else {\n                // if rate should decrease\n                info[_index].rate = info[_index].rate.sub(adjustment.rate); // lower rate\n                if (info[_index].rate <= adjustment.target) {\n                    // if target met\n                    adjustments[_index].rate = 0; // turn off adjustment\n                }\n            }\n        }\n    }\n\n    /* ====== VIEW FUNCTIONS ====== */\n\n    /**\n        @notice view function for next reward at given rate\n        @param _rate uint\n        @return uint\n     */\n    function nextRewardAt(uint256 _rate) public view returns (uint256) {\n        return IERC20(Necc).totalSupply().mul(_rate).div(1000000);\n    }\n\n    /**\n        @notice view function for next reward for specified address\n        @param _recipient address\n        @return uint\n     */\n    function nextRewardFor(address _recipient) public view returns (uint256) {\n        uint256 reward;\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].recipient == _recipient) {\n                reward = nextRewardAt(info[i].rate);\n            }\n        }\n        return reward;\n    }\n\n    /* ====== POLICY FUNCTIONS ====== */\n\n    /**\n        @notice adds recipient for distributions\n        @param _recipient address\n        @param _rewardRate uint\n     */\n    function addRecipient(address _recipient, uint256 _rewardRate)\n        external\n        onlyPolicy\n    {\n        require(_recipient != address(0));\n        info.push(Info({recipient: _recipient, rate: _rewardRate}));\n    }\n\n    /**\n        @notice removes recipient for distributions\n        @param _index uint\n        @param _recipient address\n     */\n    function removeRecipient(uint256 _index, address _recipient)\n        external\n        onlyPolicy\n    {\n        require(_recipient == info[_index].recipient);\n        info[_index].recipient = address(0);\n        info[_index].rate = 0;\n    }\n\n    /**\n        @notice set adjustment info for a collector's reward rate\n        @param _index uint\n        @param _add bool\n        @param _rate uint\n        @param _target uint\n     */\n    function setAdjustment(\n        uint256 _index,\n        bool _add,\n        uint256 _rate,\n        uint256 _target\n    ) external onlyPolicy {\n        adjustments[_index] = Adjust({add: _add, rate: _rate, target: _target});\n    }\n}\n"
    },
    "contracts/tokens/Necc/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (bool);\n\n    function valueOf(address _token, uint256 _amount)\n        external\n        view\n        returns (uint256 value_);\n\n    function mintRewards(address _recipient, uint256 _amount) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n}\n"
    },
    "contracts/tokens/Necc/types/Governable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ncontract Governable {\n    address internal _governor;\n    address internal _newGovernor;\n\n    event GovernorPushed(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n    event GovernorPulled(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    constructor() {\n        _governor = msg.sender;\n        emit GovernorPulled(address(0), _governor);\n    }\n\n    /* ========== GOVERNOR ========== */\n\n    function governor() public view returns (address) {\n        return _governor;\n    }\n\n    modifier onlyGovernor() {\n        require(\n            _governor == msg.sender,\n            \"Governable: caller is not the governor\"\n        );\n        _;\n    }\n\n    function renounceGovernor() public virtual onlyGovernor {\n        emit GovernorPushed(_governor, address(0));\n        _governor = address(0);\n    }\n\n    function pushGovernor(address newGovernor_) public virtual onlyGovernor {\n        require(\n            newGovernor_ != address(0),\n            \"Governable: new governor is the zero address\"\n        );\n        emit GovernorPushed(_governor, newGovernor_);\n        _newGovernor = newGovernor_;\n    }\n\n    function pullGovernor() public virtual {\n        require(\n            msg.sender == _newGovernor,\n            \"Governable: must be new governor to pull\"\n        );\n        emit GovernorPulled(_governor, _newGovernor);\n        _governor = _newGovernor;\n    }\n}\n"
    },
    "contracts/tokens/Necc/types/Guardable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ncontract Guardable {\n    address internal _guardian;\n    address internal _newGuardian;\n\n    event GuardianPushed(\n        address indexed previousGuardian,\n        address indexed newGuardian\n    );\n    event GuardianPulled(\n        address indexed previousGuardian,\n        address indexed newGuardian\n    );\n\n    constructor() {\n        _guardian = msg.sender;\n        emit GuardianPulled(address(0), _guardian);\n    }\n\n    function guardian() public view returns (address) {\n        return _guardian;\n    }\n\n    modifier onlyGuardian() {\n        require(\n            _guardian == msg.sender,\n            \"Guardable: caller is not the guardian\"\n        );\n        _;\n    }\n\n    function renounceGuardian() public virtual onlyGuardian {\n        emit GuardianPushed(_guardian, address(0));\n        _guardian = address(0);\n    }\n\n    function pushGuardian(address newGuardian_) public virtual onlyGuardian {\n        require(\n            newGuardian_ != address(0),\n            \"Guardable: new guardian is the zero address\"\n        );\n        emit GuardianPushed(_guardian, newGuardian_);\n        _newGuardian = newGuardian_;\n    }\n\n    function pullGuardian() public virtual {\n        require(\n            msg.sender == _newGuardian,\n            \"Guardable: must be new guardian to pull\"\n        );\n        emit GuardianPulled(_guardian, _newGuardian);\n        _guardian = _newGuardian;\n    }\n}\n"
    },
    "contracts/facets/Router/RouterLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../interfaces/IVaultPriceFeed.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../Vault/VaultLib.sol\";\n\nlibrary RouterLib {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using RouterLib for LibAppStorage.Storage;\n\n    function _validatePlugin(LibAppStorage.Storage storage s, address)\n        internal\n        view\n    {\n        require(s.plugins[msg.sender], \"Router: invalid plugin\");\n    }\n\n    function _transferETHToVault(LibAppStorage.Storage storage s) internal {\n        IWETH(s.weth).deposit{value: msg.value}();\n        IERC20(s.weth).safeTransfer(address(this), msg.value);\n    }\n\n    function _transferOutETH(\n        LibAppStorage.Storage storage s,\n        uint256 _amountOut,\n        address payable _receiver\n    ) internal {\n        IWETH(s.weth).withdraw(_amountOut);\n        _sendValue(s, _receiver, _amountOut);\n    }\n\n    function _sendValue(\n        LibAppStorage.Storage storage,\n        address payable _recipient,\n        uint256 amount\n    ) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = _recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, _crecipient may have reverted\"\n        );\n    }\n\n    function _swap(\n        LibAppStorage.Storage storage s,\n        address[] memory _path,\n        uint256 _minOut,\n        address _receiver\n    ) internal returns (uint256) {\n        if (_path.length == 2) {\n            return s._vaultSwap(_path[0], _path[1], _minOut, _receiver);\n        }\n        if (_path.length == 3) {\n            uint256 midOut = s._vaultSwap(_path[0], _path[1], 0, address(this));\n            IERC20(_path[1]).safeTransfer(address(this), midOut);\n            return s._vaultSwap(_path[1], _path[2], _minOut, _receiver);\n        }\n\n        revert(\"Router: invalid _path.length\");\n    }\n\n    function _vaultSwap(\n        LibAppStorage.Storage storage s,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _minOut,\n        address _receiver\n    )\n        internal\n        returns (\n            // uint256 _amountIn\n            uint256\n        )\n    {\n        uint256 _amountOut;\n\n        if (_tokenOut == s.nusd) {\n            // buyNUSD\n            _amountOut = IVault(address(this)).buyNUSD(_tokenIn, _receiver);\n        } else if (_tokenIn == s.nusd) {\n            // sellNUSD\n            _amountOut = IVault(address(this)).sellNUSD(_tokenOut, _receiver);\n        } else {\n            // swap\n            _amountOut = IVault(address(this)).swap(\n                _tokenIn,\n                _tokenOut,\n                _receiver\n            );\n        }\n\n        require(_amountOut >= _minOut, \"Router: insufficient amountOut\");\n\n        // TODO: Minting means contributing collateral for lending\n        return _amountOut;\n    }\n\n    function _sender() private view returns (address) {\n        return msg.sender;\n    }\n\n    function _increasePosition(\n        LibAppStorage.Storage storage s,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _price\n    ) internal {\n        if (_isLong) {\n            require(\n                VaultLib.getMaxPrice(_indexToken, s.includeAmmPrice) <= _price,\n                \"Router: mark price higher than limit\"\n            );\n        } else {\n            require(\n                VaultLib.getMinPrice(_indexToken, s.includeAmmPrice) >= _price,\n                \"Router: mark price lower than limit\"\n            );\n        }\n\n        IVault(address(this)).increasePosition(\n            _sender(),\n            _collateralToken,\n            _indexToken,\n            _sizeDelta,\n            _isLong\n        );\n    }\n\n    function _decreasePosition(\n        LibAppStorage.Storage storage s,\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _price\n    ) internal returns (uint256) {\n        if (_isLong) {\n            require(\n                VaultLib.getMinPrice(_indexToken, s.includeAmmPrice) >= _price,\n                \"Router: mark price lower than limit\"\n            );\n        } else {\n            require(\n                VaultLib.getMaxPrice(_indexToken, s.includeAmmPrice) <= _price,\n                \"Router: mark price higher than limit\"\n            );\n        }\n\n        uint256 _amountOut = IVault(address(this)).decreasePosition(\n            _sender(),\n            _collateralToken,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong,\n            _receiver\n        );\n\n        return _amountOut;\n    }\n}\n"
    },
    "contracts/facets/Router/RouterFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../Vault/VaultLib.sol\";\nimport \"./RouterLib.sol\";\nimport \"../../lib/Facet.sol\";\n\ncontract RouterFacet is Facet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event Swap(\n        address account,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    receive() external payable {\n        require(msg.sender == s.weth, \"Router: invalid sender\");\n    }\n\n    function _sender() private view returns (address) {\n        return msg.sender;\n    }\n\n    function addPlugin(address _plugin) external {\n        onlyGov();\n        s.plugins[_plugin] = true;\n    }\n\n    function removePlugin(address _plugin) external {\n        onlyGov();\n        s.plugins[_plugin] = false;\n    }\n\n    function directPoolDeposit(address _token, uint256 _amount) external {\n        IERC20(_token).safeTransferFrom(_sender(), address(this), _amount);\n        IVault(address(this)).directPoolDeposit(_token);\n    }\n\n    function swap(\n        address[] memory _path,\n        uint256 _amountIn,\n        uint256 _minOut,\n        address _receiver\n    ) public {\n        IERC20(_path[0]).safeTransferFrom(_sender(), address(this), _amountIn);\n        uint256 _amountOut = RouterLib._swap(s, _path, _minOut, _receiver);\n\n        emit Swap(\n            msg.sender,\n            _path[0],\n            _path[_path.length - 1],\n            _amountIn,\n            _amountOut\n        );\n    }\n\n    function swapETHToTokens(\n        address[] memory _path,\n        uint256 _minOut,\n        address _receiver\n    ) external payable {\n        require(_path[0] == s.weth, \"Router: weth not first in _path\");\n        RouterLib._transferETHToVault(s);\n        uint256 amountOut = RouterLib._swap(s, _path, _minOut, _receiver);\n\n        emit Swap(\n            msg.sender,\n            _path[0],\n            _path[_path.length - 1],\n            msg.value,\n            amountOut\n        );\n    }\n\n    function increasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _amountIn,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _price\n    ) external {\n        if (_amountIn > 0) {\n            IERC20(_path[0]).safeTransferFrom(\n                _sender(),\n                address(this),\n                _amountIn\n            );\n        }\n        if (_path.length > 1 && _amountIn > 0) {\n            uint256 _amountOut = RouterLib._swap(\n                s,\n                _path,\n                _minOut,\n                address(this)\n            );\n            IERC20(_path[_path.length - 1]).safeTransfer(\n                address(this),\n                _amountOut\n            );\n        }\n        RouterLib._increasePosition(\n            s,\n            _path[_path.length - 1],\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _price\n        );\n    }\n\n    function increasePositionETH(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _price\n    ) external payable {\n        require(_path[0] == s.weth, \"Router: invalid _path\");\n        if (msg.value > 0) {\n            RouterLib._transferETHToVault(s);\n        }\n        if (_path.length > 1 && msg.value > 0) {\n            uint256 _amountOut = RouterLib._swap(\n                s,\n                _path,\n                _minOut,\n                address(this)\n            );\n            IERC20(_path[_path.length - 1]).safeTransfer(\n                address(this),\n                _amountOut\n            );\n        }\n\n        RouterLib._increasePosition(\n            s,\n            _path[_path.length - 1],\n            _indexToken,\n            _sizeDelta,\n            _isLong,\n            _price\n        );\n    }\n\n    function decreasePosition(\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _price\n    ) external {\n        RouterLib._decreasePosition(\n            s,\n            _collateralToken,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong,\n            _receiver,\n            _price\n        );\n    }\n\n    function decreasePositionETH(\n        address _collateralToken,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address payable _receiver,\n        uint256 _price\n    ) external {\n        uint256 _amountOut = RouterLib._decreasePosition(\n            s,\n            _collateralToken,\n            _indexToken,\n            _collateralDelta,\n            _sizeDelta,\n            _isLong,\n            address(this),\n            _price\n        );\n        RouterLib._transferOutETH(s, _amountOut, _receiver);\n    }\n}\n"
    },
    "contracts/peripherals/BalanceUpdater.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../core/interfaces/IVault.sol\";\n\ncontract BalanceUpdater {\n    using SafeMath for uint256;\n\n    function updateBalance(\n        address _vault,\n        address _token,\n        address _nusd,\n        uint256 _nusdAmount\n    ) public {\n        IVault vault = IVault(_vault);\n        IERC20 token = IERC20(_token);\n        uint256 poolAmount = vault.poolAmounts(_token);\n        uint256 fee = vault.feeReserves(_token);\n        uint256 balance = token.balanceOf(_vault);\n\n        uint256 transferAmount = poolAmount.add(fee).sub(balance);\n        token.transferFrom(msg.sender, _vault, transferAmount);\n        IERC20(_nusd).transferFrom(msg.sender, _vault, _nusdAmount);\n\n        vault.sellNUSD(_token, msg.sender);\n    }\n}\n"
    },
    "contracts/tokens/Necc/interfaces/INecc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface INecc is IERC20 {\n    function decimals() external view returns (uint8);\n\n    function mint(uint256 amount_) external;\n\n    function mint(address account_, uint256 ammount_) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n"
    },
    "contracts/amm/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/facets/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IRouter {\n    function addPlugin(address _plugin) external;\n\n    function nusd() external view returns (address);\n\n    function swap(\n        address[] memory _path,\n        uint256 _amountIn,\n        uint256 _minOut,\n        address _receiver\n    ) external;\n\n    function vault() external view returns (address);\n}\n"
    },
    "contracts/tokens/Necc/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IStaking {\n    function stake(uint256 _amount, address _recipient) external returns (bool);\n\n    function claim(address _recipient) external;\n}\n"
    },
    "contracts/tokens/Necc/interfaces/IStakingHelper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IStakingHelper {\n    function stake(uint256 _amount) external;\n}\n"
    },
    "contracts/tokens/Necc/interfaces/ITeller.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface ITeller {\n    function newBond(\n        address _bonder,\n        uint256 _payout,\n        uint256 _end\n    ) external;\n}\n"
    },
    "contracts/tokens/Necc/mocks/MockBondDepository.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-08-29\n */\n\n// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IOwnable {\n    function policy() external view returns (address);\n\n    function renounceManagement() external;\n\n    function pushManagement(address newOwner_) external;\n\n    function pullManagement() external;\n}\n\ncontract Ownable is IOwnable {\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipPulled(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipPushed(address(0), _owner);\n    }\n\n    function policy() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyPolicy() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyPolicy {\n        emit OwnershipPushed(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function pushManagement(address newOwner_)\n        public\n        virtual\n        override\n        onlyPolicy\n    {\n        require(\n            newOwner_ != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipPushed(_owner, newOwner_);\n        _newOwner = newOwner_;\n    }\n\n    function pullManagement() public virtual override {\n        require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled(_owner, _newOwner);\n        _owner = _newOwner;\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function sub32(uint32 a, uint32 b) internal pure returns (uint32) {\n        return sub32(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub32(\n        uint32 a,\n        uint32 b,\n        string memory errorMessage\n    ) internal pure returns (uint32) {\n        require(b <= a, errorMessage);\n        uint32 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 b = add(div(a, 2), 1);\n            while (b < c) {\n                c = b;\n                b = div(add(div(a, b), b), 2);\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\n            data\n        );\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function addressToString(address _address)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes32 _bytes = bytes32(uint256(_address));\n        bytes memory HEX = \"0123456789abcdef\";\n        bytes memory _addr = new bytes(42);\n\n        _addr[0] = \"0\";\n        _addr[1] = \"x\";\n\n        for (uint256 i = 0; i < 20; i++) {\n            _addr[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];\n            _addr[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n        }\n\n        return string(_addr);\n    }\n}\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nabstract contract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    // TODO comment actual hash value.\n    bytes32 private constant ERC20TOKEN_ERC1820_INTERFACE_ID =\n        keccak256(\"ERC20Token\");\n\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string internal _name;\n\n    string internal _symbol;\n\n    uint8 internal _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account_, uint256 ammount_) internal virtual {\n        require(account_ != address(0), \"ERC20: mint to the zero address\");\n        _beforeTokenTransfer(address(this), account_, ammount_);\n        _totalSupply = _totalSupply.add(ammount_);\n        _balances[account_] = _balances[account_].add(ammount_);\n        emit Transfer(address(this), account_, ammount_);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(\n            amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from_,\n        address to_,\n        uint256 amount_\n    ) internal virtual {}\n}\n\ninterface IERC2612Permit {\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function nonces(address owner) external view returns (uint256);\n}\n\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    constructor() {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name())),\n                keccak256(bytes(\"1\")), // Version\n                chainID,\n                address(this)\n            )\n        );\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"Permit: expired deadline\");\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                _nonces[owner].current(),\n                deadline\n            )\n        );\n\n        bytes32 _hash = keccak256(\n            abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct)\n        );\n\n        address signer = ecrecover(_hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            \"ZeroSwapPermit: Invalid signature\"\n        );\n\n        _nonces[owner].increment();\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner].current();\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(\n            value\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y)\n        private\n        pure\n        returns (uint256 l, uint256 h)\n    {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n        require(h < d, \"FullMath::mulDiv: overflow\");\n        return fullDiv(l, h, d);\n    }\n}\n\nlibrary FixedPoint {\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\n    uint256 private constant Q224 =\n        0x100000000000000000000000000000000000000000000000000000000;\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    function decode112with18(uq112x112 memory self)\n        internal\n        pure\n        returns (uint256)\n    {\n        return uint256(self._x) / 5192296858534827;\n    }\n\n    function fraction(uint256 numerator, uint256 denominator)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        }\n    }\n}\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (bool);\n\n    function valueOfToken(address _token, uint256 _amount)\n        external\n        view\n        returns (uint256 value_);\n}\n\ninterface IBondCalculator {\n    function valuation(address _LP, uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function markdown(address _LP) external view returns (uint256);\n}\n\ninterface IStaking {\n    function stake(uint256 _amount, address _recipient) external returns (bool);\n}\n\ninterface IStakingHelper {\n    function stake(uint256 _amount, address _recipient) external;\n}\n\ncontract MockNeccBondDepository is Ownable {\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using SafeMath for uint32;\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated(\n        uint256 deposit,\n        uint256 indexed payout,\n        uint256 indexed expires,\n        uint256 indexed priceInUSD\n    );\n    event BondRedeemed(\n        address indexed recipient,\n        uint256 payout,\n        uint256 remaining\n    );\n    event BondPriceChanged(\n        uint256 indexed priceInUSD,\n        uint256 indexed internalPrice,\n        uint256 indexed debtRatio\n    );\n    event ControlVariableAdjustment(\n        uint256 initialBCV,\n        uint256 newBCV,\n        uint256 adjustment,\n        bool addition\n    );\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public immutable Necc; // token given as payment for bond\n    address public immutable principle; // token used to create bond\n    address public immutable treasury; // mints Necc when receives principle\n    address public immutable DAO; // receives profit share from bond\n\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n    address public immutable bondCalculator; // calculates value of LP tokens\n\n    address public staking; // to auto-stake payout\n    address public stakingHelper; // to stake and claim if no staking warmup\n    bool public useHelper;\n\n    Terms public terms; // stores terms for new bonds\n    Adjust public adjustment; // stores adjustment to BCV data\n\n    mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n    uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n    uint32 public lastDecay; // reference time for debt decay\n\n    /* ======== STRUCTS ======== */\n\n    // Info for creating new bonds\n    struct Terms {\n        uint256 controlVariable; // scaling variable for price\n        uint256 minimumPrice; // vs principle value\n        uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint256 fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\n        uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n        uint32 vestingTerm; // in seconds\n    }\n\n    // Info for bond holder\n    struct Bond {\n        uint256 payout; // Necc remaining to be paid\n        uint256 pricePaid; // In NUSD, for front end viewing\n        uint32 lastNecc; // Last interaction\n        uint32 vesting; // Seconds left to vest\n    }\n\n    // Info for incremental adjustments to control variable\n    struct Adjust {\n        bool add; // addition or subtraction\n        uint256 rate; // increment\n        uint256 target; // BCV when adjustment finished\n        uint32 buffer; // minimum length (in seconds) between adjustments\n        uint32 lastNecc; // time when last adjustment made\n    }\n\n    /* ======== INITIALIZATION ======== */\n\n    constructor(\n        address _Necc,\n        address _principle,\n        address _treasury,\n        address _DAO,\n        address _bondCalculator\n    ) {\n        require(_Necc != address(0));\n        Necc = _Necc;\n        require(_principle != address(0));\n        principle = _principle;\n        require(_treasury != address(0));\n        treasury = _treasury;\n        require(_DAO != address(0));\n        DAO = _DAO;\n        // bondCalculator should be address(0) if not LP bond\n        bondCalculator = _bondCalculator;\n        isLiquidityBond = (_bondCalculator != address(0));\n    }\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint32\n     *  @param _minimumPrice uint\n     *  @param _maxPayout uint\n     *  @param _fee uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBondTerms(\n        uint256 _controlVariable,\n        uint256 _minimumPrice,\n        uint256 _maxPayout,\n        uint256 _fee,\n        uint256 _maxDebt,\n        uint256 _initialDebt,\n        uint32 _vestingTerm\n    ) external onlyPolicy {\n        require(terms.controlVariable == 0, \"Bonds must be initialized from 0\");\n        terms = Terms({\n            controlVariable: _controlVariable,\n            minimumPrice: _minimumPrice,\n            maxPayout: _maxPayout,\n            fee: _fee,\n            maxDebt: _maxDebt,\n            vestingTerm: _vestingTerm\n        });\n        totalDebt = _initialDebt;\n        lastDecay = uint32(block.timestamp);\n    }\n\n    /* ======== POLICY FUNCTIONS ======== */\n\n    enum PARAMETER {\n        VESTING,\n        PAYOUT,\n        FEE,\n        DEBT\n    }\n\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _parameter PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms(PARAMETER _parameter, uint256 _input)\n        external\n        onlyPolicy\n    {\n        if (_parameter == PARAMETER.VESTING) {\n            // 0\n            require(_input >= 129600, \"Vesting must be longer than 36 hours\");\n            terms.vestingTerm = uint32(_input);\n        } else if (_parameter == PARAMETER.PAYOUT) {\n            // 1\n            require(_input <= 1000, \"Payout cannot be above 1 percent\");\n            terms.maxPayout = _input;\n        } else if (_parameter == PARAMETER.FEE) {\n            // 2\n            require(_input <= 10000, \"DAO fee cannot exceed payout\");\n            terms.fee = _input;\n        } else if (_parameter == PARAMETER.DEBT) {\n            // 3\n            terms.maxDebt = _input;\n        }\n    }\n\n    /**\n     *  @notice set control variable adjustment\n     *  @param _addition bool\n     *  @param _increment uint\n     *  @param _target uint\n     *  @param _buffer uint\n     */\n    function setAdjustment(\n        bool _addition,\n        uint256 _increment,\n        uint256 _target,\n        uint32 _buffer\n    ) external onlyPolicy {\n        require(\n            _increment <= terms.controlVariable.mul(25).div(1000),\n            \"Increment too large\"\n        );\n\n        adjustment = Adjust({\n            add: _addition,\n            rate: _increment,\n            target: _target,\n            buffer: _buffer,\n            lastNecc: uint32(block.timestamp)\n        });\n    }\n\n    /**\n     *  @notice set contract for auto stake\n     *  @param _staking address\n     *  @param _helper bool\n     */\n    function setStaking(address _staking, bool _helper) external onlyPolicy {\n        require(_staking != address(0));\n        if (_helper) {\n            useHelper = true;\n            stakingHelper = _staking;\n        } else {\n            useHelper = false;\n            staking = _staking;\n        }\n    }\n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit(\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _depositor\n    ) external returns (uint256) {\n        require(_depositor != address(0), \"Invalid address\");\n\n        decayDebt();\n        require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n        uint256 priceInUSD = bondPriceInUSD(); // Stored in bond info\n        uint256 nativePrice = _bondPrice();\n\n        require(\n            _maxPrice >= nativePrice,\n            \"Slippage limit: more than max price\"\n        ); // slippage protection\n\n        uint256 value = ITreasury(treasury).valueOfToken(principle, _amount);\n        uint256 payout = payoutFor(value); // payout to bonder is computed\n\n        require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 Necc ( underflow protection )\n        require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n        // profits are calculated\n        uint256 fee = payout.mul(terms.fee).div(10000);\n        uint256 profit = value.sub(payout).sub(fee);\n\n        /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) Necc\n         */\n        IERC20(principle).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(principle).approve(address(treasury), _amount);\n        ITreasury(treasury).deposit(_amount, principle, profit);\n\n        if (fee != 0) {\n            // fee is transferred to dao\n            IERC20(Necc).safeTransfer(DAO, fee);\n        }\n\n        // total debt is increased\n        totalDebt = totalDebt.add(value);\n\n        // depositor info is stored\n        bondInfo[_depositor] = Bond({\n            payout: bondInfo[_depositor].payout.add(payout),\n            vesting: terms.vestingTerm,\n            lastNecc: uint32(block.timestamp),\n            pricePaid: priceInUSD\n        });\n\n        // indexed events are emitted\n        emit BondCreated(\n            _amount,\n            payout,\n            block.timestamp.add(terms.vestingTerm),\n            priceInUSD\n        );\n        emit BondPriceChanged(bondPriceInUSD(), _bondPrice(), debtRatio());\n\n        adjust(); // control variable is adjusted\n        return payout;\n    }\n\n    /**\n     *  @notice redeem bond for user\n     *  @param _recipient address\n     *  @param _stake bool\n     *  @return uint\n     */\n    function redeem(address _recipient, bool _stake)\n        external\n        returns (uint256)\n    {\n        Bond memory info = bondInfo[_recipient];\n        // (seconds since last interaction / vesting term remaining)\n        uint256 percentVested = percentVestedFor(_recipient);\n\n        if (percentVested >= 10000) {\n            // if fully vested\n            delete bondInfo[_recipient]; // delete user info\n            emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n            return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n        } else {\n            // if unfinished\n            // calculate payout vested\n            uint256 payout = info.payout.mul(percentVested).div(10000);\n            // store updated deposit info\n            bondInfo[_recipient] = Bond({\n                payout: info.payout.sub(payout),\n                vesting: info.vesting.sub32(\n                    uint32(block.timestamp).sub32(info.lastNecc)\n                ),\n                lastNecc: uint32(block.timestamp),\n                pricePaid: info.pricePaid\n            });\n\n            emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n            return stakeOrSend(_recipient, _stake, payout);\n        }\n    }\n\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n    /**\n     *  @notice allow user to stake payout automatically\n     *  @param _stake bool\n     *  @param _amount uint\n     *  @return uint\n     */\n    function stakeOrSend(\n        address _recipient,\n        bool _stake,\n        uint256 _amount\n    ) internal returns (uint256) {\n        if (!_stake) {\n            // if user does not want to stake\n            IERC20(Necc).transfer(_recipient, _amount); // send payout\n        } else {\n            // if user wants to stake\n            if (useHelper) {\n                // use if staking warmup is 0\n                IERC20(Necc).approve(stakingHelper, _amount);\n                IStakingHelper(stakingHelper).stake(_amount, _recipient);\n            } else {\n                IERC20(Necc).approve(staking, _amount);\n                IStaking(staking).stake(_amount, _recipient);\n            }\n        }\n        return _amount;\n    }\n\n    /**\n     *  @notice makes incremental adjustment to control variable\n     */\n    function adjust() internal {\n        uint256 timeCanAdjust = adjustment.lastNecc.add(adjustment.buffer);\n        if (adjustment.rate != 0 && block.timestamp >= timeCanAdjust) {\n            uint256 initial = terms.controlVariable;\n            if (adjustment.add) {\n                terms.controlVariable = terms.controlVariable.add(\n                    adjustment.rate\n                );\n                if (terms.controlVariable >= adjustment.target) {\n                    adjustment.rate = 0;\n                }\n            } else {\n                terms.controlVariable = terms.controlVariable.sub(\n                    adjustment.rate\n                );\n                if (terms.controlVariable <= adjustment.target) {\n                    adjustment.rate = 0;\n                }\n            }\n            adjustment.lastNecc = uint32(block.timestamp);\n            emit ControlVariableAdjustment(\n                initial,\n                terms.controlVariable,\n                adjustment.rate,\n                adjustment.add\n            );\n        }\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt() internal {\n        totalDebt = totalDebt.sub(debtDecay());\n        lastDecay = uint32(block.timestamp);\n    }\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout() public view returns (uint256) {\n        return IERC20(Necc).totalSupply().mul(terms.maxPayout).div(100000);\n    }\n\n    /**\n     *  @notice calculate interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor(uint256 _value) public view returns (uint256) {\n        return\n            FixedPoint.fraction(_value, bondPrice()).decode112with18().div(\n                1e16\n            );\n    }\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price_ uint\n     */\n    function bondPrice() public view returns (uint256 price_) {\n        price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(\n            1e7\n        );\n        if (price_ < terms.minimumPrice) {\n            price_ = terms.minimumPrice;\n        }\n    }\n\n    /**\n     *  @notice calculate current bond price and remove floor if above\n     *  @return price_ uint\n     */\n    function _bondPrice() internal returns (uint256 price_) {\n        price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(\n            1e7\n        );\n        if (price_ < terms.minimumPrice) {\n            price_ = terms.minimumPrice;\n        } else if (terms.minimumPrice != 0) {\n            terms.minimumPrice = 0;\n        }\n    }\n\n    /**\n     *  @notice converts bond price to NUSD value\n     *  @return price_ uint\n     */\n    function bondPriceInUSD() public view returns (uint256 price_) {\n        if (isLiquidityBond) {\n            price_ = bondPrice()\n                .mul(IBondCalculator(bondCalculator).markdown(principle))\n                .div(100);\n        } else {\n            price_ = bondPrice().mul(10**IERC20(principle).decimals()).div(100);\n        }\n    }\n\n    /**\n     *  @notice calculate current ratio of debt to Necc supply\n     *  @return debtRatio_ uint\n     */\n    function debtRatio() public view returns (uint256 debtRatio_) {\n        uint256 supply = IERC20(Necc).totalSupply();\n        debtRatio_ = FixedPoint\n            .fraction(currentDebt().mul(1e9), supply)\n            .decode112with18()\n            .div(1e18);\n    }\n\n    /**\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\n     *  @return uint\n     */\n    function standardizedDebtRatio() external view returns (uint256) {\n        if (isLiquidityBond) {\n            return\n                debtRatio()\n                    .mul(IBondCalculator(bondCalculator).markdown(principle))\n                    .div(1e9);\n        } else {\n            return debtRatio();\n        }\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt() public view returns (uint256) {\n        return totalDebt.sub(debtDecay());\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay_ uint\n     */\n    function debtDecay() public view returns (uint256 decay_) {\n        uint32 timeSinceLast = uint32(block.timestamp).sub32(lastDecay);\n        decay_ = totalDebt.mul(timeSinceLast).div(terms.vestingTerm);\n        if (decay_ > totalDebt) {\n            decay_ = totalDebt;\n        }\n    }\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested_ uint\n     */\n    function percentVestedFor(address _depositor)\n        public\n        view\n        returns (uint256 percentVested_)\n    {\n        Bond memory bond = bondInfo[_depositor];\n        uint256 secondsSinceLast = uint32(block.timestamp).sub(bond.lastNecc);\n        uint256 vesting = bond.vesting;\n\n        if (vesting > 0) {\n            percentVested_ = secondsSinceLast.mul(10000).div(vesting);\n        } else {\n            percentVested_ = 0;\n        }\n    }\n\n    /**\n     *  @notice calculate amount of Necc available for claim by depositor\n     *  @param _depositor address\n     *  @return pendingPayout_ uint\n     */\n    function pendingPayoutFor(address _depositor)\n        external\n        view\n        returns (uint256 pendingPayout_)\n    {\n        uint256 percentVested = percentVestedFor(_depositor);\n        uint256 payout = bondInfo[_depositor].payout;\n\n        if (percentVested >= 10000) {\n            pendingPayout_ = payout;\n        } else {\n            pendingPayout_ = payout.mul(percentVested).div(10000);\n        }\n    }\n\n    /* ======= AUXILLIARY ======= */\n\n    /**\n     *  @notice allow anyone to send lost tokens (excluding principle or Necc) to the DAO\n     *  @return bool\n     */\n    function recoverLostToken(address _token) external returns (bool) {\n        require(_token != Necc);\n        require(_token != principle);\n        IERC20(_token).safeTransfer(\n            DAO,\n            IERC20(_token).balanceOf(address(this))\n        );\n        return true;\n    }\n}\n"
    },
    "contracts/tokens/Necc/mocks/MockNeccTreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\n            data\n        );\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n\ninterface IBondCalculator {\n    function valuation(address pair_, uint256 amount_)\n        external\n        view\n        returns (uint256 _value);\n}\n\ninterface IOwnable {\n    function manager() external view returns (address);\n\n    function renounceManagement() external;\n\n    function pushManagement(address newOwner_) external;\n\n    function pullManagement() external;\n}\n\ncontract Ownable is IOwnable {\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipPulled(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipPushed(address(0), _owner);\n    }\n\n    function manager() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyManager() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyManager {\n        emit OwnershipPushed(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function pushManagement(address newOwner_)\n        public\n        virtual\n        override\n        onlyManager\n    {\n        require(\n            newOwner_ != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipPushed(_owner, newOwner_);\n        _newOwner = newOwner_;\n    }\n\n    function pullManagement() public virtual override {\n        require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled(_owner, _newOwner);\n        _owner = _newOwner;\n    }\n}\n\ninterface IERC20Mintable {\n    function mint(uint256 amount_) external;\n\n    function mint(address account_, uint256 ammount_) external;\n}\n\ninterface INeccERC20 {\n    function burnFrom(address account_, uint256 amount_) external;\n}\n\ncontract MockNeccTreasury is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed token, uint256 amount, uint256 value);\n    event Withdrawal(address indexed token, uint256 amount, uint256 value);\n    event CreateDebt(\n        address indexed debtor,\n        address indexed token,\n        uint256 amount,\n        uint256 value\n    );\n    event RepayDebt(\n        address indexed debtor,\n        address indexed token,\n        uint256 amount,\n        uint256 value\n    );\n    event ReservesManaged(address indexed token, uint256 amount);\n    event ReservesUpdated(uint256 indexed totalReserves);\n    event ReservesAudited(uint256 indexed totalReserves);\n    event RewardsMinted(\n        address indexed caller,\n        address indexed recipient,\n        uint256 amount\n    );\n    event ChangeQueued(MANAGING indexed managing, address queued);\n    event ChangeActivated(\n        MANAGING indexed managing,\n        address activated,\n        bool result\n    );\n\n    enum MANAGING {\n        RESERVEDEPOSITOR,\n        RESERVESPENDER,\n        RESERVETOKEN,\n        RESERVEMANAGER,\n        LIQUIDITYDEPOSITOR,\n        LIQUIDITYTOKEN,\n        LIQUIDITYMANAGER,\n        DEBTOR,\n        REWARDMANAGER,\n        nNecc\n    }\n\n    address public immutable Necc;\n    uint256 public immutable blocksNeededForQueue;\n\n    address[] public reserveTokens; // Push only, beware false-positives.\n    mapping(address => bool) public isReserveToken;\n    mapping(address => uint256) public reserveTokenQueue; // Delays changes to mapping.\n\n    address[] public reserveDepositors; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isReserveDepositor;\n    mapping(address => uint256) public reserveDepositorQueue; // Delays changes to mapping.\n\n    address[] public reserveSpenders; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isReserveSpender;\n    mapping(address => uint256) public reserveSpenderQueue; // Delays changes to mapping.\n\n    address[] public liquidityTokens; // Push only, beware false-positives.\n    mapping(address => bool) public isLiquidityToken;\n    mapping(address => uint256) public LiquidityTokenQueue; // Delays changes to mapping.\n\n    address[] public liquidityDepositors; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isLiquidityDepositor;\n    mapping(address => uint256) public LiquidityDepositorQueue; // Delays changes to mapping.\n\n    mapping(address => address) public bondCalculator; // bond calculator for liquidity token\n\n    address[] public reserveManagers; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isReserveManager;\n    mapping(address => uint256) public ReserveManagerQueue; // Delays changes to mapping.\n\n    address[] public liquidityManagers; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isLiquidityManager;\n    mapping(address => uint256) public LiquidityManagerQueue; // Delays changes to mapping.\n\n    address[] public debtors; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isDebtor;\n    mapping(address => uint256) public debtorQueue; // Delays changes to mapping.\n    mapping(address => uint256) public debtorBalance;\n\n    address[] public rewardManagers; // Push only, beware false-positives. Only for viewing.\n    mapping(address => bool) public isRewardManager;\n    mapping(address => uint256) public rewardManagerQueue; // Delays changes to mapping.\n\n    address public nNecc;\n    uint256 public nNeccQueue; // Delays change to nNecc address\n\n    uint256 public totalReserves; // Risk-free value of all assets\n    uint256 public totalDebt;\n\n    constructor(\n        address _Necc,\n        address _NUSD,\n        uint256 _blocksNeededForQueue\n    ) {\n        require(_Necc != address(0));\n        Necc = _Necc;\n\n        isReserveToken[_NUSD] = true;\n        reserveTokens.push(_NUSD);\n\n        // isLiquidityToken[ _NeccNUSD ] = true;\n        // liquidityTokens.push( _NeccNUSD );\n\n        blocksNeededForQueue = _blocksNeededForQueue;\n    }\n\n    /**\n        @notice allow approved address to deposit an asset for Necc\n        @param _amount uint\n        @param _token address\n        @param _profit uint\n        @return send_ uint\n     */\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256 send_) {\n        require(\n            isReserveToken[_token] || isLiquidityToken[_token],\n            \"Not accepted\"\n        );\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (isReserveToken[_token]) {\n            require(isReserveDepositor[msg.sender], \"Not approved\");\n        } else {\n            require(isLiquidityDepositor[msg.sender], \"Not approved\");\n        }\n\n        uint256 value = valueOfToken(_token, _amount);\n        (_token, _amount);\n        // mint Necc needed and store amount of rewards for distribution\n        send_ = value.sub(_profit);\n        IERC20Mintable(Necc).mint(msg.sender, send_);\n\n        totalReserves = totalReserves.add(value);\n        emit ReservesUpdated(totalReserves);\n\n        emit Deposit(_token, _amount, value);\n    }\n\n    /**\n        @notice allow approved address to burn Necc for reserves\n        @param _amount uint\n        @param _token address\n     */\n    function withdraw(uint256 _amount, address _token) external {\n        require(isReserveToken[_token], \"Not accepted\"); // Only reserves can be used for redemptions\n        require(isReserveSpender[msg.sender] == true, \"Not approved\");\n\n        uint256 value = valueOfToken(_token, _amount);\n        INeccERC20(Necc).burnFrom(msg.sender, value);\n\n        totalReserves = totalReserves.sub(value);\n        emit ReservesUpdated(totalReserves);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n\n        emit Withdrawal(_token, _amount, value);\n    }\n\n    /**\n        @notice allow approved address to borrow reserves\n        @param _amount uint\n        @param _token address\n     */\n    function incurDebt(uint256 _amount, address _token) external {\n        require(isDebtor[msg.sender], \"Not approved\");\n        require(isReserveToken[_token], \"Not accepted\");\n\n        uint256 value = valueOfToken(_token, _amount);\n\n        uint256 maximumDebt = IERC20(nNecc).balanceOf(msg.sender); // Can only borrow against nNecc held\n        uint256 availableDebt = maximumDebt.sub(debtorBalance[msg.sender]);\n        require(value <= availableDebt, \"Exceeds debt limit\");\n\n        debtorBalance[msg.sender] = debtorBalance[msg.sender].add(value);\n        totalDebt = totalDebt.add(value);\n\n        totalReserves = totalReserves.sub(value);\n        emit ReservesUpdated(totalReserves);\n\n        IERC20(_token).transfer(msg.sender, _amount);\n\n        emit CreateDebt(msg.sender, _token, _amount, value);\n    }\n\n    /**\n        @notice allow approved address to repay borrowed reserves with reserves\n        @param _amount uint\n        @param _token address\n     */\n    function repayDebtWithReserve(uint256 _amount, address _token) external {\n        require(isDebtor[msg.sender], \"Not approved\");\n        require(isReserveToken[_token], \"Not accepted\");\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 value = valueOfToken(_token, _amount);\n        debtorBalance[msg.sender] = debtorBalance[msg.sender].sub(value);\n        totalDebt = totalDebt.sub(value);\n\n        totalReserves = totalReserves.add(value);\n        emit ReservesUpdated(totalReserves);\n\n        emit RepayDebt(msg.sender, _token, _amount, value);\n    }\n\n    /**\n        @notice allow approved address to repay borrowed reserves with Necc\n        @param _amount uint\n     */\n    function repayDebtWithNecc(uint256 _amount) external {\n        require(isDebtor[msg.sender], \"Not approved\");\n\n        INeccERC20(Necc).burnFrom(msg.sender, _amount);\n\n        debtorBalance[msg.sender] = debtorBalance[msg.sender].sub(_amount);\n        totalDebt = totalDebt.sub(_amount);\n\n        emit RepayDebt(msg.sender, Necc, _amount, _amount);\n    }\n\n    /**\n        @notice allow approved address to withdraw assets\n        @param _token address\n        @param _amount uint\n     */\n    function manage(address _token, uint256 _amount) external {\n        if (isLiquidityToken[_token]) {\n            require(isLiquidityManager[msg.sender], \"Not approved\");\n        } else {\n            require(isReserveManager[msg.sender], \"Not approved\");\n        }\n\n        uint256 value = valueOfToken(_token, _amount);\n        (_token, _amount);\n        require(value <= excessReserves(), \"Insufficient reserves\");\n\n        totalReserves = totalReserves.sub(value);\n        emit ReservesUpdated(totalReserves);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n\n        emit ReservesManaged(_token, _amount);\n    }\n\n    /**\n        @notice send epoch reward to staking contract\n     */\n    function mintRewards(address _recipient, uint256 _amount) external {\n        require(isRewardManager[msg.sender], \"Not approved\");\n        require(_amount <= excessReserves(), \"Insufficient reserves\");\n\n        IERC20Mintable(Necc).mint(_recipient, _amount);\n\n        emit RewardsMinted(msg.sender, _recipient, _amount);\n    }\n\n    /**\n        @notice returns excess reserves not backing tokens\n        @return uint\n     */\n    function excessReserves() public view returns (uint256) {\n        return totalReserves.sub(IERC20(Necc).totalSupply().sub(totalDebt));\n    }\n\n    /**\n        @notice takes inventory of all tracked assets\n        @notice always consolidate to recognized reserves before audit\n     */\n    function auditReserves() external onlyManager {\n        uint256 reserves;\n        for (uint256 i = 0; i < reserveTokens.length; i++) {\n            reserves = reserves.add(\n                valueOfToken(\n                    reserveTokens[i],\n                    IERC20(reserveTokens[i]).balanceOf(address(this))\n                )\n            );\n        }\n        for (uint256 i = 0; i < liquidityTokens.length; i++) {\n            reserves = reserves.add(\n                valueOfToken(\n                    liquidityTokens[i],\n                    IERC20(liquidityTokens[i]).balanceOf(address(this))\n                )\n            );\n        }\n        totalReserves = reserves;\n        emit ReservesUpdated(reserves);\n        emit ReservesAudited(reserves);\n    }\n\n    /**\n        @notice returns Necc valuation of asset\n        @param _token address\n        @param _amount uint\n        @return value_ uint\n     */\n    function valueOfToken(address _token, uint256 _amount)\n        public\n        view\n        returns (uint256 value_)\n    {\n        if (isReserveToken[_token]) {\n            // convert amount to match Necc decimals\n            value_ = _amount.mul(10**IERC20(Necc).decimals()).div(\n                10**IERC20(_token).decimals()\n            );\n        } else if (isLiquidityToken[_token]) {\n            value_ = IBondCalculator(bondCalculator[_token]).valuation(\n                _token,\n                _amount\n            );\n        }\n    }\n\n    /**\n        @notice queue address to change boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n    function queue(MANAGING _managing, address _address)\n        external\n        onlyManager\n        returns (bool)\n    {\n        require(_address != address(0));\n        if (_managing == MANAGING.RESERVEDEPOSITOR) {\n            // 0\n            reserveDepositorQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVESPENDER) {\n            // 1\n            reserveSpenderQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVETOKEN) {\n            // 2\n            reserveTokenQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.RESERVEMANAGER) {\n            // 3\n            ReserveManagerQueue[_address] = block.number.add(\n                blocksNeededForQueue.mul(2)\n            );\n        } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n            // 4\n            LiquidityDepositorQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n            // 5\n            LiquidityTokenQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n            // 6\n            LiquidityManagerQueue[_address] = block.number.add(\n                blocksNeededForQueue.mul(2)\n            );\n        } else if (_managing == MANAGING.DEBTOR) {\n            // 7\n            debtorQueue[_address] = block.number.add(blocksNeededForQueue);\n        } else if (_managing == MANAGING.REWARDMANAGER) {\n            // 8\n            rewardManagerQueue[_address] = block.number.add(\n                blocksNeededForQueue\n            );\n        } else if (_managing == MANAGING.nNecc) {\n            // 9\n            nNeccQueue = block.number.add(blocksNeededForQueue);\n        } else return false;\n\n        emit ChangeQueued(_managing, _address);\n        return true;\n    }\n\n    /**\n        @notice verify queue then set boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @param _calculator address\n        @return bool\n     */\n    function toggle(\n        MANAGING _managing,\n        address _address,\n        address _calculator\n    ) external onlyManager returns (bool) {\n        require(_address != address(0));\n        bool result;\n        if (_managing == MANAGING.RESERVEDEPOSITOR) {\n            // 0\n            if (\n                requirements(\n                    reserveDepositorQueue,\n                    isReserveDepositor,\n                    _address\n                )\n            ) {\n                reserveDepositorQueue[_address] = 0;\n                if (!listContains(reserveDepositors, _address)) {\n                    reserveDepositors.push(_address);\n                }\n            }\n            result = !isReserveDepositor[_address];\n            isReserveDepositor[_address] = result;\n        } else if (_managing == MANAGING.RESERVESPENDER) {\n            // 1\n            if (requirements(reserveSpenderQueue, isReserveSpender, _address)) {\n                reserveSpenderQueue[_address] = 0;\n                if (!listContains(reserveSpenders, _address)) {\n                    reserveSpenders.push(_address);\n                }\n            }\n            result = !isReserveSpender[_address];\n            isReserveSpender[_address] = result;\n        } else if (_managing == MANAGING.RESERVETOKEN) {\n            // 2\n            if (requirements(reserveTokenQueue, isReserveToken, _address)) {\n                reserveTokenQueue[_address] = 0;\n                if (!listContains(reserveTokens, _address)) {\n                    reserveTokens.push(_address);\n                }\n            }\n            result = !isReserveToken[_address];\n            isReserveToken[_address] = result;\n        } else if (_managing == MANAGING.RESERVEMANAGER) {\n            // 3\n            if (requirements(ReserveManagerQueue, isReserveManager, _address)) {\n                reserveManagers.push(_address);\n                ReserveManagerQueue[_address] = 0;\n                if (!listContains(reserveManagers, _address)) {\n                    reserveManagers.push(_address);\n                }\n            }\n            result = !isReserveManager[_address];\n            isReserveManager[_address] = result;\n        } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\n            // 4\n            if (\n                requirements(\n                    LiquidityDepositorQueue,\n                    isLiquidityDepositor,\n                    _address\n                )\n            ) {\n                liquidityDepositors.push(_address);\n                LiquidityDepositorQueue[_address] = 0;\n                if (!listContains(liquidityDepositors, _address)) {\n                    liquidityDepositors.push(_address);\n                }\n            }\n            result = !isLiquidityDepositor[_address];\n            isLiquidityDepositor[_address] = result;\n        } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\n            // 5\n            if (requirements(LiquidityTokenQueue, isLiquidityToken, _address)) {\n                LiquidityTokenQueue[_address] = 0;\n                if (!listContains(liquidityTokens, _address)) {\n                    liquidityTokens.push(_address);\n                }\n            }\n            result = !isLiquidityToken[_address];\n            isLiquidityToken[_address] = result;\n            bondCalculator[_address] = _calculator;\n        } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\n            // 6\n            if (\n                requirements(\n                    LiquidityManagerQueue,\n                    isLiquidityManager,\n                    _address\n                )\n            ) {\n                LiquidityManagerQueue[_address] = 0;\n                if (!listContains(liquidityManagers, _address)) {\n                    liquidityManagers.push(_address);\n                }\n            }\n            result = !isLiquidityManager[_address];\n            isLiquidityManager[_address] = result;\n        } else if (_managing == MANAGING.DEBTOR) {\n            // 7\n            if (requirements(debtorQueue, isDebtor, _address)) {\n                debtorQueue[_address] = 0;\n                if (!listContains(debtors, _address)) {\n                    debtors.push(_address);\n                }\n            }\n            result = !isDebtor[_address];\n            isDebtor[_address] = result;\n        } else if (_managing == MANAGING.REWARDMANAGER) {\n            // 8\n            if (requirements(rewardManagerQueue, isRewardManager, _address)) {\n                rewardManagerQueue[_address] = 0;\n                if (!listContains(rewardManagers, _address)) {\n                    rewardManagers.push(_address);\n                }\n            }\n            result = !isRewardManager[_address];\n            isRewardManager[_address] = result;\n        } else if (_managing == MANAGING.nNecc) {\n            // 9\n            nNeccQueue = 0;\n            nNecc = _address;\n            result = true;\n        } else return false;\n\n        emit ChangeActivated(_managing, _address, result);\n        return true;\n    }\n\n    /**\n        @notice checks requirements and returns altered structs\n        @param queue_ mapping( address => uint )\n        @param status_ mapping( address => bool )\n        @param _address address\n        @return bool \n     */\n    function requirements(\n        mapping(address => uint256) storage queue_,\n        mapping(address => bool) storage status_,\n        address _address\n    ) internal view returns (bool) {\n        if (!status_[_address]) {\n            require(queue_[_address] != 0, \"Must queue\");\n            require(queue_[_address] <= block.number, \"Queue not expired\");\n            return true;\n        }\n        return false;\n    }\n\n    /**\n        @notice checks array to ensure against duplicate\n        @param _list address[]\n        @param _token address\n        @return bool\n     */\n    function listContains(address[] storage _list, address _token)\n        internal\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _list.length; i++) {\n            if (_list[i] == _token) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/tokens/Necc/mocks/MockNUSD.sol": {
      "content": "pragma solidity 0.7.5;\n\ncontract LibNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed usr,\n        bytes32 indexed arg1,\n        bytes32 indexed arg2,\n        bytes data\n    ) anonymous;\n\n    modifier note() {\n        _;\n        // assembly {\n        //     // log an 'anonymous' event with a constant 6 words of calldata\n        //     // and four indexed topics: selector, caller, arg1 and arg2\n        //     let mark := msize()                         // end of memory ensures zero\n        //     mstore(0x40, add(mark, 288))              // update free memory pointer\n        //     mstore(mark, 0x20)                        // bytes type data offset\n        //     mstore(add(mark, 0x20), 224)              // bytes size (padded)\n        //     calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n        //     log4(mark, 288,                           // calldata\n        //          shl(224, shr(224, calldataload(0))), // msg.sig\n        //          caller(),                              // msg.sender\n        //          calldataload(4),                     // arg1\n        //          calldataload(36)                     // arg2\n        //         )\n        // }\n    }\n}\n\ninterface INUSD {\n    // --- Auth ---\n    function wards() external returns (uint256);\n\n    function rely(address guy) external;\n\n    function deny(address guy) external;\n\n    // --- Token ---\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function mint(address usr, uint256 wad) external;\n\n    function burn(address usr, uint256 wad) external;\n\n    function approve(address usr, uint256 wad) external returns (bool);\n\n    // --- Alias ---\n    function push(address usr, uint256 wad) external;\n\n    function pull(address usr, uint256 wad) external;\n\n    function move(\n        address src,\n        address dst,\n        uint256 wad\n    ) external;\n\n    // --- Approve by signature ---\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/NUSD.sol\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity 0.5.12; */\n\n/* import \"./lib.sol\"; */\n\ncontract MockNUSD is LibNote {\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n\n    // --- Auth ---\n    mapping(address => uint256) public wards;\n\n    function rely(address guy) external note auth {\n        wards[guy] = 1;\n    }\n\n    function deny(address guy) external note auth {\n        wards[guy] = 0;\n    }\n\n    modifier auth() {\n        require(wards[msg.sender] == 1, \"NUSD/not-authorized\");\n        _;\n    }\n\n    // --- ERC20 Data ---\n    string public constant name = \"NUSD Stablecoin\";\n    string public constant symbol = \"NUSD\";\n    string public constant version = \"1\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n    uint256 public NUSDlyNUSDLimit;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) private allowances;\n    mapping(address => uint256) public nonces;\n    mapping(address => uint256) public lastMintRestart;\n    mapping(address => uint256) public NUSDMintedToday;\n\n    // event Approval(address indexed src, address indexed guy, uint wad);\n    // event Transfer(address indexed src, address indexed dst, uint wad);\n\n    // --- Math ---\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    // --- EIP712 niceties ---\n    bytes32 public DOMAIN_SEPARATOR;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n\n    constructor(uint256 chainId_) {\n        wards[msg.sender] = 1;\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                chainId_,\n                address(this)\n            )\n        );\n        NUSDlyNUSDLimit = 10000000000000000000000;\n    }\n\n    function allowance(address account_, address sender_)\n        external\n        view\n        returns (uint256)\n    {\n        return _allowance(account_, sender_);\n    }\n\n    function _allowance(address account_, address sender_)\n        internal\n        view\n        returns (uint256)\n    {\n        return allowances[account_][sender_];\n    }\n\n    // --- Token ---\n    function transfer(address dst, uint256 wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad, \"NUSD/insufficient-balance\");\n        if (src != msg.sender && _allowance(src, msg.sender) != uint256(-1)) {\n            require(\n                _allowance(src, msg.sender) >= wad,\n                \"NUSD/insufficient-allowance\"\n            );\n            allowances[src][msg.sender] = sub(_allowance(src, msg.sender), wad);\n        }\n        balanceOf[src] = sub(balanceOf[src], wad);\n        balanceOf[dst] = add(balanceOf[dst], wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n\n    function addAuth(address usr) external auth {\n        wards[usr] = 1;\n    }\n\n    function adjustNUSDlyNUSDLimit(uint256 _limit) external auth {\n        NUSDlyNUSDLimit = _limit;\n    }\n\n    function mint(address usr, uint256 wad) external {\n        if (wards[msg.sender] == 0) {\n            require(\n                add(wad, NUSDMintedToday[msg.sender]) <= NUSDlyNUSDLimit ||\n                    (sub(block.number, lastMintRestart[msg.sender]) >= 6500 &&\n                        wad <= NUSDlyNUSDLimit),\n                \"Over NUSDly NUSD Limit\"\n            );\n            if (sub(block.number, lastMintRestart[msg.sender]) >= 6500) {\n                NUSDMintedToday[msg.sender] = wad;\n                lastMintRestart[msg.sender] = block.number;\n            } else {\n                NUSDMintedToday[msg.sender] = add(\n                    NUSDMintedToday[msg.sender],\n                    wad\n                );\n            }\n        }\n\n        balanceOf[usr] = add(balanceOf[usr], wad);\n\n        totalSupply = add(totalSupply, wad);\n\n        emit Transfer(address(0), usr, wad);\n    }\n\n    function burn(address usr, uint256 wad) external {\n        require(balanceOf[usr] >= wad, \"NUSD/insufficient-balance\");\n        if (usr != msg.sender && _allowance(usr, msg.sender) != uint256(-1)) {\n            require(\n                _allowance(usr, msg.sender) >= wad,\n                \"NUSD/insufficient-allowance\"\n            );\n            allowances[usr][msg.sender] = sub(_allowance(usr, msg.sender), wad);\n        }\n        balanceOf[usr] = sub(balanceOf[usr], wad);\n        totalSupply = sub(totalSupply, wad);\n        emit Transfer(usr, address(0), wad);\n    }\n\n    function _approve(address usr, uint256 wad) internal returns (bool) {\n        allowances[msg.sender][usr] = wad;\n\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n\n    function approve(address usr_, uint256 wad_) external returns (bool) {\n        return _approve(usr_, wad_);\n    }\n\n    // --- Alias ---\n    function push(address usr, uint256 wad) external {\n        transferFrom(msg.sender, usr, wad);\n    }\n\n    function pull(address usr, uint256 wad) external {\n        transferFrom(usr, msg.sender, wad);\n    }\n\n    function move(\n        address src,\n        address dst,\n        uint256 wad\n    ) external {\n        transferFrom(src, dst, wad);\n    }\n\n    // --- Approve by signature ---\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        holder,\n                        spender,\n                        nonce,\n                        expiry,\n                        allowed\n                    )\n                )\n            )\n        );\n\n        require(holder != address(0), \"NUSD/invalid-address-0\");\n        require(holder == ecrecover(digest, v, r, s), \"NUSD/invalid-permit\");\n        require(\n            expiry == 0 || block.timestamp <= expiry,\n            \"NUSD/permit-expired\"\n        );\n        require(nonce == nonces[holder]++, \"NUSD/invalid-nonce\");\n        uint256 wad = allowed ? uint256(-1) : 0;\n        allowances[holder][spender] = wad;\n        emit Approval(holder, spender, wad);\n    }\n}\n"
    },
    "contracts/tokens/Necc/StakingWarmup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract StakingWarmup {\n    address public immutable staking;\n    address public immutable nNecc;\n\n    constructor(address _staking, address _nNecc) {\n        require(_staking != address(0));\n        staking = _staking;\n        require(_nNecc != address(0));\n        nNecc = _nNecc;\n    }\n\n    function retrieve(address _staker, uint256 _amount) external {\n        require(msg.sender == staking);\n        IERC20(nNecc).transfer(_staker, _amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}