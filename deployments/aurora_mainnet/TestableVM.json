{
  "address": "0x8F110B92B427eA47fB0B336f1b682cF454e247bF",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract VM",
          "name": "_vm",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "commands",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes[]",
          "name": "state",
          "type": "bytes[]"
        }
      ],
      "name": "execute",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vm",
      "outputs": [
        {
          "internalType": "contract VM",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x7ece4ec48a49d5e31844c949e3e788b7c31773d4eb266bc554d55669f37e7f10",
  "receipt": {
    "to": null,
    "from": "0xdF1d35b28dadeC2fFe56f72614e62B08A757CA31",
    "contractAddress": "0x8F110B92B427eA47fB0B336f1b682cF454e247bF",
    "transactionIndex": 0,
    "gasUsed": "648112",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x69d1b3a275eb1eadd3a9fd7836d01737d0923e5aaa655d5b5f30c5de6975af16",
    "transactionHash": "0x7ece4ec48a49d5e31844c949e3e788b7c31773d4eb266bc554d55669f37e7f10",
    "logs": [],
    "blockNumber": 54986251,
    "cumulativeGasUsed": "0",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x4F69f0Ce4d1431f407218758Bc6eD765CCb5aEb2"
  ],
  "solcInputHash": "51e0a29016eb8a808231ef727f964484",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract VM\",\"name\":\"_vm\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"commands\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"state\",\"type\":\"bytes[]\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vm\",\"outputs\":[{\"internalType\":\"contract VM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/weiroll/TestableVM.sol\":\"TestableVM\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/weiroll/CommandBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nuint256 constant IDX_VARIABLE_LENGTH = 0x80;\\nuint256 constant IDX_VALUE_MASK = 0x7f;\\nuint256 constant IDX_END_OF_ARGS = 0xff;\\nuint256 constant IDX_USE_STATE = 0xfe;\\n\\nlibrary CommandBuilder {\\n    function buildInputs(\\n        bytes[] memory state,\\n        bytes4 selector,\\n        bytes32 indices\\n    ) internal view returns (bytes memory ret) {\\n        uint256 count = 0; // Number of bytes in whole ABI encoded message\\n        uint256 free = 0; // Pointer to first free byte in tail part of message\\n        bytes memory stateData; // Optionally encode the current state if the call requires it\\n\\n        uint256 idx;\\n\\n        // Determine the length of the encoded data\\n        for (uint256 i = 0; i < 32; i++) {\\n            idx = uint8(indices[i]);\\n            if (idx == IDX_END_OF_ARGS) break;\\n\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    if (stateData.length == 0) {\\n                        stateData = abi.encode(state);\\n                    }\\n                    count += stateData.length;\\n                    free += 32;\\n                } else {\\n                    // Add the size of the value, rounded up to the next word boundary, plus space for pointer and length\\n                    uint256 arglen = state[idx & IDX_VALUE_MASK].length;\\n                    require(\\n                        arglen % 32 == 0,\\n                        \\\"Dynamic state variables must be a multiple of 32 bytes\\\"\\n                    );\\n                    count += arglen + 32;\\n                    free += 32;\\n                }\\n            } else {\\n                require(\\n                    state[idx & IDX_VALUE_MASK].length == 32,\\n                    \\\"Static state variables must be 32 bytes\\\"\\n                );\\n                count += 32;\\n                free += 32;\\n            }\\n        }\\n\\n        // Encode it\\n        ret = new bytes(count + 4);\\n        assembly {\\n            mstore(add(ret, 32), selector)\\n        }\\n        count = 0;\\n        for (uint256 i = 0; i < 32; i++) {\\n            idx = uint8(indices[i]);\\n            if (idx == IDX_END_OF_ARGS) break;\\n\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    memcpy(stateData, 32, ret, free + 4, stateData.length - 32);\\n                    free += stateData.length - 32;\\n                    count += 32;\\n                } else {\\n                    uint256 arglen = state[idx & IDX_VALUE_MASK].length;\\n\\n                    // Variable length data; put a pointer in the slot and write the data at the end\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    memcpy(\\n                        state[idx & IDX_VALUE_MASK],\\n                        0,\\n                        ret,\\n                        free + 4,\\n                        arglen\\n                    );\\n                    free += arglen;\\n                    count += 32;\\n                }\\n            } else {\\n                // Fixed length data; write it directly\\n                bytes memory statevar = state[idx & IDX_VALUE_MASK];\\n                assembly {\\n                    mstore(add(add(ret, 36), count), mload(add(statevar, 32)))\\n                }\\n                count += 32;\\n            }\\n        }\\n    }\\n\\n    function writeOutputs(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal pure returns (bytes[] memory) {\\n        uint256 idx = uint8(index);\\n        if (idx == IDX_END_OF_ARGS) return state;\\n\\n        if (idx & IDX_VARIABLE_LENGTH != 0) {\\n            if (idx == IDX_USE_STATE) {\\n                state = abi.decode(output, (bytes[]));\\n            } else {\\n                // Check the first field is 0x20 (because we have only a single return value)\\n                uint256 argptr;\\n                assembly {\\n                    argptr := mload(add(output, 32))\\n                }\\n                require(\\n                    argptr == 32,\\n                    \\\"Only one return value permitted (variable)\\\"\\n                );\\n\\n                assembly {\\n                    // Overwrite the first word of the return data with the length - 32\\n                    mstore(add(output, 32), sub(mload(output), 32))\\n                    // Insert a pointer to the return data, starting at the second word, into state\\n                    mstore(\\n                        add(add(state, 32), mul(and(idx, IDX_VALUE_MASK), 32)),\\n                        add(output, 32)\\n                    )\\n                }\\n            }\\n        } else {\\n            // Single word\\n            require(\\n                output.length == 32,\\n                \\\"Only one return value permitted (static)\\\"\\n            );\\n\\n            state[idx & IDX_VALUE_MASK] = output;\\n        }\\n\\n        return state;\\n    }\\n\\n    function writeTuple(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal view {\\n        uint8 idx = uint8(index);\\n        if (idx == IDX_END_OF_ARGS) return;\\n\\n        bytes memory entry = state[idx] = new bytes(output.length + 32);\\n        memcpy(output, 0, entry, 32, output.length);\\n        assembly {\\n            let l := mload(output)\\n            mstore(add(entry, 32), l)\\n        }\\n    }\\n\\n    function memcpy(\\n        bytes memory src,\\n        uint256 srcidx,\\n        bytes memory dest,\\n        uint256 destidx,\\n        uint256 len\\n    ) internal view {\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    4,\\n                    add(add(src, 32), srcidx),\\n                    len,\\n                    add(add(dest, 32), destidx),\\n                    len\\n                )\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8c0aad0ee670ff08b9e8ec0f2af647eb8d8239f86cf2cf0f29401d5e2859c6cc\",\"license\":\"MIT\"},\"contracts/weiroll/TestableVM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./VM.sol\\\";\\n\\ncontract TestableVM {\\n    VM public vm;\\n\\n    constructor(VM _vm) {\\n        vm = _vm;\\n    }\\n\\n    function execute(bytes32[] calldata commands, bytes[] memory state)\\n        public\\n        returns (bytes[] memory)\\n    {\\n        (bool success, bytes memory data) = address(vm).delegatecall(\\n            abi.encodeWithSelector(VM.execute.selector, commands, state)\\n        );\\n        require(success, \\\"TestableVM: execution failed\\\");\\n\\n        return abi.decode(data, (bytes[]));\\n    }\\n}\\n\",\"keccak256\":\"0x0e5b1720db6b45bd0c617d3b3d0609cd47d6d1754a311f956c088819b67bbfcd\",\"license\":\"MIT\"},\"contracts/weiroll/VM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CommandBuilder.sol\\\";\\n\\nuint8 constant FLAG_CT_DELEGATECALL = 0x00;\\nuint8 constant FLAG_CT_CALL = 0x01;\\nuint8 constant FLAG_CT_STATICCALL = 0x02;\\nuint8 constant FLAG_CT_VALUECALL = 0x03;\\nuint8 constant FLAG_CT_MASK = 0x03;\\nuint8 constant FLAG_EXTENDED_COMMAND = 0x80;\\nuint8 constant FLAG_TUPLE_RETURN = 0x40;\\n\\nuint256 constant SHORT_COMMAND_FILL = 0x000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\ncontract VM {\\n    using CommandBuilder for bytes[];\\n\\n    address immutable self;\\n\\n    modifier ensureDelegateCall() {\\n        require(address(this) != self);\\n        _;\\n    }\\n\\n    constructor() {\\n        self = address(this);\\n    }\\n\\n    function execute(bytes32[] calldata commands, bytes[] memory state)\\n        public\\n        ensureDelegateCall\\n        returns (bytes[] memory)\\n    {\\n        bytes32 command;\\n        uint256 flags;\\n        bytes32 indices;\\n\\n        bool success;\\n        bytes memory outdata;\\n\\n        for (uint256 i = 0; i < commands.length; i++) {\\n            command = commands[i];\\n            flags = uint8(bytes1(command << 32));\\n\\n            if (flags & FLAG_EXTENDED_COMMAND != 0) {\\n                indices = commands[i++];\\n            } else {\\n                indices = bytes32(uint256(command << 40) | SHORT_COMMAND_FILL);\\n            }\\n\\n            if (flags & FLAG_CT_MASK == FLAG_CT_DELEGATECALL) {\\n                (success, outdata) = address(uint160(uint256(command))) // target\\n                    .delegatecall(\\n                        // inputs\\n                        state.buildInputs(\\n                            //selector\\n                            bytes4(command),\\n                            indices\\n                        )\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_CALL) {\\n                (success, outdata) = address(uint160(uint256(command))).call( // target\\n                    // inputs\\n                    state.buildInputs(\\n                        //selector\\n                        bytes4(command),\\n                        indices\\n                    )\\n                );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_STATICCALL) {\\n                (success, outdata) = address(uint160(uint256(command))) // target\\n                    .staticcall(\\n                        // inputs\\n                        state.buildInputs(\\n                            //selector\\n                            bytes4(command),\\n                            indices\\n                        )\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_VALUECALL) {\\n                uint256 calleth;\\n                bytes memory v = state[uint8(bytes1(indices))];\\n                assembly {\\n                    mstore(calleth, add(v, 0x20))\\n                }\\n                (success, outdata) = address(uint160(uint256(command))).call{ // target\\n                    value: calleth\\n                }(\\n                    // inputs\\n                    state.buildInputs(\\n                        //selector\\n                        bytes4(command),\\n                        bytes32(uint256(indices << 8) | IDX_END_OF_ARGS)\\n                    )\\n                );\\n            } else {\\n                revert(\\\"Invalid calltype\\\");\\n            }\\n\\n            require(success, \\\"Call failed\\\");\\n\\n            if (flags & FLAG_TUPLE_RETURN != 0) {\\n                state.writeTuple(bytes1(command << 88), outdata);\\n            } else {\\n                state = state.writeOutputs(bytes1(command << 88), outdata);\\n            }\\n        }\\n        return state;\\n    }\\n}\\n\",\"keccak256\":\"0x6c5ca5238b03f64cb9b7d80045b532618dc54c5822e3e89cb73f227094c8bbed\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051610b79380380610b79833981810160405281019061003291906100ed565b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505061011a565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006100a88261007d565b9050919050565b60006100ba8261009d565b9050919050565b6100ca816100af565b81146100d557600080fd5b50565b6000815190506100e7816100c1565b92915050565b60006020828403121561010357610102610078565b5b6000610111848285016100d8565b91505092915050565b610a50806101296000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80633a7684631461003b578063de792d5f14610059575b600080fd5b610043610089565b6040516100509190610293565b60405180910390f35b610073600480360381019061006e9190610549565b6100ad565b604051610080919061070f565b60405180910390f35b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b606060008060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663de792d5f60e01b878787604051602401610106939291906107a3565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040516101709190610818565b600060405180830381855af49150503d80600081146101ab576040519150601f19603f3d011682016040523d82523d6000602084013e6101b0565b606091505b5091509150816101f5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016101ec9061088c565b60405180910390fd5b8080602001905181019061020991906109d1565b925050509392505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061025961025461024f84610214565b610234565b610214565b9050919050565b600061026b8261023e565b9050919050565b600061027d82610260565b9050919050565b61028d81610272565b82525050565b60006020820190506102a86000830184610284565b92915050565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f8401126102e7576102e66102c2565b5b8235905067ffffffffffffffff811115610304576103036102c7565b5b6020830191508360208202830111156103205761031f6102cc565b5b9250929050565b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61037082610327565b810181811067ffffffffffffffff8211171561038f5761038e610338565b5b80604052505050565b60006103a26102ae565b90506103ae8282610367565b919050565b600067ffffffffffffffff8211156103ce576103cd610338565b5b602082029050602081019050919050565b600080fd5b600067ffffffffffffffff8211156103ff576103fe610338565b5b61040882610327565b9050602081019050919050565b82818337600083830152505050565b6000610437610432846103e4565b610398565b905082815260208101848484011115610453576104526103df565b5b61045e848285610415565b509392505050565b600082601f83011261047b5761047a6102c2565b5b813561048b848260208601610424565b91505092915050565b60006104a76104a2846103b3565b610398565b905080838252602082019050602084028301858111156104ca576104c96102cc565b5b835b8181101561051157803567ffffffffffffffff8111156104ef576104ee6102c2565b5b8086016104fc8982610466565b855260208501945050506020810190506104cc565b5050509392505050565b600082601f8301126105305761052f6102c2565b5b8135610540848260208601610494565b91505092915050565b600080600060408486031215610562576105616102b8565b5b600084013567ffffffffffffffff8111156105805761057f6102bd565b5b61058c868287016102d1565b9350935050602084013567ffffffffffffffff8111156105af576105ae6102bd565b5b6105bb8682870161051b565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561062b578082015181840152602081019050610610565b8381111561063a576000848401525b50505050565b600061064b826105f1565b61065581856105fc565b935061066581856020860161060d565b61066e81610327565b840191505092915050565b60006106858383610640565b905092915050565b6000602082019050919050565b60006106a5826105c5565b6106af81856105d0565b9350836020820285016106c1856105e1565b8060005b858110156106fd57848403895281516106de8582610679565b94506106e98361068d565b925060208a019950506001810190506106c5565b50829750879550505050505092915050565b60006020820190508181036000830152610729818461069a565b905092915050565b600082825260208201905092915050565b600080fd5b60006107538385610731565b93507f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83111561078657610785610742565b5b602083029250610797838584610415565b82840190509392505050565b600060408201905081810360008301526107be818587610747565b905081810360208301526107d2818461069a565b9050949350505050565b600081905092915050565b60006107f2826105f1565b6107fc81856107dc565b935061080c81856020860161060d565b80840191505092915050565b600061082482846107e7565b915081905092915050565b600082825260208201905092915050565b7f5465737461626c65564d3a20657865637574696f6e206661696c656400000000600082015250565b6000610876601c8361082f565b915061088182610840565b602082019050919050565b600060208201905081810360008301526108a581610869565b9050919050565b60006108bf6108ba846103e4565b610398565b9050828152602081018484840111156108db576108da6103df565b5b6108e684828561060d565b509392505050565b600082601f830112610903576109026102c2565b5b81516109138482602086016108ac565b91505092915050565b600061092f61092a846103b3565b610398565b90508083825260208201905060208402830185811115610952576109516102cc565b5b835b8181101561099957805167ffffffffffffffff811115610977576109766102c2565b5b80860161098489826108ee565b85526020850194505050602081019050610954565b5050509392505050565b600082601f8301126109b8576109b76102c2565b5b81516109c884826020860161091c565b91505092915050565b6000602082840312156109e7576109e66102b8565b5b600082015167ffffffffffffffff811115610a0557610a046102bd565b5b610a11848285016109a3565b9150509291505056fea2646970667358221220ae67aa346373e6a93de491ec028f4b809cd1c1b78a038fc67b2eca4a7ab5bafc64736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80633a7684631461003b578063de792d5f14610059575b600080fd5b610043610089565b6040516100509190610293565b60405180910390f35b610073600480360381019061006e9190610549565b6100ad565b604051610080919061070f565b60405180910390f35b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b606060008060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663de792d5f60e01b878787604051602401610106939291906107a3565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040516101709190610818565b600060405180830381855af49150503d80600081146101ab576040519150601f19603f3d011682016040523d82523d6000602084013e6101b0565b606091505b5091509150816101f5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016101ec9061088c565b60405180910390fd5b8080602001905181019061020991906109d1565b925050509392505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061025961025461024f84610214565b610234565b610214565b9050919050565b600061026b8261023e565b9050919050565b600061027d82610260565b9050919050565b61028d81610272565b82525050565b60006020820190506102a86000830184610284565b92915050565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f8401126102e7576102e66102c2565b5b8235905067ffffffffffffffff811115610304576103036102c7565b5b6020830191508360208202830111156103205761031f6102cc565b5b9250929050565b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61037082610327565b810181811067ffffffffffffffff8211171561038f5761038e610338565b5b80604052505050565b60006103a26102ae565b90506103ae8282610367565b919050565b600067ffffffffffffffff8211156103ce576103cd610338565b5b602082029050602081019050919050565b600080fd5b600067ffffffffffffffff8211156103ff576103fe610338565b5b61040882610327565b9050602081019050919050565b82818337600083830152505050565b6000610437610432846103e4565b610398565b905082815260208101848484011115610453576104526103df565b5b61045e848285610415565b509392505050565b600082601f83011261047b5761047a6102c2565b5b813561048b848260208601610424565b91505092915050565b60006104a76104a2846103b3565b610398565b905080838252602082019050602084028301858111156104ca576104c96102cc565b5b835b8181101561051157803567ffffffffffffffff8111156104ef576104ee6102c2565b5b8086016104fc8982610466565b855260208501945050506020810190506104cc565b5050509392505050565b600082601f8301126105305761052f6102c2565b5b8135610540848260208601610494565b91505092915050565b600080600060408486031215610562576105616102b8565b5b600084013567ffffffffffffffff8111156105805761057f6102bd565b5b61058c868287016102d1565b9350935050602084013567ffffffffffffffff8111156105af576105ae6102bd565b5b6105bb8682870161051b565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561062b578082015181840152602081019050610610565b8381111561063a576000848401525b50505050565b600061064b826105f1565b61065581856105fc565b935061066581856020860161060d565b61066e81610327565b840191505092915050565b60006106858383610640565b905092915050565b6000602082019050919050565b60006106a5826105c5565b6106af81856105d0565b9350836020820285016106c1856105e1565b8060005b858110156106fd57848403895281516106de8582610679565b94506106e98361068d565b925060208a019950506001810190506106c5565b50829750879550505050505092915050565b60006020820190508181036000830152610729818461069a565b905092915050565b600082825260208201905092915050565b600080fd5b60006107538385610731565b93507f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83111561078657610785610742565b5b602083029250610797838584610415565b82840190509392505050565b600060408201905081810360008301526107be818587610747565b905081810360208301526107d2818461069a565b9050949350505050565b600081905092915050565b60006107f2826105f1565b6107fc81856107dc565b935061080c81856020860161060d565b80840191505092915050565b600061082482846107e7565b915081905092915050565b600082825260208201905092915050565b7f5465737461626c65564d3a20657865637574696f6e206661696c656400000000600082015250565b6000610876601c8361082f565b915061088182610840565b602082019050919050565b600060208201905081810360008301526108a581610869565b9050919050565b60006108bf6108ba846103e4565b610398565b9050828152602081018484840111156108db576108da6103df565b5b6108e684828561060d565b509392505050565b600082601f830112610903576109026102c2565b5b81516109138482602086016108ac565b91505092915050565b600061092f61092a846103b3565b610398565b90508083825260208201905060208402830185811115610952576109516102cc565b5b835b8181101561099957805167ffffffffffffffff811115610977576109766102c2565b5b80860161098489826108ee565b85526020850194505050602081019050610954565b5050509392505050565b600082601f8301126109b8576109b76102c2565b5b81516109c884826020860161091c565b91505092915050565b6000602082840312156109e7576109e66102b8565b5b600082015167ffffffffffffffff811115610a0557610a046102bd565b5b610a11848285016109a3565b9150509291505056fea2646970667358221220ae67aa346373e6a93de491ec028f4b809cd1c1b78a038fc67b2eca4a7ab5bafc64736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 23126,
        "contract": "contracts/weiroll/TestableVM.sol:TestableVM",
        "label": "vm",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(VM)23533"
      }
    ],
    "types": {
      "t_contract(VM)23533": {
        "encoding": "inplace",
        "label": "contract VM",
        "numberOfBytes": "20"
      }
    }
  }
}